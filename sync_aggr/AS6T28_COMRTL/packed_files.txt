===FILE_START===app_common/pulse_cnt.v===END_HEADER===
module pulse_cnt#(
    parameter   CNT_WDTH    =   32
)(/*AUTOARG*/
   // Outputs
   cnt,
   // Inputs
   clk, rst_n, clear, pulse
   );
input                   clk;
input                   rst_n;
input                   clear;
input                   pulse;
output [CNT_WDTH-1:0]   cnt;

reg    [CNT_WDTH-1:0]   cnt;
always@(posedge clk or negedge rst_n)begin
    if(~rst_n)
        cnt <= {CNT_WDTH{1'd0}};
    else if(clear)
        cnt <= {CNT_WDTH{1'd0}};
    else if(pulse)
        cnt <= (cnt == {CNT_WDTH{1'd1}}) ? cnt :cnt + 1'd1 ;
end

endmodule

===FILE_END===app_common/pulse_cnt.v===
===FILE_START===app_common/app_pkt_filter_lane.v===END_HEADER===
module   app_pkt_filter_lane (/*AUTOARG*/
   // Outputs
   out_csi_data, out_bytes_en, out_header_en, out_data_en,
   out_data_type, out_virtual_channel, out_word_count, out_pkt_crc_en,
   out_pkt_crc, out_ecc, out_dvalid, out_hvalid, out_vvalid,
   out_data_crc,
   // Inputs
   app_clk_data, app_clk_rst_n, reg_mem_dt1_selz, reg_mem_dt2_selz,
   reg_mem_dt7_selz, reg_mem_dt8_selz, reg_mem_dt3_selz,
   reg_mem_dt4_selz, reg_mem_dt3_selz_en, reg_mem_dt4_selz_en,
   reg_vc_selz_l, reg_vc_selz_h, in_csi_data, in_bytes_en,
   in_header_en, in_data_en, in_data_type, in_virtual_channel,
   in_word_count, in_pkt_crc_en, in_pkt_crc, in_ecc, in_dvalid,
   in_hvalid, in_vvalid, in_data_crc
   );

output  [64-1:0]  out_csi_data            ;
output  [3-1:0]   out_bytes_en            ;
output            out_header_en           ;
output            out_data_en             ;
output  [5:0]     out_data_type           ;
output  [4-1:0]   out_virtual_channel     ;
output  [15:0]    out_word_count          ;
output            out_pkt_crc_en          ;
output  [31:0]    out_pkt_crc             ;
output  [7:0]     out_ecc                 ;
output  [16-1:0]  out_dvalid              ;
output  [16-1:0]  out_hvalid              ;
output  [16-1:0]  out_vvalid              ;
output  [32-1:0]  out_data_crc            ;

input             app_clk_data            ;
input             app_clk_rst_n           ;

input   [6:0]     reg_mem_dt1_selz        ;
input   [6:0]     reg_mem_dt2_selz        ;
input   [6:0]     reg_mem_dt7_selz        ;
input   [6:0]     reg_mem_dt8_selz        ;
input   [7:0]     reg_mem_dt3_selz        ;
input   [7:0]     reg_mem_dt4_selz        ;
input             reg_mem_dt3_selz_en     ;
input             reg_mem_dt4_selz_en     ;
input   [7:0]     reg_vc_selz_l           ;
input   [7:0]     reg_vc_selz_h           ;

input   [64-1:0]  in_csi_data             ;
input   [3-1:0]   in_bytes_en             ;
input             in_header_en            ;
input             in_data_en              ;
input   [5:0]     in_data_type            ;
input   [4-1:0]   in_virtual_channel      ;
input   [15:0]    in_word_count           ;
input             in_pkt_crc_en           ;
input   [31:0]    in_pkt_crc              ;
input   [7:0]     in_ecc                  ;
input   [16-1:0]  in_dvalid               ;
input   [16-1:0]  in_hvalid               ;
input   [16-1:0]  in_vvalid               ;
input   [32-1:0]  in_data_crc             ;

reg               dt_enable_flag1         ;
reg               dt_enable_flag2         ;
reg               dt_enable_flag3         ;
reg               dt_enable_flag4         ;
reg               dtvc_enable_flag5       ;
reg               dtvc_enable_flag6       ;
reg               vc_enable_flag7         ;
reg               vc_enable_flag8         ;
wire              dt_enable_d1            ;
wire              dtvc_enable_d2          ;
wire              vc_enable_d3            ;

app_idi_host    app_idi_i        ;
app_idi_host    app_idi_d1       ;
app_idi_host    app_idi_d1_pre   ;
app_idi_host    app_idi_d2       ;
app_idi_host    app_idi_d2_pre   ;
app_idi_host    app_idi_d3       ;
app_idi_host    app_idi_d3_pre   ;
app_idi_host    app_idi_d4       ;
app_idi_host    app_idi_o        ;

//32+`MEP_CSI2_HOST_IDI_CSIDATA_SIZE+`MEP_CSI2_HOST_BYTES_EN_SIZE+`MEP_CSI2_HOST_VC_WIDTH+(3*`MEP_CSI2_HOST_N_VIRT_CH)+crc+crc_en;
localparam    IDI_BUS_WIDTH = 32+64+3+4+(3*16)+32+32+1;

assign    app_idi_i.csi_data        = in_csi_data                   ;
assign    app_idi_i.bytes_en        = in_bytes_en                   ;
assign    app_idi_i.header_en       = in_header_en                  ;
assign    app_idi_i.data_en         = in_data_en                    ;
assign    app_idi_i.data_type       = in_data_type                  ;
assign    app_idi_i.virtual_channel = in_virtual_channel            ;
assign    app_idi_i.word_count      = in_word_count                 ;
assign    app_idi_i.ecc             = in_ecc                        ;
assign    app_idi_i.pkt_crc_en      = in_pkt_crc_en                 ;
assign    app_idi_i.pkt_crc         = in_pkt_crc                    ;
assign    app_idi_i.dvalid          = in_dvalid                     ;
assign    app_idi_i.hvalid          = in_hvalid                     ;
assign    app_idi_i.vvalid          = in_vvalid                     ;
assign    app_idi_i.data_crc        = in_data_crc                   ;
assign    out_csi_data              = app_idi_d3.csi_data           ;
assign    out_bytes_en              = app_idi_d3.bytes_en           ;
assign    out_header_en             = app_idi_d3.header_en          ;
assign    out_data_en               = app_idi_d3.data_en            ;
assign    out_data_type             = app_idi_d3.data_type          ;
assign    out_virtual_channel       = app_idi_d3.virtual_channel    ;
assign    out_word_count            = app_idi_d3.word_count         ;
assign    out_ecc                   = app_idi_d3.ecc                ;
assign    out_pkt_crc_en            = app_idi_d3.pkt_crc_en         ;
assign    out_pkt_crc               = app_idi_d3.pkt_crc            ;
assign    out_dvalid                = app_idi_d3.dvalid             ;
assign    out_hvalid                = app_idi_d3.hvalid             ;
assign    out_vvalid                = app_idi_d3.vvalid             ;           
assign    out_data_crc              = app_idi_d3.data_crc           ;           

always@(posedge app_clk_data or negedge app_clk_rst_n)begin
    if(~app_clk_rst_n)
        dt_enable_flag1 <= 1'd0;
    //permit csi short packet
    else if((reg_mem_dt1_selz[6])&&(app_idi_i.data_type[5:2]==4'd0)&&app_idi_i.header_en)
        dt_enable_flag1 <= 1'd1;
    else if((reg_mem_dt1_selz[6])&&(app_idi_i.data_type==reg_mem_dt1_selz[5:0])&&app_idi_i.header_en)
        dt_enable_flag1 <= 1'd1;
    else
        dt_enable_flag1 <= 1'd0;
end

always@(posedge app_clk_data or negedge app_clk_rst_n)begin
    if(~app_clk_rst_n)
        dt_enable_flag2 <= 1'd0;
    else if((reg_mem_dt2_selz[6])&&(app_idi_i.data_type[5:2]==4'd0)&&app_idi_i.header_en)
        dt_enable_flag2 <= 1'd1;
    else if((reg_mem_dt2_selz[6])&&(app_idi_i.data_type==reg_mem_dt2_selz[5:0])&&app_idi_i.header_en)
        dt_enable_flag2 <= 1'd1;
    else
        dt_enable_flag2 <= 1'd0;
end

always@(posedge app_clk_data or negedge app_clk_rst_n)begin
    if(~app_clk_rst_n)
        dt_enable_flag3 <= 1'd0;
    else if((reg_mem_dt7_selz[6])&&(app_idi_i.data_type[5:2]==4'd0)&&app_idi_i.header_en)
        dt_enable_flag3 <= 1'd1;
    else if((reg_mem_dt7_selz[6])&&(app_idi_i.data_type==reg_mem_dt7_selz[5:0])&&app_idi_i.header_en)
        dt_enable_flag3 <= 1'd1;
    else
        dt_enable_flag3 <= 1'd0;
end

always@(posedge app_clk_data or negedge app_clk_rst_n)begin
    if(~app_clk_rst_n)
        dt_enable_flag4 <= 1'd0;
    else if((reg_mem_dt8_selz[6])&&(app_idi_i.data_type[5:2]==4'd0)&&app_idi_i.header_en)
        dt_enable_flag4 <= 1'd1;
    else if((reg_mem_dt8_selz[6])&&(app_idi_i.data_type==reg_mem_dt8_selz[5:0])&&app_idi_i.header_en)
        dt_enable_flag4 <= 1'd1;
    else
        dt_enable_flag4 <= 1'd0;
end

assign dt_enable_d1 = (reg_mem_dt1_selz[6]|reg_mem_dt2_selz[6]|reg_mem_dt7_selz[6]|reg_mem_dt8_selz[6]) ? (dt_enable_flag1|dt_enable_flag2|dt_enable_flag3|dt_enable_flag4) : 1'd1;

/*    bus_delay    AUTO_TEMPLATE(
    .clk    (app_clk_data),
    .rst_n  (app_clk_rst_n),
    .inbus  (app_idi_i),
    .outbus (app_idi_d1_pre),
);*/
bus_delay #(
    .DELAY_CYCLES (1),
    .BUS_WIDTH    (IDI_BUS_WIDTH)
)u0_bus_delay(
	     .outbus		(app_idi_d1_pre),	
	     .inbus			(app_idi_i),	
        /*AUTOINST*/
	      // Inputs
	      .clk			(app_clk_data),		 // Templated
	      .rst_n			(app_clk_rst_n));	 // Templated

assign app_idi_d1 = app_idi_d1_pre & {IDI_BUS_WIDTH{dt_enable_d1}};

always@(posedge app_clk_data or negedge app_clk_rst_n)begin
    if(~app_clk_rst_n)
        dtvc_enable_flag5 <= 1'd0;
    //permit csi short packet within select vc
    else if((reg_mem_dt3_selz_en)&&({app_idi_d1.virtual_channel[1:0],app_idi_d1.data_type[5:2]}=={reg_mem_dt3_selz[7:6],4'd0})&&app_idi_d1.header_en)
        dtvc_enable_flag5 <= 1'd1;
    else if((reg_mem_dt3_selz_en)&&({app_idi_d1.virtual_channel[1:0],app_idi_d1.data_type}==reg_mem_dt3_selz[7:0])&&app_idi_d1.header_en)
        dtvc_enable_flag5 <= 1'd1;
    else
        dtvc_enable_flag5 <= 1'd0;
end

always@(posedge app_clk_data or negedge app_clk_rst_n)begin
    if(~app_clk_rst_n)
        dtvc_enable_flag6 <= 1'd0;
    else if((reg_mem_dt4_selz_en)&&({app_idi_d1.virtual_channel[1:0],app_idi_d1.data_type[5:2]}=={reg_mem_dt4_selz[7:6],4'd0})&&app_idi_d1.header_en)
        dtvc_enable_flag6 <= 1'd1;
    else if((reg_mem_dt4_selz_en)&&({app_idi_d1.virtual_channel[1:0],app_idi_d1.data_type}==reg_mem_dt4_selz[7:0])&&app_idi_d1.header_en)
        dtvc_enable_flag6 <= 1'd1;
    else
        dtvc_enable_flag6 <= 1'd0;
end

assign dtvc_enable_d2 = (reg_mem_dt3_selz_en|reg_mem_dt4_selz_en) ? (dtvc_enable_flag5|dtvc_enable_flag6) : 1'd1 ;

/*    bus_delay    AUTO_TEMPLATE(
    .clk    (app_clk_data),
    .rst_n    (app_clk_rst_n),
    .inbus    (app_idi_d1),
    .outbus    (app_idi_d2_pre),
);*/
bus_delay #(
    .DELAY_CYCLES (1),
    .BUS_WIDTH    (IDI_BUS_WIDTH)
)u1_bus_delay(
	     .outbus		(app_idi_d2_pre),
	     .inbus			(app_idi_d1),		 
        /*AUTOINST*/
	      // Inputs
	      .clk			(app_clk_data),		 // Templated
	      .rst_n			(app_clk_rst_n));	 // Templated

assign app_idi_d2 = app_idi_d2_pre & {IDI_BUS_WIDTH{dtvc_enable_d2}};

always@(posedge app_clk_data or negedge app_clk_rst_n)begin
    if(~app_clk_rst_n)
        vc_enable_flag7 <= 1'd0;
    else if((reg_vc_selz_l[0])&&(app_idi_d2.virtual_channel[3:0]==4'd0)&&app_idi_d2.header_en)
        vc_enable_flag7 <= 1'd1;                                                
    else if((reg_vc_selz_l[1])&&(app_idi_d2.virtual_channel[3:0]==4'd1)&&app_idi_d2.header_en)
        vc_enable_flag7 <= 1'd1;                                                
    else if((reg_vc_selz_l[2])&&(app_idi_d2.virtual_channel[3:0]==4'd2)&&app_idi_d2.header_en)
        vc_enable_flag7 <= 1'd1;                                                
    else if((reg_vc_selz_l[3])&&(app_idi_d2.virtual_channel[3:0]==4'd3)&&app_idi_d2.header_en)
        vc_enable_flag7 <= 1'd1;                                                
    else if((reg_vc_selz_l[4])&&(app_idi_d2.virtual_channel[3:0]==4'd4)&&app_idi_d2.header_en)
        vc_enable_flag7 <= 1'd1;                                                
    else if((reg_vc_selz_l[5])&&(app_idi_d2.virtual_channel[3:0]==4'd5)&&app_idi_d2.header_en)
        vc_enable_flag7 <= 1'd1;                                                
    else if((reg_vc_selz_l[6])&&(app_idi_d2.virtual_channel[3:0]==4'd6)&&app_idi_d2.header_en)
        vc_enable_flag7 <= 1'd1;                                                
    else if((reg_vc_selz_l[7])&&(app_idi_d2.virtual_channel[3:0]==4'd7)&&app_idi_d2.header_en)
        vc_enable_flag7 <= 1'd1;
    else 
        vc_enable_flag7 <= 1'd0;
end

always@(posedge app_clk_data or negedge app_clk_rst_n)begin
    if(~app_clk_rst_n)
        vc_enable_flag8 <= 1'd0;
    else if((reg_vc_selz_h[0])&&(app_idi_d2.virtual_channel[3:0]==4'd8)&&app_idi_d2.header_en)
        vc_enable_flag8 <= 1'd1;                                                
    else if((reg_vc_selz_h[1])&&(app_idi_d2.virtual_channel[3:0]==4'd9)&&app_idi_d2.header_en)
        vc_enable_flag8 <= 1'd1;                                                
    else if((reg_vc_selz_h[2])&&(app_idi_d2.virtual_channel[3:0]==4'd10)&&app_idi_d2.header_en)
        vc_enable_flag8 <= 1'd1;                                                
    else if((reg_vc_selz_h[3])&&(app_idi_d2.virtual_channel[3:0]==4'd11)&&app_idi_d2.header_en)
        vc_enable_flag8 <= 1'd1;                                                
    else if((reg_vc_selz_h[4])&&(app_idi_d2.virtual_channel[3:0]==4'd12)&&app_idi_d2.header_en)
        vc_enable_flag8 <= 1'd1;                                                
    else if((reg_vc_selz_h[5])&&(app_idi_d2.virtual_channel[3:0]==4'd13)&&app_idi_d2.header_en)
        vc_enable_flag8 <= 1'd1;                                                
    else if((reg_vc_selz_h[6])&&(app_idi_d2.virtual_channel[3:0]==4'd14)&&app_idi_d2.header_en)
        vc_enable_flag8 <= 1'd1;                                                
    else if((reg_vc_selz_h[7])&&(app_idi_d2.virtual_channel[3:0]==4'd15)&&app_idi_d2.header_en)
        vc_enable_flag8 <= 1'd1;
    else 
        vc_enable_flag8 <= 1'd0;
end

assign vc_enable_d3 = vc_enable_flag7 | vc_enable_flag8;

/*    bus_delay    AUTO_TEMPLATE(
    .clk    (app_clk_data),
    .rst_n  (app_clk_rst_n),
    .inbus  (app_idi_d2),
    .outbus (app_idi_d3_pre),
);*/
bus_delay #(
    .DELAY_CYCLES (1),
    .BUS_WIDTH    (IDI_BUS_WIDTH)
)u2_bus_delay(
	     .outbus		(app_idi_d3_pre),
	     .inbus			(app_idi_d2),
         /*AUTOINST*/
	      // Inputs
	      .clk			(app_clk_data),		 // Templated
	      .rst_n			(app_clk_rst_n));	 // Templated

assign app_idi_d3 = app_idi_d3_pre & {IDI_BUS_WIDTH{vc_enable_d3}};


endmodule 
//Local Variables:
//verilog-auto-inst-param-value : t
//verilog-library-files:("../BUS_DELAY/bus_delay.v")
//verilog-library-extensions:(".v"".vh"".sv"".svh")
//End:


===FILE_END===app_common/app_pkt_filter_lane.v===
===FILE_START===app_common/monitor_idi_packet.v===END_HEADER===
module monitor_idi_packet(/*AUTOARG*/
   // Outputs
   reg_rd_resv_pkt_cnt_lp_pf, reg_rd_resv_pkt_cnt_lp_ph,
   reg_rd_resv_pkt_cnt_sp_le, reg_rd_resv_pkt_cnt_sp_ls,
   reg_rd_resv_pkt_cnt_sp_fe, reg_rd_resv_pkt_cnt_sp_fs,
   // Inputs
   clk, rst_n, header_en, data_type, reg_resv_pkt_match_lp_dt,
   reg_resv_pkt_match_lp_dt_en, reg_clear_resv_pkt_cnt_lp_pf,
   reg_clear_resv_pkt_cnt_lp_ph, reg_clear_resv_pkt_cnt_sp_le,
   reg_clear_resv_pkt_cnt_sp_ls, reg_clear_resv_pkt_cnt_sp_fe,
   reg_clear_resv_pkt_cnt_sp_fs
   );

    input                                               clk;
    input                                               rst_n;
    input                                               header_en;
    input  [5:0]                                        data_type;
    input  [5:0]                                        reg_resv_pkt_match_lp_dt;
    input                                               reg_resv_pkt_match_lp_dt_en;
    input                                               reg_clear_resv_pkt_cnt_lp_pf;
    input                                               reg_clear_resv_pkt_cnt_lp_ph;
    input                                               reg_clear_resv_pkt_cnt_sp_le;
    input                                               reg_clear_resv_pkt_cnt_sp_ls;
    input                                               reg_clear_resv_pkt_cnt_sp_fe;
    input                                               reg_clear_resv_pkt_cnt_sp_fs;

    output [31:0]                                       reg_rd_resv_pkt_cnt_lp_pf;
    output [31:0]                                       reg_rd_resv_pkt_cnt_lp_ph;
    output [31:0]                                       reg_rd_resv_pkt_cnt_sp_le;
    output [31:0]                                       reg_rd_resv_pkt_cnt_sp_ls;
    output [31:0]                                       reg_rd_resv_pkt_cnt_sp_fe;
    output [31:0]                                       reg_rd_resv_pkt_cnt_sp_fs;

    genvar                                              j;
    reg                                                 header_en_d1;
    reg  [5:0]                                          data_type_d1;
    wire                                                header_up;
    wire                                                header_dn;
    reg                                                 header_up_d1;
    wire                                                wr_header;
    wire                                                wr_footer;
    wire                                                wr_data;
    wire                                                wr_short;
    wire                                                sp_fs;
    wire                                                sp_fe;
    wire                                                sp_ls;
    wire                                                sp_le;
    wire                                                lp_dt;
    wire                                                lp_ph;
    wire                                                lp_pf;
    wire [5:0]                                          pkt_pulse;
    wire [31:0]                                         pulse_cnt_block[5:0];
    wire [5:0]                                          pulse_cnt_clear;
    
    always @(posedge clk or negedge rst_n)begin
        if(~rst_n)begin
            header_en_d1               <=  1'd0                                        ;
            data_type_d1               <=  6'd0                                        ;
        end
        else begin
            header_en_d1               <=  header_en                                   ;
            data_type_d1               <=  data_type                                   ;
        end
    end
    
    assign header_up = header_en & (~header_en_d1);
    assign header_dn = ~header_en & header_en_d1;
    
    always @(posedge clk or negedge rst_n)begin
        if(~rst_n)
            header_up_d1 <= 1'd0;
        else
            header_up_d1 <= header_up;
    end
    
    assign    sp_fs = data_type_d1 == `CSI_FRAME_START;
    assign    sp_fe = data_type_d1 == `CSI_FRAME_END;
    assign    sp_ls = data_type_d1 == `CSI_LINE_START;
    assign    sp_le = data_type_d1 == `CSI_LINE_END;
    assign    lp_dt = reg_resv_pkt_match_lp_dt_en ? (data_type_d1 == reg_resv_pkt_match_lp_dt) : 1'd1 ;
    
    assign    wr_header    = (~header_up)&(~header_dn)&(header_up_d1);
    assign    wr_footer    = (~header_up)&(header_dn)&(~header_up_d1);
    assign    wr_short     = (~header_up)&(header_dn)&(header_up_d1);
    
    assign    pkt_pulse[5]     = wr_footer&lp_dt;
    assign    pkt_pulse[4]     = wr_header&lp_dt;
    assign    pkt_pulse[3]     = wr_short&sp_le;
    assign    pkt_pulse[2]     = wr_short&sp_ls;
    assign    pkt_pulse[1]     = wr_short&sp_fe;
    assign    pkt_pulse[0]     = wr_short&sp_fs;
    
    assign pulse_cnt_clear = {reg_clear_resv_pkt_cnt_lp_pf,
                              reg_clear_resv_pkt_cnt_lp_ph,
                              reg_clear_resv_pkt_cnt_sp_le,
                              reg_clear_resv_pkt_cnt_sp_ls,
                              reg_clear_resv_pkt_cnt_sp_fe,
                              reg_clear_resv_pkt_cnt_sp_fs};
    
    generate for (j=0;j<=5;j=j+1) begin:pulse_cnt_pkt_bk
        pulse_cnt pulse_cnt_pkt(
            .cnt    (pulse_cnt_block[j]),
            .clk    (clk),
            .rst_n  (rst_n),
            .clear  (pulse_cnt_clear[j]),
            .pulse  (pkt_pulse[j])
        );
    end
    endgenerate
    
    assign     reg_rd_resv_pkt_cnt_lp_pf = pulse_cnt_block[5];
    assign     reg_rd_resv_pkt_cnt_lp_ph = pulse_cnt_block[4];
    assign     reg_rd_resv_pkt_cnt_sp_le = pulse_cnt_block[3];
    assign     reg_rd_resv_pkt_cnt_sp_ls = pulse_cnt_block[2];
    assign     reg_rd_resv_pkt_cnt_sp_fe = pulse_cnt_block[1];
    assign     reg_rd_resv_pkt_cnt_sp_fs = pulse_cnt_block[0];

endmodule

===FILE_END===app_common/monitor_idi_packet.v===
===FILE_START===pattern_test/app_video_prbs_gen.v===END_HEADER===
module app_video_prbs_gen(/*AUTOARG*/
   // Outputs
   prbs_data_out,
   // Inputs
   clk, rst_n, reg_vprbs_tx_gen_en, reg_vprbs_tx_pat_reset,
   reg_vprbs_tx_mode, reg_vprbs_tx_order, reg_vprbs_tx_err_inject_en,
   reg_vprbs_tx_err_inject_intv_time,
   reg_vprbs_tx_err_inject_intv_num, tx_data_type, tx_byte_en,
   tx_data_en, tx_header_en
   );

/***IO define***/
input           clk                                 ; 
input           rst_n                               ; 
input           reg_vprbs_tx_gen_en                 ;
input           reg_vprbs_tx_pat_reset              ;
input  [2:0]    reg_vprbs_tx_mode                   ;
input           reg_vprbs_tx_order                  ;//order == 1 ==> invert , 0 ===> original order
input           reg_vprbs_tx_err_inject_en          ;
input  [7:0]    reg_vprbs_tx_err_inject_intv_time   ;
input  [7:0]    reg_vprbs_tx_err_inject_intv_num    ;
input  [5:0]    tx_data_type                        ;
input  [2:0]    tx_byte_en                          ;
input           tx_data_en                          ;
input           tx_header_en                        ;

output [63:0]   prbs_data_out                       ;

/***signal define***/
wire    [63:0]  prbs_data_out           ;
wire    [63:0]  prbs_err_ijct_post      ;
wire    [63:0]  prbs_q_inv              ;//reverse and inverted      
wire    [63:0]  prbs_inv_post           ;
reg     [63:0]  prbs_d                  ; 
reg     [63:0]  prbs_q                  ;
reg     [63:0]  prbs_d_post             ;
reg     [63:0]  dbg_prbs_q              ;
wire    [63:0]  prbs_d_7_64b            ;
wire    [63:0]  prbs_d_9_64b            ;
wire    [63:0]  prbs_d_11_64b           ;
wire    [63:0]  prbs_d_15_64b           ;
wire    [63:0]  prbs_d_23_64b           ;
wire    [63:0]  prbs_d_31_64b           ;
wire    [63:0]  dbg_prbs_d_7_64b        ;
wire    [63:0]  dbg_prbs_d_9_64b        ;
wire    [63:0]  dbg_prbs_d_11_64b       ;
wire    [63:0]  dbg_prbs_d_15_64b       ;
wire    [63:0]  dbg_prbs_d_23_64b       ;
wire    [63:0]  dbg_prbs_d_31_64b       ;
reg             tx_header_en_d1         ;
wire            header_en_rise          ;

/***logic design***/
prbs_7#(64,128)  u_rx_prbs_7_64b_gen( .prbs_q(prbs_q), .prbs_d(prbs_d_7_64b));
prbs_9#(64,128)  u_rx_prbs_9_64b_gen( .prbs_q(prbs_q), .prbs_d(prbs_d_9_64b));
prbs_11#(64,128) u_rx_prbs_11_64b_gen( .prbs_q(prbs_q), .prbs_d(prbs_d_11_64b));
prbs_15#(64,128) u_rx_prbs_15_64b_gen( .prbs_q(prbs_q), .prbs_d(prbs_d_15_64b));
prbs_23#(64,128) u_rx_prbs_23_64b_gen( .prbs_q(prbs_q), .prbs_d(prbs_d_23_64b));
prbs_31#(64,128) u_rx_prbs_31_64b_gen( .prbs_q(prbs_q), .prbs_d(prbs_d_31_64b));

`ifdef VPRBS_DBG
prbs_7#(64,128)  u_rx_prbs_7_64b_dbg( .prbs_q(dbg_prbs_q), .prbs_d(dbg_prbs_d_7_64b));
prbs_9#(64,128)  u_rx_prbs_9_64b_dbg( .prbs_q(dbg_prbs_q), .prbs_d(dbg_prbs_d_9_64b));
prbs_11#(64,128) u_rx_prbs_11_64b_dbg( .prbs_q(dbg_prbs_q), .prbs_d(dbg_prbs_d_11_64b));
prbs_15#(64,128) u_rx_prbs_15_64b_dbg( .prbs_q(dbg_prbs_q), .prbs_d(dbg_prbs_d_15_64b));
prbs_23#(64,128) u_rx_prbs_23_64b_dbg( .prbs_q(dbg_prbs_q), .prbs_d(dbg_prbs_d_23_64b));
prbs_31#(64,128) u_rx_prbs_31_64b_dbg( .prbs_q(dbg_prbs_q), .prbs_d(dbg_prbs_d_31_64b));
`endif

//the logic----
always @ (*)begin
    case(reg_vprbs_tx_mode)
    3'b000:  prbs_d = prbs_d_7_64b   ; //PRBS7  G(X) = X^7 + X^6 +1         64 steps
    3'b001:  prbs_d = prbs_d_9_64b   ; //PRBS9  G(X) = X^9 + X^5 +1         64 steps
    3'b010:  prbs_d = prbs_d_11_64b  ; //PRBS11 G(X) = X^11 + X^9 + 1       64 steps
    3'b011:  prbs_d = prbs_d_15_64b  ; //PRBS15  G(X) = X^15 + X^14 +1      64 steps
    3'b100:  prbs_d = prbs_d_23_64b  ; //PRBS23  G(X) = X^23 + X^18 +1      64 steps
    3'b101:  prbs_d = prbs_d_31_64b  ; //PRBS31 G(X) = X^31 + X^28 + 1      64 steps
    default: prbs_d = prbs_d_7_64b   ; 
    endcase    
end//end of else
      
//`CSI_YUV420_8_BIT_LEGACY  :data_type = 6'h1a
//`CSI_YUV422_8_BIT         :data_type = 6'h1e
always@(*)begin
    if((tx_data_type == 6'h1a) || (tx_data_type == 6'h1e))begin
        case(tx_byte_en)
        3'd0:prbs_d_post = {prbs_d[63:56],56'd0};
        3'd1:prbs_d_post = {prbs_d[63:48],48'd0};
        3'd2:prbs_d_post = {prbs_d[63:40],40'd0};
        3'd3:prbs_d_post = {prbs_d[63:32],32'd0};
        3'd4:prbs_d_post = {prbs_d[63:24],24'd0};
        3'd5:prbs_d_post = {prbs_d[63:16],16'd0};
        3'd6:prbs_d_post = {prbs_d[63: 8], 8'd0};
        3'd7:prbs_d_post = prbs_d[63:0];
        endcase
    end
    else begin
        case(tx_byte_en)
        3'd0:prbs_d_post = {56'd0,prbs_d[63:56]};
        3'd1:prbs_d_post = {48'd0,prbs_d[63:48]};
        3'd2:prbs_d_post = {40'd0,prbs_d[63:40]};
        3'd3:prbs_d_post = {32'd0,prbs_d[63:32]};
        3'd4:prbs_d_post = {24'd0,prbs_d[63:24]};
        3'd5:prbs_d_post = {16'd0,prbs_d[63:16]};
        3'd6:prbs_d_post = { 8'd0,prbs_d[63:8]};
        3'd7:prbs_d_post = prbs_d[63:0];
        endcase
    end
end

reg [63:0]  prbs_d_load;
always@(*)begin
    case(tx_byte_en)
    3'd0:prbs_d_load = {56'd0,prbs_d[63:56]};
    3'd1:prbs_d_load = {48'd0,prbs_d[63:48]};
    3'd2:prbs_d_load = {40'd0,prbs_d[63:40]};
    3'd3:prbs_d_load = {32'd0,prbs_d[63:32]};
    3'd4:prbs_d_load = {24'd0,prbs_d[63:24]};
    3'd5:prbs_d_load = {16'd0,prbs_d[63:16]};
    3'd6:prbs_d_load = { 8'd0,prbs_d[63:8]};
    3'd7:prbs_d_load = prbs_d[63:0];
    endcase
end

//flip_flops 
always @(posedge clk or negedge rst_n)begin
    if(!rst_n)
        prbs_q <=  64'hffff_ffff_ffff_ffff ;
    else if( ~reg_vprbs_tx_gen_en ) 
        prbs_q <=  64'hffff_ffff_ffff_ffff ;
    else if( reg_vprbs_tx_pat_reset ) 
        prbs_q <=  64'hffff_ffff_ffff_ffff ;
    else if(tx_data_en)
        prbs_q <= prbs_d_load;
end

`ifdef VPRBS_DBG
//debug flip_flops 
always @(posedge clk or negedge rst_n)begin
    if(!rst_n)
        dbg_prbs_q <=  64'hffff_ffff_ffff_ffff ;
    else if( ~reg_vprbs_tx_gen_en ) 
        dbg_prbs_q <=  64'hffff_ffff_ffff_ffff ;
    else if( reg_vprbs_tx_pat_reset ) 
        dbg_prbs_q <=  64'hffff_ffff_ffff_ffff ;
    else if(tx_data_en)
        dbg_prbs_q <= prbs_d;
end
`endif

assign prbs_inv_post = reg_vprbs_tx_order ? ~prbs_d_post : prbs_d_post ;
assign prbs_data_out = prbs_err_ijct_post;

always@(posedge clk or negedge rst_n)begin
    if(!rst_n)
        tx_header_en_d1 <= 1'd0;
    else
        tx_header_en_d1 <= tx_header_en;
end

assign  header_en_rise = ~tx_header_en_d1 && tx_header_en;

/*  vprbs_err_inject  AUTO_TEMPLATE (
    .data_in(prbs_inv_post),
    .data_out(prbs_err_ijct_post),
    .data_en(tx_data_en),
	.reg_vprbs_err_inject_\(.*\)(reg_vprbs_tx_err_inject_\1),
	.err_inject_restart	(header_en_rise),
)*/
vprbs_err_inject u_prbs_err_inject(/*AUTOINST*/
				   // Outputs
				   .data_out		(prbs_err_ijct_post), // Templated
				   // Inputs
				   .clk			(clk),
				   .rst_n		(rst_n),
				   .data_in		(prbs_inv_post), // Templated
				   .data_en		(tx_data_en),	 // Templated
				   .err_inject_restart	(header_en_rise), // Templated
				   .reg_vprbs_err_inject_en(reg_vprbs_tx_err_inject_en), // Templated
				   .reg_vprbs_err_inject_intv_time(reg_vprbs_tx_err_inject_intv_time), // Templated
				   .reg_vprbs_err_inject_intv_num(reg_vprbs_tx_err_inject_intv_num)); // Templated

endmodule

===FILE_END===pattern_test/app_video_prbs_gen.v===
===FILE_START===pattern_test/app_video_prbs_chk.v===END_HEADER===
module app_video_prbs_chk #(
    parameter   DATA_W = 64,
    parameter   BYTE_W = $clog2(DATA_W/8)
)(/*AUTOARG*/
   // Outputs
   reg_rd_vprbs_rx_check, reg_rd_vprbs_rx_fail, reg_rd_vprbs_rx_err,
   // Inputs
   clk, rst_n, prbs_data_in, reg_vprbs_rx_chk_en, reg_vprbs_rx_mode,
   reg_vprbs_rx_order, reg_vprbs_rx_load, reg_vprbs_rx_lock_continue,
   reg_vprbs_rx_uncheck_tolerance, reg_vprbs_rx_err_clear,
   reg_vprbs_rx_locked_match_cnt, rx_byte_en, rx_data_en,
   rx_header_en, rx_data_type
   );

/***IO define***/
input                           clk                                 ;
input                           rst_n                               ;
input [DATA_W-1:0]              prbs_data_in                        ;
input                           reg_vprbs_rx_chk_en                 ;
input [2:0]                     reg_vprbs_rx_mode                   ;
input                           reg_vprbs_rx_order                  ;//1= invert, 0= normal (default)
input                           reg_vprbs_rx_load                   ;
input                           reg_vprbs_rx_lock_continue          ;//1: continous locked_match_cnt match will trigger lock; 0: total locked_match_cnt match will trigger lock
input [3:0]                     reg_vprbs_rx_uncheck_tolerance      ;
input                           reg_vprbs_rx_err_clear              ;
input [3:0]                     reg_vprbs_rx_locked_match_cnt       ;
input [BYTE_W-1:0]              rx_byte_en                          ;
input                           rx_data_en                          ;
input                           rx_header_en                        ;
input [5:0]                     rx_data_type                        ;

output                          reg_rd_vprbs_rx_check               ;
output                          reg_rd_vprbs_rx_fail                ;
output[31:0]                    reg_rd_vprbs_rx_err                 ;
/***signal define***/
wire                            vprbs_rx_check_pulse                ;
wire                            vprbs_rx_fail_pulse                 ;
wire  [DATA_W-1:0]              prbs_local_inv_post                 ;
reg   [DATA_W-1:0]              cal_prbs                            ;
reg   [DATA_W-1:0]              lcpb_d                              ;   
reg   [DATA_W-1:0]              lcpb_q                              ;
wire                            comp_res                            ;
wire  [DATA_W-1:0]              inv_prbsin_64                       ; 
wire  [DATA_W-1:0]              inv_prbsin_32                       ; 
wire                            match                               ;
reg                             locked_d                            ;
reg                             locked_q                            ;
reg   [3:0]                     cnt_d                               ;
reg   [3:0]                     cnt_q                               ;
wire  [DATA_W-1:0]              cal_prbs_7                          ;
wire  [DATA_W-1:0]              cal_prbs_11                         ;
wire  [DATA_W-1:0]              cal_prbs_9                          ;
wire  [DATA_W-1:0]              cal_prbs_15                         ;
wire  [DATA_W-1:0]              cal_prbs_23                         ;
wire  [DATA_W-1:0]              cal_prbs_31                         ;
wire  [DATA_W-1:0]              prbs_in_inv_post                    ;
reg   [DATA_W-1:0]              prbs_in_shft_post                   ;
reg   [DATA_W-1:0]              prbs_local_shft_post                ;
reg   [DATA_W-1:0]              prbs_in_shft_post_load              ;
reg   [DATA_W-1:0]              prbs_local_shft_post_load           ;
reg   [31:0]                    reg_rd_vprbs_rx_err                 ;
wire                            reg_vprbs_rx_err_clear              ;
reg                             rx_header_en_d1                     ;
wire                            check_restart                       ;
reg   [3:0]                     rx_uncheck_tolerance_cnt            ;
wire                            force_check                         ;
wire  [DATA_W-1:0]              comp_res_xor                        ;
wire  [$clog2(DATA_W):0]        err_sim_d                           ;
wire  [32:0]                    vprbs_err_d                         ;
wire                            reg_vprbs_rx_unswap                 ;
wire  [DATA_W-1:0]              prbs_in_swap_post                   ;
wire                            data_type_unswap_flag               ;
reg                             reg_rd_vprbs_rx_check               ;
reg                             reg_rd_vprbs_rx_fail                ;
wire                            vprbs_rx_err_restart                ;
/***logic design***/

/***force_check rtl begin***/
always@(posedge clk or negedge rst_n)begin
    if(!rst_n)
        rx_uncheck_tolerance_cnt <= 4'd0;
    else if(check_restart)
        rx_uncheck_tolerance_cnt <= 4'd0;
    else if(reg_vprbs_rx_chk_en & (rx_data_en))
        rx_uncheck_tolerance_cnt <= (rx_uncheck_tolerance_cnt == reg_vprbs_rx_uncheck_tolerance) ? rx_uncheck_tolerance_cnt : rx_uncheck_tolerance_cnt + 1'd1;
end

assign force_check = (rx_uncheck_tolerance_cnt >= reg_vprbs_rx_uncheck_tolerance);
/***force_check rtl end***/

/***check_restart rtl begin***/
always@(posedge clk or negedge rst_n)begin
    if(!rst_n)
        rx_header_en_d1 <= 1'd0;
    else
        rx_header_en_d1 <= rx_header_en;
end

assign  check_restart = ~rx_header_en_d1 && rx_header_en;
/***check_restart rtl end***/

//`CSI_YUV420_8_BIT_LEGACY  :data_type = 6'h1a
//`CSI_YUV422_8_BIT         :data_type = 6'h1e
//
/***match rtl begin***/
generate if(DATA_W==64)begin: prbs_swap_64_bk
    assign prbs_in_swap_post = prbs_data_in  ;
end
else if(DATA_W==128)begin: prbs_swap_128_bk
    assign reg_vprbs_rx_unswap = (rx_byte_en <= 4'd7);
    assign data_type_unswap_flag = ((rx_data_type == 6'h1a) || (rx_data_type == 6'h1e));
    assign prbs_in_swap_post = (reg_vprbs_rx_unswap | data_type_unswap_flag) ? prbs_data_in : {prbs_data_in[63:0],prbs_data_in[127:64]} ;
end
endgenerate

assign prbs_in_inv_post = reg_vprbs_rx_order ? ~prbs_in_swap_post : prbs_in_swap_post ;

generate if(DATA_W==64)begin: prbs_compare_64_bk
    always@(*)begin
        if((rx_data_type == 6'h1a) || (rx_data_type == 6'h1e))begin
            case(rx_byte_en)
            3'd0:prbs_in_shft_post = {prbs_in_inv_post[63:56],56'd0};
            3'd1:prbs_in_shft_post = {prbs_in_inv_post[63:48],48'd0};
            3'd2:prbs_in_shft_post = {prbs_in_inv_post[63:40],40'd0};
            3'd3:prbs_in_shft_post = {prbs_in_inv_post[63:32],32'd0};
            3'd4:prbs_in_shft_post = {prbs_in_inv_post[63:24],24'd0};
            3'd5:prbs_in_shft_post = {prbs_in_inv_post[63:16],16'd0};
            3'd6:prbs_in_shft_post = {prbs_in_inv_post[63: 8], 8'd0};
            3'd7:prbs_in_shft_post = prbs_in_inv_post[63:0];
            endcase
        end
        else begin
            case(rx_byte_en)
            3'd0:prbs_in_shft_post = {56'd0,prbs_in_inv_post[ 7:0]};
            3'd1:prbs_in_shft_post = {48'd0,prbs_in_inv_post[15:0]};
            3'd2:prbs_in_shft_post = {40'd0,prbs_in_inv_post[23:0]};
            3'd3:prbs_in_shft_post = {32'd0,prbs_in_inv_post[31:0]};
            3'd4:prbs_in_shft_post = {24'd0,prbs_in_inv_post[39:0]};
            3'd5:prbs_in_shft_post = {16'd0,prbs_in_inv_post[47:0]};
            3'd6:prbs_in_shft_post = { 8'd0,prbs_in_inv_post[55:0]};
            3'd7:prbs_in_shft_post = prbs_in_inv_post[63:0];
            endcase
        end
    end

    always@(*)begin
        case(rx_byte_en)
        3'd0:prbs_in_shft_post_load = {56'd0,prbs_in_inv_post[63:56]};
        3'd1:prbs_in_shft_post_load = {48'd0,prbs_in_inv_post[63:48]};
        3'd2:prbs_in_shft_post_load = {40'd0,prbs_in_inv_post[63:40]};
        3'd3:prbs_in_shft_post_load = {32'd0,prbs_in_inv_post[63:32]};
        3'd4:prbs_in_shft_post_load = {24'd0,prbs_in_inv_post[63:24]};
        3'd5:prbs_in_shft_post_load = {16'd0,prbs_in_inv_post[63:16]};
        3'd6:prbs_in_shft_post_load = { 8'd0,prbs_in_inv_post[63: 8]};
        3'd7:prbs_in_shft_post_load = prbs_in_inv_post[63:0];
        endcase
    end

    always@(*)begin
        if((rx_data_type == 6'h1a) || (rx_data_type == 6'h1e))begin
            case(rx_byte_en)
            3'd0:prbs_local_shft_post = {prbs_local_inv_post[63:56],56'd0};
            3'd1:prbs_local_shft_post = {prbs_local_inv_post[63:48],48'd0};
            3'd2:prbs_local_shft_post = {prbs_local_inv_post[63:40],40'd0};
            3'd3:prbs_local_shft_post = {prbs_local_inv_post[63:32],32'd0};
            3'd4:prbs_local_shft_post = {prbs_local_inv_post[63:24],24'd0};
            3'd5:prbs_local_shft_post = {prbs_local_inv_post[63:16],16'd0};
            3'd6:prbs_local_shft_post = {prbs_local_inv_post[63: 8], 8'd0};
            3'd7:prbs_local_shft_post = prbs_local_inv_post[63:0];
            endcase
        end
        else begin
            case(rx_byte_en)
            3'd0:prbs_local_shft_post = {56'd0,prbs_local_inv_post[63:56]};
            3'd1:prbs_local_shft_post = {48'd0,prbs_local_inv_post[63:48]};
            3'd2:prbs_local_shft_post = {40'd0,prbs_local_inv_post[63:40]};
            3'd3:prbs_local_shft_post = {32'd0,prbs_local_inv_post[63:32]};
            3'd4:prbs_local_shft_post = {24'd0,prbs_local_inv_post[63:24]};
            3'd5:prbs_local_shft_post = {16'd0,prbs_local_inv_post[63:16]};
            3'd6:prbs_local_shft_post = { 8'd0,prbs_local_inv_post[63: 8]};
            3'd7:prbs_local_shft_post = prbs_local_inv_post[63:0];
            endcase
        end
    end

    always@(*)begin
        case(rx_byte_en)
        3'd0:prbs_local_shft_post_load = {56'd0,prbs_local_inv_post[63:56]};
        3'd1:prbs_local_shft_post_load = {48'd0,prbs_local_inv_post[63:48]};
        3'd2:prbs_local_shft_post_load = {40'd0,prbs_local_inv_post[63:40]};
        3'd3:prbs_local_shft_post_load = {32'd0,prbs_local_inv_post[63:32]};
        3'd4:prbs_local_shft_post_load = {24'd0,prbs_local_inv_post[63:24]};
        3'd5:prbs_local_shft_post_load = {16'd0,prbs_local_inv_post[63:16]};
        3'd6:prbs_local_shft_post_load = { 8'd0,prbs_local_inv_post[63: 8]};
        3'd7:prbs_local_shft_post_load = prbs_local_inv_post[63:0];
        endcase
    end

end
else if(DATA_W==128)begin: prbs_compare_128_bk
    always@(*)begin
        if((rx_data_type == 6'h1a) || (rx_data_type == 6'h1e))begin
            case(rx_byte_en)
            4'd0 :prbs_in_shft_post = {prbs_in_inv_post[127:120],120'd0};
            4'd1 :prbs_in_shft_post = {prbs_in_inv_post[127:112],112'd0};
            4'd2 :prbs_in_shft_post = {prbs_in_inv_post[127:104],104'd0};
            4'd3 :prbs_in_shft_post = {prbs_in_inv_post[127: 96], 96'd0};
            4'd4 :prbs_in_shft_post = {prbs_in_inv_post[127: 88], 88'd0};
            4'd5 :prbs_in_shft_post = {prbs_in_inv_post[127: 80], 80'd0};
            4'd6 :prbs_in_shft_post = {prbs_in_inv_post[127: 72], 72'd0};
            4'd7 :prbs_in_shft_post = {prbs_in_inv_post[127: 64], 64'd0};
            4'd8 :prbs_in_shft_post = {prbs_in_inv_post[127: 56], 56'd0};
            4'd9 :prbs_in_shft_post = {prbs_in_inv_post[127: 48], 48'd0};
            4'd10:prbs_in_shft_post = {prbs_in_inv_post[127: 40], 40'd0};
            4'd11:prbs_in_shft_post = {prbs_in_inv_post[127: 32], 32'd0};
            4'd12:prbs_in_shft_post = {prbs_in_inv_post[127: 24], 24'd0};
            4'd13:prbs_in_shft_post = {prbs_in_inv_post[127: 16], 16'd0};
            4'd14:prbs_in_shft_post = {prbs_in_inv_post[127:  8],  8'd0};
            4'd15:prbs_in_shft_post = prbs_in_inv_post[127:0];
            endcase
        end
        else begin
            case(rx_byte_en)
            4'd0 :prbs_in_shft_post = {120'd0,prbs_in_inv_post[  7:0]};
            4'd1 :prbs_in_shft_post = {112'd0,prbs_in_inv_post[ 15:0]};
            4'd2 :prbs_in_shft_post = {104'd0,prbs_in_inv_post[ 23:0]};
            4'd3 :prbs_in_shft_post = { 96'd0,prbs_in_inv_post[ 31:0]};
            4'd4 :prbs_in_shft_post = { 88'd0,prbs_in_inv_post[ 39:0]};
            4'd5 :prbs_in_shft_post = { 80'd0,prbs_in_inv_post[ 47:0]};
            4'd6 :prbs_in_shft_post = { 72'd0,prbs_in_inv_post[ 55:0]};
            4'd7 :prbs_in_shft_post = { 64'd0,prbs_in_inv_post[ 63:0]};
            4'd8 :prbs_in_shft_post = { 56'd0,prbs_in_inv_post[ 71:0]};
            4'd9 :prbs_in_shft_post = { 48'd0,prbs_in_inv_post[ 79:0]};
            4'd10:prbs_in_shft_post = { 40'd0,prbs_in_inv_post[ 87:0]};
            4'd11:prbs_in_shft_post = { 32'd0,prbs_in_inv_post[ 95:0]};
            4'd12:prbs_in_shft_post = { 24'd0,prbs_in_inv_post[103:0]};
            4'd13:prbs_in_shft_post = { 16'd0,prbs_in_inv_post[111:0]};
            4'd14:prbs_in_shft_post = {  8'd0,prbs_in_inv_post[119:0]};
            4'd15:prbs_in_shft_post = prbs_in_inv_post[127:0];
            endcase
        end
    end

    always@(*)begin
        case(rx_byte_en)
        4'd0 :prbs_in_shft_post_load = {120'd0,prbs_in_inv_post[127:120]};
        4'd1 :prbs_in_shft_post_load = {112'd0,prbs_in_inv_post[127:112]};
        4'd2 :prbs_in_shft_post_load = {104'd0,prbs_in_inv_post[127:104]};
        4'd3 :prbs_in_shft_post_load = { 96'd0,prbs_in_inv_post[127: 96]};
        4'd4 :prbs_in_shft_post_load = { 88'd0,prbs_in_inv_post[127: 88]};
        4'd5 :prbs_in_shft_post_load = { 80'd0,prbs_in_inv_post[127: 80]};
        4'd6 :prbs_in_shft_post_load = { 72'd0,prbs_in_inv_post[127: 72]};
        4'd7 :prbs_in_shft_post_load = { 64'd0,prbs_in_inv_post[127: 64]};
        4'd8 :prbs_in_shft_post_load = { 56'd0,prbs_in_inv_post[127: 56]};
        4'd9 :prbs_in_shft_post_load = { 48'd0,prbs_in_inv_post[127: 48]};
        4'd10:prbs_in_shft_post_load = { 40'd0,prbs_in_inv_post[127: 40]};
        4'd11:prbs_in_shft_post_load = { 32'd0,prbs_in_inv_post[127: 32]};
        4'd12:prbs_in_shft_post_load = { 24'd0,prbs_in_inv_post[127: 24]};
        4'd13:prbs_in_shft_post_load = { 16'd0,prbs_in_inv_post[127: 16]};
        4'd14:prbs_in_shft_post_load = {  8'd0,prbs_in_inv_post[127:  8]};
        4'd15:prbs_in_shft_post_load = prbs_in_inv_post[127:0];
        endcase
    end

    always@(*)begin
        if((rx_data_type == 6'h1a) || (rx_data_type == 6'h1e))begin
            case(rx_byte_en)
            4'd0 :prbs_local_shft_post = {prbs_local_inv_post[127:120],120'd0};
            4'd1 :prbs_local_shft_post = {prbs_local_inv_post[127:112],112'd0};
            4'd2 :prbs_local_shft_post = {prbs_local_inv_post[127:104],104'd0};
            4'd3 :prbs_local_shft_post = {prbs_local_inv_post[127: 96], 96'd0};
            4'd4 :prbs_local_shft_post = {prbs_local_inv_post[127: 88], 88'd0};
            4'd5 :prbs_local_shft_post = {prbs_local_inv_post[127: 80], 80'd0};
            4'd6 :prbs_local_shft_post = {prbs_local_inv_post[127: 72], 72'd0};
            4'd7 :prbs_local_shft_post = {prbs_local_inv_post[127: 64], 64'd0};
            4'd8 :prbs_local_shft_post = {prbs_local_inv_post[127: 56], 56'd0};
            4'd9 :prbs_local_shft_post = {prbs_local_inv_post[127: 48], 48'd0};
            4'd10:prbs_local_shft_post = {prbs_local_inv_post[127: 40], 40'd0};
            4'd11:prbs_local_shft_post = {prbs_local_inv_post[127: 32], 32'd0};
            4'd12:prbs_local_shft_post = {prbs_local_inv_post[127: 24], 24'd0};
            4'd13:prbs_local_shft_post = {prbs_local_inv_post[127: 16], 16'd0};
            4'd14:prbs_local_shft_post = {prbs_local_inv_post[127:  8],  8'd0};
            4'd15:prbs_local_shft_post = prbs_local_inv_post[127:0];
            endcase
        end
        else begin
            case(rx_byte_en)
            4'd0 :prbs_local_shft_post = {120'd0,prbs_local_inv_post[127:120]};
            4'd1 :prbs_local_shft_post = {112'd0,prbs_local_inv_post[127:112]};
            4'd2 :prbs_local_shft_post = {104'd0,prbs_local_inv_post[127:104]};
            4'd3 :prbs_local_shft_post = { 96'd0,prbs_local_inv_post[127: 96]};
            4'd4 :prbs_local_shft_post = { 88'd0,prbs_local_inv_post[127: 88]};
            4'd5 :prbs_local_shft_post = { 80'd0,prbs_local_inv_post[127: 80]};
            4'd6 :prbs_local_shft_post = { 72'd0,prbs_local_inv_post[127: 72]};
            4'd7 :prbs_local_shft_post = { 64'd0,prbs_local_inv_post[127: 64]};
            4'd8 :prbs_local_shft_post = { 56'd0,prbs_local_inv_post[127: 56]};
            4'd9 :prbs_local_shft_post = { 48'd0,prbs_local_inv_post[127: 48]};
            4'd10:prbs_local_shft_post = { 40'd0,prbs_local_inv_post[127: 40]};
            4'd11:prbs_local_shft_post = { 32'd0,prbs_local_inv_post[127: 32]};
            4'd12:prbs_local_shft_post = { 24'd0,prbs_local_inv_post[127: 24]};
            4'd13:prbs_local_shft_post = { 16'd0,prbs_local_inv_post[127: 16]};
            4'd14:prbs_local_shft_post = {  8'd0,prbs_local_inv_post[127:  8]};
            4'd15:prbs_local_shft_post = prbs_local_inv_post[127:0];
            endcase
        end
    end

    always@(*)begin
        case(rx_byte_en)
            4'd0 :prbs_local_shft_post_load = {120'd0,prbs_local_inv_post[127:120]};
            4'd1 :prbs_local_shft_post_load = {112'd0,prbs_local_inv_post[127:112]};
            4'd2 :prbs_local_shft_post_load = {104'd0,prbs_local_inv_post[127:104]};
            4'd3 :prbs_local_shft_post_load = { 96'd0,prbs_local_inv_post[127: 96]};
            4'd4 :prbs_local_shft_post_load = { 88'd0,prbs_local_inv_post[127: 88]};
            4'd5 :prbs_local_shft_post_load = { 80'd0,prbs_local_inv_post[127: 80]};
            4'd6 :prbs_local_shft_post_load = { 72'd0,prbs_local_inv_post[127: 72]};
            4'd7 :prbs_local_shft_post_load = { 64'd0,prbs_local_inv_post[127: 64]};
            4'd8 :prbs_local_shft_post_load = { 56'd0,prbs_local_inv_post[127: 56]};
            4'd9 :prbs_local_shft_post_load = { 48'd0,prbs_local_inv_post[127: 48]};
            4'd10:prbs_local_shft_post_load = { 40'd0,prbs_local_inv_post[127: 40]};
            4'd11:prbs_local_shft_post_load = { 32'd0,prbs_local_inv_post[127: 32]};
            4'd12:prbs_local_shft_post_load = { 24'd0,prbs_local_inv_post[127: 24]};
            4'd13:prbs_local_shft_post_load = { 16'd0,prbs_local_inv_post[127: 16]};
            4'd14:prbs_local_shft_post_load = {  8'd0,prbs_local_inv_post[127:  8]};
            4'd15:prbs_local_shft_post_load = prbs_local_inv_post[127:0];
        endcase
    end
end
endgenerate

//PRBS data output always equal to the calculated data !!
//assign  prbs_local_inv_post  = reg_vprbs_rx_order? ~cal_prbs : cal_prbs;
assign  prbs_local_inv_post  = cal_prbs;

//compare the PRBS data here 
assign  comp_res = (prbs_local_shft_post == prbs_in_shft_post)  ;//normal order

assign  match = (comp_res & reg_vprbs_rx_chk_en & (rx_data_en));

prbs_7#(DATA_W,DATA_W*2)  u_tx_prbs_7( .prbs_q(lcpb_q), .prbs_d(cal_prbs_7));
prbs_9#(DATA_W,DATA_W*2)  u_tx_prbs_9( .prbs_q(lcpb_q), .prbs_d(cal_prbs_9));
prbs_11#(DATA_W,DATA_W*2) u_tx_prbs_11( .prbs_q(lcpb_q), .prbs_d(cal_prbs_11));
prbs_15#(DATA_W,DATA_W*2) u_tx_prbs_15( .prbs_q(lcpb_q), .prbs_d(cal_prbs_15));
prbs_23#(DATA_W,DATA_W*2) u_tx_prbs_23( .prbs_q(lcpb_q), .prbs_d(cal_prbs_23));
prbs_31#(DATA_W,DATA_W*2) u_tx_prbs_31( .prbs_q(lcpb_q), .prbs_d(cal_prbs_31));

//calculate the predict data
always @(*)begin
   case(reg_vprbs_rx_mode)
   3'b000:cal_prbs = cal_prbs_7  ; //PRBS7  G(X) = X^7 + X^6 +1    64 steps
   3'b001:cal_prbs = cal_prbs_9  ; //PRBS9  G(X) = X^9 + X^5 +1    64 steps
   3'b010:cal_prbs = cal_prbs_11 ; //PRBS11  G(X) = X^11 + X^9 +1    64 steps   
   3'b011:cal_prbs = cal_prbs_15 ; //PRBS15  G(X) = X^15 + X^14 +1    64 steps
   3'b100:cal_prbs = cal_prbs_23 ; //PRBS23  G(X) = X^23 + X^18 +1    64 steps
   3'b101:cal_prbs = cal_prbs_31 ; //PRBS31 G(X) = X^31 + X^28 + 1  20 steps
   default :cal_prbs = cal_prbs_7  ; //PRBS7  G(X) = X^7 + X^6 +1    64 steps
   endcase
end   
/***match rtl end***/

/***lcpb_d rtl begin***/
always @(*)begin
    //to load the input [63:0]
    if(reg_vprbs_rx_load) begin //always load from the input data
        lcpb_d = prbs_in_shft_post_load ;//normal order
    end else begin //do not load from the input data after locked
        if(!locked_q) begin //not locked yet, load from the input data
            lcpb_d = prbs_in_shft_post_load ;//normal order
        end else  //already locked, load from internal data
            lcpb_d = prbs_local_shft_post_load;//prbs shft right until reaching byte_en num, the last 7 bits are taken for polynomial calculation(prbs7)
    end
end
/***lcpb_d rtl end***/

/***locked rtl begin***/
always @(*)begin
    //the locked counter
    if(!reg_vprbs_rx_chk_en) begin
        cnt_d   = 4'b0000;
        locked_d= 1'b0  ;
    end else if(~locked_q) begin
        if(match) begin
            if(cnt_q == reg_vprbs_rx_locked_match_cnt) begin
                cnt_d   = reg_vprbs_rx_locked_match_cnt;
                locked_d= 1'b1  ;
            end else begin
                cnt_d   = cnt_q + 1'b1;
                locked_d= 1'b0 ;
            end
        end else begin
            if(reg_vprbs_rx_lock_continue) begin  //go to relock from 0
                cnt_d   = 4'b0000;
                locked_d= 1'b0  ;
            end else begin
                cnt_d   = cnt_q ;
                locked_d= locked_q ;
            end
        end
    end else begin
        cnt_d   = cnt_q ;
        locked_d= locked_q ;
    end
end   

//flip-flops
always @(posedge clk or negedge rst_n)
    if(!rst_n) begin
        lcpb_q      <= {DATA_W{1'd1}} ;
        cnt_q       <= 4'h0 ;
        locked_q    <= 1'b0 ;
    end
    else if(check_restart) begin
        lcpb_q      <= {DATA_W{1'd1}} ;
        cnt_q       <= 4'h0 ;
        locked_q    <= 1'b0 ;
    end
    else if(~reg_vprbs_rx_chk_en) begin
        lcpb_q      <= {DATA_W{1'd1}} ;
        cnt_q       <= 4'h0 ;
        locked_q    <= 1'b0 ;
    end
    else if(rx_data_en)begin
        lcpb_q      <= lcpb_d ;
        cnt_q       <= cnt_d ;
        locked_q    <= locked_d ;
    end
/***locked rtl end***/

assign  vprbs_rx_check_pulse = reg_vprbs_rx_chk_en & rx_data_en;

assign  vprbs_rx_fail_pulse  = reg_vprbs_rx_chk_en & (locked_d|force_check) & rx_data_en & ~match; 

assign  comp_res_xor = (prbs_local_shft_post ^ prbs_in_shft_post)  ;//normal order

generate if(DATA_W==64)
    begin: err_sim_d_64_bk
        assign err_sim_d =  {5'd0,comp_res_xor[0]}  + {5'd0,comp_res_xor[1]} +
                            {5'd0,comp_res_xor[2]}  + {5'd0,comp_res_xor[3]} +
                            {5'd0,comp_res_xor[4]}  + {5'd0,comp_res_xor[5]} +
                            {5'd0,comp_res_xor[6]}  + {5'd0,comp_res_xor[7]} +
                            {5'd0,comp_res_xor[8]}  + {5'd0,comp_res_xor[9]} +
                            {5'd0,comp_res_xor[10]} + {5'd0,comp_res_xor[11]} +
                            {5'd0,comp_res_xor[12]} + {5'd0,comp_res_xor[13]} +
                            {5'd0,comp_res_xor[14]} + {5'd0,comp_res_xor[15]} +
                            {5'd0,comp_res_xor[16]} + {5'd0,comp_res_xor[17]} +
                            {5'd0,comp_res_xor[18]} + {5'd0,comp_res_xor[19]} +
                            {5'd0,comp_res_xor[20]} + {5'd0,comp_res_xor[21]} +
                            {5'd0,comp_res_xor[22]} + {5'd0,comp_res_xor[23]} +
                            {5'd0,comp_res_xor[24]} + {5'd0,comp_res_xor[25]} +
                            {5'd0,comp_res_xor[26]} + {5'd0,comp_res_xor[27]} +
                            {5'd0,comp_res_xor[28]} + {5'd0,comp_res_xor[29]} +
                            {5'd0,comp_res_xor[30]} + {5'd0,comp_res_xor[31]} +
                            {5'd0,comp_res_xor[32]} + {5'd0,comp_res_xor[33]} +
                            {5'd0,comp_res_xor[34]} + {5'd0,comp_res_xor[35]} +
                            {5'd0,comp_res_xor[36]} + {5'd0,comp_res_xor[37]} +
                            {5'd0,comp_res_xor[38]} + {5'd0,comp_res_xor[39]} +
                            {5'd0,comp_res_xor[40]} + {5'd0,comp_res_xor[41]} +
                            {5'd0,comp_res_xor[42]} + {5'd0,comp_res_xor[43]} +
                            {5'd0,comp_res_xor[44]} + {5'd0,comp_res_xor[45]} +
                            {5'd0,comp_res_xor[46]} + {5'd0,comp_res_xor[47]} +
                            {5'd0,comp_res_xor[48]} + {5'd0,comp_res_xor[49]} +
                            {5'd0,comp_res_xor[50]} + {5'd0,comp_res_xor[51]} +
                            {5'd0,comp_res_xor[52]} + {5'd0,comp_res_xor[53]} +
                            {5'd0,comp_res_xor[54]} + {5'd0,comp_res_xor[55]} +
                            {5'd0,comp_res_xor[56]} + {5'd0,comp_res_xor[57]} +
                            {5'd0,comp_res_xor[58]} + {5'd0,comp_res_xor[59]} +
                            {5'd0,comp_res_xor[60]} + {5'd0,comp_res_xor[61]} +
                            {5'd0,comp_res_xor[62]} + {5'd0,comp_res_xor[63]};
    end
else if(DATA_W==128)
    begin: err_sim_d_128_bk
        assign err_sim_d =  {6'd0,comp_res_xor[0]}   + {6'd0,comp_res_xor[1]} +
                            {6'd0,comp_res_xor[2]}   + {6'd0,comp_res_xor[3]} +
                            {6'd0,comp_res_xor[4]}   + {6'd0,comp_res_xor[5]} +
                            {6'd0,comp_res_xor[6]}   + {6'd0,comp_res_xor[7]} +
                            {6'd0,comp_res_xor[8]}   + {6'd0,comp_res_xor[9]} +
                            {6'd0,comp_res_xor[10]}  + {6'd0,comp_res_xor[11]} +
                            {6'd0,comp_res_xor[12]}  + {6'd0,comp_res_xor[13]} +
                            {6'd0,comp_res_xor[14]}  + {6'd0,comp_res_xor[15]} +
                            {6'd0,comp_res_xor[16]}  + {6'd0,comp_res_xor[17]} +
                            {6'd0,comp_res_xor[18]}  + {6'd0,comp_res_xor[19]} +
                            {6'd0,comp_res_xor[20]}  + {6'd0,comp_res_xor[21]} +
                            {6'd0,comp_res_xor[22]}  + {6'd0,comp_res_xor[23]} +
                            {6'd0,comp_res_xor[24]}  + {6'd0,comp_res_xor[25]} +
                            {6'd0,comp_res_xor[26]}  + {6'd0,comp_res_xor[27]} +
                            {6'd0,comp_res_xor[28]}  + {6'd0,comp_res_xor[29]} +
                            {6'd0,comp_res_xor[30]}  + {6'd0,comp_res_xor[31]} +
                            {6'd0,comp_res_xor[32]}  + {6'd0,comp_res_xor[33]} +
                            {6'd0,comp_res_xor[34]}  + {6'd0,comp_res_xor[35]} +
                            {6'd0,comp_res_xor[36]}  + {6'd0,comp_res_xor[37]} +
                            {6'd0,comp_res_xor[38]}  + {6'd0,comp_res_xor[39]} +
                            {6'd0,comp_res_xor[40]}  + {6'd0,comp_res_xor[41]} +
                            {6'd0,comp_res_xor[42]}  + {6'd0,comp_res_xor[43]} +
                            {6'd0,comp_res_xor[44]}  + {6'd0,comp_res_xor[45]} +
                            {6'd0,comp_res_xor[46]}  + {6'd0,comp_res_xor[47]} +
                            {6'd0,comp_res_xor[48]}  + {6'd0,comp_res_xor[49]} +
                            {6'd0,comp_res_xor[50]}  + {6'd0,comp_res_xor[51]} +
                            {6'd0,comp_res_xor[52]}  + {6'd0,comp_res_xor[53]} +
                            {6'd0,comp_res_xor[54]}  + {6'd0,comp_res_xor[55]} +
                            {6'd0,comp_res_xor[56]}  + {6'd0,comp_res_xor[57]} +
                            {6'd0,comp_res_xor[58]}  + {6'd0,comp_res_xor[59]} +
                            {6'd0,comp_res_xor[60]}  + {6'd0,comp_res_xor[61]} +
                            {6'd0,comp_res_xor[62]}  + {6'd0,comp_res_xor[63]} +
                            {6'd0,comp_res_xor[64]}  + {6'd0,comp_res_xor[65]} +
                            {6'd0,comp_res_xor[66]}  + {6'd0,comp_res_xor[67]} +
                            {6'd0,comp_res_xor[68]}  + {6'd0,comp_res_xor[69]} +
                            {6'd0,comp_res_xor[70]}  + {6'd0,comp_res_xor[71]} +
                            {6'd0,comp_res_xor[72]}  + {6'd0,comp_res_xor[73]} +
                            {6'd0,comp_res_xor[74]}  + {6'd0,comp_res_xor[75]} +
                            {6'd0,comp_res_xor[76]}  + {6'd0,comp_res_xor[77]} +
                            {6'd0,comp_res_xor[78]}  + {6'd0,comp_res_xor[79]} +
                            {6'd0,comp_res_xor[80]}  + {6'd0,comp_res_xor[81]} +
                            {6'd0,comp_res_xor[82]}  + {6'd0,comp_res_xor[83]} +
                            {6'd0,comp_res_xor[84]}  + {6'd0,comp_res_xor[85]} +
                            {6'd0,comp_res_xor[86]}  + {6'd0,comp_res_xor[87]} +
                            {6'd0,comp_res_xor[88]}  + {6'd0,comp_res_xor[89]} +
                            {6'd0,comp_res_xor[90]}  + {6'd0,comp_res_xor[91]} +
                            {6'd0,comp_res_xor[92]}  + {6'd0,comp_res_xor[93]} +
                            {6'd0,comp_res_xor[94]}  + {6'd0,comp_res_xor[95]} +
                            {6'd0,comp_res_xor[96]}  + {6'd0,comp_res_xor[97]} +
                            {6'd0,comp_res_xor[98]}  + {6'd0,comp_res_xor[99]} +
                            {6'd0,comp_res_xor[100]} + {6'd0,comp_res_xor[101]} +
                            {6'd0,comp_res_xor[102]} + {6'd0,comp_res_xor[103]} +
                            {6'd0,comp_res_xor[104]} + {6'd0,comp_res_xor[105]} +
                            {6'd0,comp_res_xor[106]} + {6'd0,comp_res_xor[107]} +
                            {6'd0,comp_res_xor[108]} + {6'd0,comp_res_xor[109]} +
                            {6'd0,comp_res_xor[110]} + {6'd0,comp_res_xor[111]} +
                            {6'd0,comp_res_xor[112]} + {6'd0,comp_res_xor[113]} +
                            {6'd0,comp_res_xor[114]} + {6'd0,comp_res_xor[115]} +
                            {6'd0,comp_res_xor[116]} + {6'd0,comp_res_xor[117]} +
                            {6'd0,comp_res_xor[118]} + {6'd0,comp_res_xor[119]} +
                            {6'd0,comp_res_xor[120]} + {6'd0,comp_res_xor[121]} +
                            {6'd0,comp_res_xor[122]} + {6'd0,comp_res_xor[123]} +
                            {6'd0,comp_res_xor[124]} + {6'd0,comp_res_xor[125]} +
                            {6'd0,comp_res_xor[126]} + {6'd0,comp_res_xor[127]};
    end
endgenerate

always@(posedge clk or negedge rst_n)begin
    if(!rst_n)begin
        reg_rd_vprbs_rx_check <=  1'd0;
    end
    else if(reg_vprbs_rx_err_clear)begin
        reg_rd_vprbs_rx_check <=  1'd0;
    end
    else if(~reg_rd_vprbs_rx_check) begin
        reg_rd_vprbs_rx_check <=  vprbs_rx_check_pulse;
    end
end

assign vprbs_rx_err_restart = ~reg_rd_vprbs_rx_check &  vprbs_rx_check_pulse;

always@(posedge clk or negedge rst_n)begin
    if(!rst_n)begin
        reg_rd_vprbs_rx_fail <=  1'd0;
    end
    else if(reg_vprbs_rx_err_clear)begin
        reg_rd_vprbs_rx_fail <=  1'd0;
    end
    else if(~reg_rd_vprbs_rx_fail) begin
        reg_rd_vprbs_rx_fail <=  vprbs_rx_fail_pulse;
    end
end

assign  vprbs_err_d = reg_rd_vprbs_rx_err + err_sim_d;

always@(posedge clk or negedge rst_n)begin
    if(!rst_n)
        reg_rd_vprbs_rx_err <= 32'd0;
    else if(~reg_vprbs_rx_chk_en)
        reg_rd_vprbs_rx_err <= 32'd0;
    else if(reg_vprbs_rx_err_clear)
        reg_rd_vprbs_rx_err <= 32'd0;
    else if(vprbs_rx_err_restart)
        reg_rd_vprbs_rx_err <= 32'd0;
    else if(vprbs_rx_fail_pulse)
        reg_rd_vprbs_rx_err <= (vprbs_err_d[32]^vprbs_err_d[31]) ? 32'hffff_ffff : vprbs_err_d[31:0];
end

endmodule 

===FILE_END===pattern_test/app_video_prbs_chk.v===
===FILE_START===pattern_test/pattern_test.f===END_HEADER===
-v ${AS6T28_PROJ_DIR}/AS6T28_DIGCOM/AS6T28_COMRTL/pattern_test/app_video_prbs_chk.v
-v ${AS6T28_PROJ_DIR}/AS6T28_DIGCOM/AS6T28_COMRTL/pattern_test/app_video_prbs_gen.v
-v ${AS6T28_PROJ_DIR}/AS6T28_DIGCOM/AS6T28_COMRTL/pattern_test/idi_pattern_driver.v
-v ${AS6T28_PROJ_DIR}/AS6T28_DIGCOM/AS6T28_COMRTL/pattern_test/pattern_test.v
-v ${AS6T28_PROJ_DIR}/AS6T28_DIGCOM/AS6T28_COMRTL/pattern_test/prbs_11.v
-v ${AS6T28_PROJ_DIR}/AS6T28_DIGCOM/AS6T28_COMRTL/pattern_test/prbs_15.v
-v ${AS6T28_PROJ_DIR}/AS6T28_DIGCOM/AS6T28_COMRTL/pattern_test/prbs_16.v
-v ${AS6T28_PROJ_DIR}/AS6T28_DIGCOM/AS6T28_COMRTL/pattern_test/prbs_23.v
-v ${AS6T28_PROJ_DIR}/AS6T28_DIGCOM/AS6T28_COMRTL/pattern_test/prbs_31.v
-v ${AS6T28_PROJ_DIR}/AS6T28_DIGCOM/AS6T28_COMRTL/pattern_test/prbs_32.v
-v ${AS6T28_PROJ_DIR}/AS6T28_DIGCOM/AS6T28_COMRTL/pattern_test/prbs_7.v
-v ${AS6T28_PROJ_DIR}/AS6T28_DIGCOM/AS6T28_COMRTL/pattern_test/prbs_9.v
-v ${AS6T28_PROJ_DIR}/AS6T28_DIGCOM/AS6T28_COMRTL/pattern_test/scrambler_core_64bit.v
-v ${AS6T28_PROJ_DIR}/AS6T28_DIGCOM/AS6T28_COMRTL/pattern_test/sync_bus.v
-v ${AS6T28_PROJ_DIR}/AS6T28_DIGCOM/AS6T28_COMRTL/pattern_test/vprbs_err_inject.v

===FILE_END===pattern_test/pattern_test.f===
===FILE_START===pattern_test/idi_pattern_driver.v===END_HEADER===
module  idi_pattern_driver(/*AUTOARG*/
   // Outputs
   idi_header_en, idi_data_en, idi_byte_en, idi_word_count,
   idi_virtual_channel, idi_data_type,
   // Inputs
   clk, rst_n, reg_idi_driver_enable, reg_idi_driver_total_interval,
   reg_idi_driver_pkt_interval, reg_idi_driver_word_count,
   reg_idi_driver_virtual_channel, reg_idi_driver_data_type
   );

input                   clk                             ;
input                   rst_n                           ;
input                   reg_idi_driver_enable           ;
input       [15:0]      reg_idi_driver_total_interval   ;
input       [15:0]      reg_idi_driver_pkt_interval     ;
input       [15:0]      reg_idi_driver_word_count       ;
input       [ 3:0]      reg_idi_driver_virtual_channel  ;
input       [ 5:0]      reg_idi_driver_data_type        ;

output                  idi_header_en                   ;
output                  idi_data_en                     ;
output      [ 2:0]      idi_byte_en                     ;
output      [15:0]      idi_word_count                  ;
output      [ 3:0]      idi_virtual_channel             ;
output      [ 5:0]      idi_data_type                   ;

reg             idi_header_en                           ;
reg             idi_data_en                             ;
reg  [ 2:0]     idi_byte_en                             ;
reg  [15:0]     idi_word_count                          ;
reg  [ 3:0]     idi_virtual_channel                     ;
reg  [ 5:0]     idi_data_type                           ;

reg             total_transmission_completed            ;
reg             data_transmission_start                 ;
reg  [15:0]     word_count                              ;
reg  [15:0]     word_count_d1                           ;
wire            data_transmission_end                   ;
reg             empty_interval_valid                    ;
reg  [15:0]     empty_interval_cnt                      ;
reg             bitwise_or_empty_interval_cnt_d1        ;
wire            empty_interval_end                      ;
reg             empty_interval_start                    ;
reg  [ 4:0]     pkt_bitmap                              ;
reg  [15:0]     pkt_cnt                                 ;
wire            pkt_transmission_end                    ;
wire            data_transmission_end_lock              ;
wire            pkt_0_vld                               ;
wire            pkt_1_vld                               ;
wire            pkt_2_vld                               ;
wire            pkt_3_vld                               ;
wire            pkt_4_vld                               ;

/***total_transmission_completed rtl begin***/

/*                     __   __   __________   __   __                               _   _   __________   _   _                              */
/*    idi_header_en :_|p0|_|p1|_|    p2    |_|p3|_|p4|_____________________________| |_| |_|          |_| |_| |____________________________ */
/*                                                    ____________________________                             ____________________________ */
/* total_trans_cplt :________________________________|                            |___________________________|                             */
/*                                                                                                                                          */

always@(posedge clk or negedge rst_n)begin
    if(~rst_n)
        total_transmission_completed <= 1'd0;
    else if(~reg_idi_driver_enable)
        total_transmission_completed <= 1'd0;
    else if(pkt_transmission_end)
        total_transmission_completed <= 1'd1;
    else if(empty_interval_end)
        total_transmission_completed <= 1'd0;
end
/***total_transmission_completed rtl begin***/

/***pkt send sequence rtl begin***/
always@(posedge clk or negedge rst_n)begin
    if(~rst_n)
        pkt_bitmap <= 5'b00001 ;
    else if(~reg_idi_driver_enable)
        pkt_bitmap <= 5'b00001 ;
    else if(reg_idi_driver_enable&&((pkt_cnt==16'd1)&&(|(pkt_bitmap[4:0] & 5'b11011))))
        pkt_bitmap <= pkt_bitmap << 1 ;
    else if(reg_idi_driver_enable&&((pkt_cnt==16'd1)&&(pkt_bitmap[2])&&data_transmission_end_lock))
        pkt_bitmap <= pkt_bitmap << 1 ;
    else if(empty_interval_end)
        pkt_bitmap <= 5'b00001 ;
end

always@(posedge clk or negedge rst_n)begin
    if(~rst_n)
        pkt_cnt <= 16'd0;
    else if(~reg_idi_driver_enable)
        pkt_cnt <= 16'd0;
    else if((~total_transmission_completed)&&(~|pkt_cnt)&&((|pkt_bitmap[4:3])|(|pkt_bitmap[1:0]))&&reg_idi_driver_enable)
        pkt_cnt <= reg_idi_driver_pkt_interval;
    else if((~total_transmission_completed)&&((data_transmission_start|(|word_count))&(~data_transmission_end))&&(|pkt_bitmap[2])&&reg_idi_driver_enable)
        pkt_cnt <= reg_idi_driver_pkt_interval;
    else if(|pkt_cnt)
        pkt_cnt <= pkt_cnt-1'd1;
end

assign  pkt_0_vld = ((~total_transmission_completed)&&(pkt_cnt == reg_idi_driver_pkt_interval)&&pkt_bitmap[0]&&reg_idi_driver_enable);
assign  pkt_1_vld = ((~total_transmission_completed)&&(pkt_cnt == reg_idi_driver_pkt_interval)&&pkt_bitmap[1]&&reg_idi_driver_enable);
assign  pkt_2_vld = ((~total_transmission_completed)&&(data_transmission_start|(|word_count)) &&pkt_bitmap[2]&&reg_idi_driver_enable);
assign  pkt_3_vld = ((~total_transmission_completed)&&(pkt_cnt == reg_idi_driver_pkt_interval)&&pkt_bitmap[3]&&reg_idi_driver_enable);
assign  pkt_4_vld = ((~total_transmission_completed)&&(pkt_cnt == reg_idi_driver_pkt_interval)&&pkt_bitmap[4]&&reg_idi_driver_enable);

assign  pkt_transmission_end = ((~total_transmission_completed)&&(pkt_cnt==16'd1)&&(pkt_bitmap[4])&&reg_idi_driver_enable);

/***pkt send sequence rtl end***/

/***pkt_2 transmission rtl begin***/
always@(posedge clk or negedge rst_n)begin
    if(~rst_n)
        data_transmission_start <= 1'd0 ;
    else if(~reg_idi_driver_enable)
        data_transmission_start <= 1'd0 ;
    else if(data_transmission_start)
        data_transmission_start <= ~data_transmission_start ;
    else if((~total_transmission_completed)&&(~|word_count)&&pkt_bitmap[2]&&reg_idi_driver_enable&&(~data_transmission_end_lock))
        data_transmission_start <= 1'd1 ;
end

reg data_transmission_valid     ;
always@(posedge clk or negedge rst_n)begin
    if(~rst_n)
        data_transmission_valid <= 1'd0;
    else if(~reg_idi_driver_enable)
        data_transmission_valid <= 1'd0;
    else if(data_transmission_start)
        data_transmission_valid <= 1'd1;
    else if(((|word_count[2:0])& (~|word_count[15:3]))||((~|word_count[2:0])& (word_count[15:3]==13'd1)))
        data_transmission_valid <= 1'd0;
end

always@(posedge clk or negedge rst_n)begin
    if(~rst_n)
        word_count <= 16'd0;
    else if(~reg_idi_driver_enable)
        word_count <= 16'd0;
    else if(data_transmission_start)
        word_count <= reg_idi_driver_word_count;
    else if(|word_count[15:3])
        word_count[15:3] <= word_count[15:3]-1'd1;
    else if((|word_count[2:0])& (~|word_count[15:3]))
        word_count <= 16'd0;
end

always@(posedge clk or negedge rst_n)begin
    if(~rst_n)
        word_count_d1 <= 16'd0;
    else if(~reg_idi_driver_enable)
        word_count_d1 <= 16'd0;
    else 
        word_count_d1 <= word_count;
end

assign  data_transmission_end = data_transmission_valid && (((|word_count[2:0])& (~|word_count[15:3]))||((~|word_count[2:0])& (word_count[15:3]==13'd1)))  ;

reg data_transmission_end_save;
always@(posedge clk or negedge rst_n)begin
    if(~rst_n)
        data_transmission_end_save <= 1'd0;
    else if(~reg_idi_driver_enable)
        data_transmission_end_save <= 1'd0;
    else if(data_transmission_end)
        data_transmission_end_save <= 1'd1;
    else if(empty_interval_end)
        data_transmission_end_save <= 1'd0;
end

assign  data_transmission_end_lock = data_transmission_end | data_transmission_end_save  ;

/***pkt_2 transmission rtl end***/

/***empty_interval rtl begin***/
always@(posedge clk or negedge rst_n)begin
    if(~rst_n)
        empty_interval_start <= 1'd0;
    else if(~reg_idi_driver_enable)
        empty_interval_start <= 1'd0;
    else if(pkt_transmission_end)
        empty_interval_start <= 1'd1;
    else 
        empty_interval_start <= 1'd0;
end

always@(posedge clk or negedge rst_n)begin
    if(~rst_n)
        empty_interval_valid <= 1'd0 ;
    else if(~reg_idi_driver_enable)
        empty_interval_valid <= 1'd0 ;
    else if(empty_interval_start)
        empty_interval_valid <= 1'd1 ;
    else if((~empty_interval_start)&&(empty_interval_cnt==1'd1))
        empty_interval_valid <= 1'd0 ;
end

always@(posedge clk or negedge rst_n)begin
    if(~rst_n)
        empty_interval_cnt <= 16'd0;
    else if(~reg_idi_driver_enable)
        empty_interval_cnt <= 16'd0;
    else if(empty_interval_start)
        empty_interval_cnt <= reg_idi_driver_total_interval - 16'd3;
    else if(|empty_interval_cnt)
        empty_interval_cnt <= empty_interval_cnt-1'd1;
end

always@(posedge clk or negedge rst_n)begin
    if(~rst_n)
        bitwise_or_empty_interval_cnt_d1 <= 16'd0;
    else if(~reg_idi_driver_enable)
        bitwise_or_empty_interval_cnt_d1 <= 16'd0;
    else if(|empty_interval_cnt)
        bitwise_or_empty_interval_cnt_d1 <= 1'd1;
    else 
        bitwise_or_empty_interval_cnt_d1 <= 1'd0;
end

assign  empty_interval_end =  (bitwise_or_empty_interval_cnt_d1) && (~|empty_interval_cnt)  ;

/***empty_interval rtl end***/

/***idi behavier rtl begin***/
always@(*)begin
    if(pkt_2_vld)begin
        if(|word_count[15:3])
            idi_byte_en = 3'b111;
        else if((|word_count[2:0])& (~|word_count[15:3]))
            idi_byte_en = word_count[2:0] - 1'd1;
        else
            idi_byte_en = 3'd0;
    end
    else begin
        idi_byte_en = 3'd0;
    end
end

always@(*)begin
    if(pkt_0_vld|pkt_1_vld|pkt_2_vld|pkt_3_vld|pkt_4_vld)begin
        idi_header_en = 1'd1;
    end
    else begin
        idi_header_en = 1'd0;
    end
end

always@(*)begin
    if(pkt_2_vld)begin
        if(|word_count)
            idi_data_en = 1'd1;
        else
            idi_data_en = 1'd0;
    end
    else begin
        idi_data_en = 1'd0;
    end
end

always@(*)begin
    if(pkt_2_vld)begin
        idi_word_count = reg_idi_driver_word_count;
    end
    else begin
        idi_word_count = 16'd0;
    end
end

always@(*)begin
    if(pkt_0_vld|pkt_1_vld|pkt_2_vld|pkt_3_vld|pkt_4_vld)begin
        idi_virtual_channel = reg_idi_driver_virtual_channel;
    end
    else begin
        idi_virtual_channel = 16'd0;
    end
end

always@(*)begin
    if(pkt_0_vld)begin
        idi_data_type = 6'd0;
    end
    else if(pkt_1_vld)begin
        idi_data_type = 6'd2;
    end
    else if(pkt_2_vld)begin
        idi_data_type = reg_idi_driver_data_type;
    end
    else if(pkt_3_vld)begin
        idi_data_type = 6'd3;
    end
    else if(pkt_4_vld)begin
        idi_data_type = 6'd1;
    end
    else begin
        idi_data_type = 16'd0;
    end
end
/***idi behavier rtl end***/

endmodule

===FILE_END===pattern_test/idi_pattern_driver.v===
===FILE_START===pattern_test/pattern_test.v===END_HEADER===
module pattern_test(/*AUTOARG*/
   // Outputs
   reg_rd_vprbs_rx_fail, reg_rd_vprbs_rx_err, reg_rd_vprbs_rx_check,
   idi_gen_word_count, idi_gen_virtual_channel, idi_gen_header_en,
   idi_gen_data_en, idi_gen_byte_en, idi_gen_data, idi_gen_data_type,
   // Inputs
   reg_vprbs_tx_pat_reset, reg_vprbs_tx_order, reg_vprbs_tx_mode,
   reg_vprbs_tx_idi_driver_word_count,
   reg_vprbs_tx_idi_driver_virtual_channel,
   reg_vprbs_tx_idi_driver_total_interval,
   reg_vprbs_tx_idi_driver_pkt_interval,
   reg_vprbs_tx_idi_driver_data_type, reg_vprbs_tx_gen_en,
   reg_vprbs_tx_err_inject_intv_time,
   reg_vprbs_tx_err_inject_intv_num, reg_vprbs_tx_err_inject_en,
   reg_vprbs_rx_uncheck_tolerance, reg_vprbs_rx_order,
   reg_vprbs_rx_mode, reg_vprbs_rx_locked_match_cnt,
   reg_vprbs_rx_lock_continue, reg_vprbs_rx_load,
   reg_vprbs_rx_err_clear, reg_vprbs_rx_chk_en, gen_rst_n, gen_clk,
   chk_rst_n, chk_clk, idi_chk_header_en, idi_chk_data_en,
   idi_chk_byte_en, idi_chk_data_type, idi_chk_data,
   reg_vprbs_loopback
   );
/*AUTOINPUT*/
// Beginning of automatic inputs (from unused autoinst inputs)
input			chk_clk;		// To u_app_video_prbs_chk of app_video_prbs_chk.v
input			chk_rst_n;		// To u_app_video_prbs_chk of app_video_prbs_chk.v
input			gen_clk;		// To u_idi_pattern_driver of idi_pattern_driver.v, ...
input			gen_rst_n;		// To u_idi_pattern_driver of idi_pattern_driver.v, ...
input			reg_vprbs_rx_chk_en;	// To u_app_video_prbs_chk of app_video_prbs_chk.v
input			reg_vprbs_rx_err_clear;	// To u_app_video_prbs_chk of app_video_prbs_chk.v
input			reg_vprbs_rx_load;	// To u_app_video_prbs_chk of app_video_prbs_chk.v
input			reg_vprbs_rx_lock_continue;// To u_app_video_prbs_chk of app_video_prbs_chk.v
input [3:0]		reg_vprbs_rx_locked_match_cnt;// To u_app_video_prbs_chk of app_video_prbs_chk.v
input [2:0]		reg_vprbs_rx_mode;	// To u_app_video_prbs_chk of app_video_prbs_chk.v
input			reg_vprbs_rx_order;	// To u_app_video_prbs_chk of app_video_prbs_chk.v
input [3:0]		reg_vprbs_rx_uncheck_tolerance;// To u_app_video_prbs_chk of app_video_prbs_chk.v
input			reg_vprbs_tx_err_inject_en;// To u_app_video_prbs_gen of app_video_prbs_gen.v
input [7:0]		reg_vprbs_tx_err_inject_intv_num;// To u_app_video_prbs_gen of app_video_prbs_gen.v
input [7:0]		reg_vprbs_tx_err_inject_intv_time;// To u_app_video_prbs_gen of app_video_prbs_gen.v
input			reg_vprbs_tx_gen_en;	// To u_idi_pattern_driver of idi_pattern_driver.v, ...
input [5:0]		reg_vprbs_tx_idi_driver_data_type;// To u_idi_pattern_driver of idi_pattern_driver.v
input [15:0]		reg_vprbs_tx_idi_driver_pkt_interval;// To u_idi_pattern_driver of idi_pattern_driver.v
input [15:0]		reg_vprbs_tx_idi_driver_total_interval;// To u_idi_pattern_driver of idi_pattern_driver.v
input [3:0]		reg_vprbs_tx_idi_driver_virtual_channel;// To u_idi_pattern_driver of idi_pattern_driver.v
input [15:0]		reg_vprbs_tx_idi_driver_word_count;// To u_idi_pattern_driver of idi_pattern_driver.v
input [2:0]		reg_vprbs_tx_mode;	// To u_app_video_prbs_gen of app_video_prbs_gen.v
input			reg_vprbs_tx_order;	// To u_app_video_prbs_gen of app_video_prbs_gen.v
input			reg_vprbs_tx_pat_reset;	// To u_app_video_prbs_gen of app_video_prbs_gen.v
// End of automatics
input           idi_chk_header_en       ;
input           idi_chk_data_en         ;
input  [ 2:0]    idi_chk_byte_en        ;
input  [ 5:0]    idi_chk_data_type      ;
input  [63:0]    idi_chk_data           ;
input           reg_vprbs_loopback      ;
/*AUTOOUTPUT*/
// Beginning of automatic outputs (from unused autoinst outputs)
output [3:0]		idi_gen_virtual_channel;// From u_idi_pattern_driver of idi_pattern_driver.v
output [15:0]		idi_gen_word_count;	// From u_idi_pattern_driver of idi_pattern_driver.v
output			reg_rd_vprbs_rx_check;	// From u_app_video_prbs_chk of app_video_prbs_chk.v
output [31:0]		reg_rd_vprbs_rx_err;	// From u_app_video_prbs_chk of app_video_prbs_chk.v
output			reg_rd_vprbs_rx_fail;	// From u_app_video_prbs_chk of app_video_prbs_chk.v
// End of automatics
output			idi_gen_header_en       ;
output          idi_gen_data_en         ;
output [2:0]    idi_gen_byte_en         ;
output [63:0]   idi_gen_data            ;
output [5:0]    idi_gen_data_type       ;
/***signal define ***/
wire [63:0]     idi_vpg_data            ;
wire [63:0]     idi_prbs_data           ;
wire [63:0]     prbs_data_in            ;
wire [ 2:0]     rx_byte_en              ;
wire            rx_data_en              ;
wire            rx_header_en            ;
wire [ 5:0]     rx_data_type            ;
wire [ 2:0]     idi_byte_en             ;
wire            idi_data_en             ;
wire [63:0]     idi_gen_data            ;

assign  prbs_data_in = reg_vprbs_loopback ?  idi_gen_data      : idi_chk_data       ;
assign  rx_byte_en   = reg_vprbs_loopback ?  idi_gen_byte_en   : idi_chk_byte_en    ;
assign  rx_data_en   = reg_vprbs_loopback ?  idi_gen_data_en   : idi_chk_data_en    ;
assign  rx_data_type = reg_vprbs_loopback ?  idi_gen_data_type : idi_chk_data_type  ;
assign  rx_header_en = reg_vprbs_loopback ?  idi_gen_header_en : idi_chk_header_en  ;
                     
/* app_video_prbs_chk   AUTO_TEMPLATE (
    .clk(chk_clk),
    .rst_n(chk_rst_n),
    .prbs_data_in(prbs_data_in),
    .rx_header_en(rx_header_en  ),
    .rx_data_en(rx_data_en  ),
    .rx_data_type(rx_data_type[]  ),
    .rx_byte_en(rx_byte_en[2:0]  ),
)*/
app_video_prbs_chk #(
                    .DATA_W(64)
) u_app_video_prbs_chk(/*AUTOINST*/
		       // Outputs
		       .reg_rd_vprbs_rx_fail(reg_rd_vprbs_rx_fail),
		       .reg_rd_vprbs_rx_check(reg_rd_vprbs_rx_check),
		       .reg_rd_vprbs_rx_err(reg_rd_vprbs_rx_err[31:0]),
		       // Inputs
		       .clk		(chk_clk),		 // Templated
		       .rst_n		(chk_rst_n),		 // Templated
		       .prbs_data_in	(prbs_data_in),		 // Templated
		       .reg_vprbs_rx_chk_en(reg_vprbs_rx_chk_en),
		       .reg_vprbs_rx_mode(reg_vprbs_rx_mode[2:0]),
		       .reg_vprbs_rx_order(reg_vprbs_rx_order),
		       .reg_vprbs_rx_load(reg_vprbs_rx_load),
		       .reg_vprbs_rx_lock_continue(reg_vprbs_rx_lock_continue),
		       .reg_vprbs_rx_uncheck_tolerance(reg_vprbs_rx_uncheck_tolerance[3:0]),
		       .reg_vprbs_rx_err_clear(reg_vprbs_rx_err_clear),
		       .reg_vprbs_rx_locked_match_cnt(reg_vprbs_rx_locked_match_cnt[3:0]),
		       .rx_byte_en	(rx_byte_en[2:0]  ),	 // Templated
		       .rx_data_en	(rx_data_en  ),		 // Templated
		       .rx_header_en	(rx_header_en  ),	 // Templated
		       .rx_data_type	(rx_data_type[5:0]  ));	 // Templated

/*  idi_pattern_driver    AUTO_TEMPLATE (
    .clk(gen_clk),
    .rst_n(gen_rst_n),
    .idi_header_en	(idi_gen_header_en),
    .idi_data_en	(idi_gen_data_en),
    .idi_byte_en	(idi_gen_byte_en[2:0]),
    .idi_word_count	(idi_gen_word_count[15:0]),
    .idi_virtual_channel(idi_gen_virtual_channel[3:0]),
    .idi_data_type	(idi_gen_data_type[5:0]),
	.reg_idi_driver_enable(reg_vprbs_tx_gen_en),
    .reg_idi_driver_\(.*\)(reg_vprbs_tx_idi_driver_\1[]),

)*/
idi_pattern_driver u_idi_pattern_driver(/*AUTOINST*/
					// Outputs
					.idi_header_en	(idi_gen_header_en), // Templated
					.idi_data_en	(idi_gen_data_en), // Templated
					.idi_byte_en	(idi_gen_byte_en[2:0]), // Templated
					.idi_word_count	(idi_gen_word_count[15:0]), // Templated
					.idi_virtual_channel(idi_gen_virtual_channel[3:0]), // Templated
					.idi_data_type	(idi_gen_data_type[5:0]), // Templated
					// Inputs
					.clk		(gen_clk),	 // Templated
					.rst_n		(gen_rst_n),	 // Templated
					.reg_idi_driver_enable(reg_vprbs_tx_gen_en), // Templated
					.reg_idi_driver_total_interval(reg_vprbs_tx_idi_driver_total_interval[15:0]), // Templated
					.reg_idi_driver_pkt_interval(reg_vprbs_tx_idi_driver_pkt_interval[15:0]), // Templated
					.reg_idi_driver_word_count(reg_vprbs_tx_idi_driver_word_count[15:0]), // Templated
					.reg_idi_driver_virtual_channel(reg_vprbs_tx_idi_driver_virtual_channel[3:0]), // Templated
					.reg_idi_driver_data_type(reg_vprbs_tx_idi_driver_data_type[5:0])); // Templated


/*  app_video_prbs_gen  AUTO_TEMPLATE (
    .clk(gen_clk),
    .rst_n(gen_rst_n),
	.tx_header_en(idi_gen_header_en),
    .tx_data_en(idi_gen_data_en),
    .tx_byte_en(idi_gen_byte_en[]),
	.tx_data_type(idi_gen_data_type[]),
    .prbs_data_out(idi_gen_data[]),
)*/
app_video_prbs_gen u_app_video_prbs_gen(
					.prbs_data_out	(idi_gen_data[63:0]),
					.tx_byte_en	(idi_gen_byte_en[2:0]),
					.tx_data_en	(idi_gen_data_en),
					.tx_header_en	(idi_gen_header_en),
					.tx_data_type	(idi_gen_data_type[5:0]),
                    /*AUTOINST*/
					// Inputs
					.clk		(gen_clk),	 // Templated
					.rst_n		(gen_rst_n),	 // Templated
					.reg_vprbs_tx_gen_en(reg_vprbs_tx_gen_en),
					.reg_vprbs_tx_pat_reset(reg_vprbs_tx_pat_reset),
					.reg_vprbs_tx_mode(reg_vprbs_tx_mode[2:0]),
					.reg_vprbs_tx_order(reg_vprbs_tx_order),
					.reg_vprbs_tx_err_inject_en(reg_vprbs_tx_err_inject_en),
					.reg_vprbs_tx_err_inject_intv_time(reg_vprbs_tx_err_inject_intv_time[7:0]),
					.reg_vprbs_tx_err_inject_intv_num(reg_vprbs_tx_err_inject_intv_num[7:0]));




endmodule

===FILE_END===pattern_test/pattern_test.v===
===FILE_START===pattern_test/prbs7_64b.v===END_HEADER===
//PRBS7  G(X) = X^7 + X^6 +1    64 steps
module prbs_7_64b ( prbs_q, prbs_d);

output  [63:0] prbs_d   ;
input   [63:0] prbs_q   ;

wire    [63:0] prbs_d   ;

    assign prbs_d[63] = prbs_q[ 6] ^ prbs_q[ 5] ;
    assign prbs_d[62] = prbs_q[ 5] ^ prbs_q[ 4] ;
    assign prbs_d[61] = prbs_q[ 4] ^ prbs_q[ 3] ;
    assign prbs_d[60] = prbs_q[ 3] ^ prbs_q[ 2] ;
    assign prbs_d[59] = prbs_q[ 2] ^ prbs_q[ 1] ;
    assign prbs_d[58] = prbs_q[ 1] ^ prbs_q[ 0] ;
    assign prbs_d[57] = prbs_q[ 6] ^ prbs_q[ 5] ^ prbs_q[ 0] ;
    assign prbs_d[56] = prbs_q[ 6] ^ prbs_q[ 4] ;
    assign prbs_d[55] = prbs_q[ 5] ^ prbs_q[ 3] ;
    assign prbs_d[54] = prbs_q[ 4] ^ prbs_q[ 2] ;
    assign prbs_d[53] = prbs_q[ 3] ^ prbs_q[ 1] ;
    assign prbs_d[52] = prbs_q[ 2] ^ prbs_q[ 0] ;
    assign prbs_d[51] = prbs_q[ 6] ^ prbs_q[ 5] ^ prbs_q[ 1] ;
    assign prbs_d[50] = prbs_q[ 5] ^ prbs_q[ 4] ^ prbs_q[ 0] ;
    assign prbs_d[49] = prbs_q[ 6] ^ prbs_q[ 5] ^ prbs_q[ 4] ^ prbs_q[ 3] ;
    assign prbs_d[48] = prbs_q[ 5] ^ prbs_q[ 4] ^ prbs_q[ 3] ^ prbs_q[ 2] ;
    assign prbs_d[47] = prbs_q[ 4] ^ prbs_q[ 3] ^ prbs_q[ 2] ^ prbs_q[ 1] ;
    assign prbs_d[46] = prbs_q[ 3] ^ prbs_q[ 2] ^ prbs_q[ 1] ^ prbs_q[ 0] ;
    assign prbs_d[45] = prbs_q[ 6] ^ prbs_q[ 5] ^ prbs_q[ 2] ^ prbs_q[ 1] ^ prbs_q[ 0] ;
    assign prbs_d[44] = prbs_q[ 6] ^ prbs_q[ 4] ^ prbs_q[ 1] ^ prbs_q[ 0] ;
    assign prbs_d[43] = prbs_q[ 6] ^ prbs_q[ 3] ^ prbs_q[ 0] ;
    assign prbs_d[42] = prbs_q[ 6] ^ prbs_q[ 2] ;
    assign prbs_d[41] = prbs_q[ 5] ^ prbs_q[ 1] ;
    assign prbs_d[40] = prbs_q[ 4] ^ prbs_q[ 0] ;
    assign prbs_d[39] = prbs_q[ 6] ^ prbs_q[ 5] ^ prbs_q[ 3] ;
    assign prbs_d[38] = prbs_q[ 5] ^ prbs_q[ 4] ^ prbs_q[ 2] ;
    assign prbs_d[37] = prbs_q[ 4] ^ prbs_q[ 3] ^ prbs_q[ 1] ;
    assign prbs_d[36] = prbs_q[ 3] ^ prbs_q[ 2] ^ prbs_q[ 0] ;
    assign prbs_d[35] = prbs_q[ 6] ^ prbs_q[ 5] ^ prbs_q[ 2] ^ prbs_q[ 1] ;
    assign prbs_d[34] = prbs_q[ 5] ^ prbs_q[ 4] ^ prbs_q[ 1] ^ prbs_q[ 0] ;
    assign prbs_d[33] = prbs_q[ 6] ^ prbs_q[ 5] ^ prbs_q[ 4] ^ prbs_q[ 3] ^ prbs_q[ 0] ;
    assign prbs_d[32] = prbs_q[ 6] ^ prbs_q[ 4] ^ prbs_q[ 3] ^ prbs_q[ 2] ;
    assign prbs_d[31] = prbs_q[ 5] ^ prbs_q[ 3] ^ prbs_q[ 2] ^ prbs_q[ 1] ;
    assign prbs_d[30] = prbs_q[ 4] ^ prbs_q[ 2] ^ prbs_q[ 1] ^ prbs_q[ 0] ;
    assign prbs_d[29] = prbs_q[ 6] ^ prbs_q[ 5] ^ prbs_q[ 3] ^ prbs_q[ 1] ^ prbs_q[ 0] ;
    assign prbs_d[28] = prbs_q[ 6] ^ prbs_q[ 4] ^ prbs_q[ 2] ^ prbs_q[ 0] ;
    assign prbs_d[27] = prbs_q[ 6] ^ prbs_q[ 3] ^ prbs_q[ 1] ;
    assign prbs_d[26] = prbs_q[ 5] ^ prbs_q[ 2] ^ prbs_q[ 0] ;
    assign prbs_d[25] = prbs_q[ 6] ^ prbs_q[ 5] ^ prbs_q[ 4] ^ prbs_q[ 1] ;
    assign prbs_d[24] = prbs_q[ 5] ^ prbs_q[ 4] ^ prbs_q[ 3] ^ prbs_q[ 0] ;
    assign prbs_d[23] = prbs_q[ 6] ^ prbs_q[ 5] ^ prbs_q[ 4] ^ prbs_q[ 3] ^ prbs_q[ 2] ;
    assign prbs_d[22] = prbs_q[ 5] ^ prbs_q[ 4] ^ prbs_q[ 3] ^ prbs_q[ 2] ^ prbs_q[ 1] ;
    assign prbs_d[21] = prbs_q[ 4] ^ prbs_q[ 3] ^ prbs_q[ 2] ^ prbs_q[ 1] ^ prbs_q[ 0] ;
    assign prbs_d[20] = prbs_q[ 6] ^ prbs_q[ 5] ^ prbs_q[ 3] ^ prbs_q[ 2] ^ prbs_q[ 1] ^ prbs_q[ 0] ;
    assign prbs_d[19] = prbs_q[ 6] ^ prbs_q[ 4] ^ prbs_q[ 2] ^ prbs_q[ 1] ^ prbs_q[ 0] ;
    assign prbs_d[18] = prbs_q[ 6] ^ prbs_q[ 3] ^ prbs_q[ 1] ^ prbs_q[ 0] ;
    assign prbs_d[17] = prbs_q[ 6] ^ prbs_q[ 2] ^ prbs_q[ 0] ;
    assign prbs_d[16] = prbs_q[ 6] ^ prbs_q[ 1] ;
    assign prbs_d[15] = prbs_q[ 5] ^ prbs_q[ 0] ;
    assign prbs_d[14] = prbs_q[ 6] ^ prbs_q[ 5] ^ prbs_q[ 4] ;
    assign prbs_d[13] = prbs_q[ 5] ^ prbs_q[ 4] ^ prbs_q[ 3] ;
    assign prbs_d[12] = prbs_q[ 4] ^ prbs_q[ 3] ^ prbs_q[ 2] ;
    assign prbs_d[11] = prbs_q[ 3] ^ prbs_q[ 2] ^ prbs_q[ 1] ;
    assign prbs_d[10] = prbs_q[ 2] ^ prbs_q[ 1] ^ prbs_q[ 0] ;
    assign prbs_d[ 9] = prbs_q[ 6] ^ prbs_q[ 5] ^ prbs_q[ 1] ^ prbs_q[ 0] ;
    assign prbs_d[ 8] = prbs_q[ 6] ^ prbs_q[ 4] ^ prbs_q[ 0] ;
    assign prbs_d[ 7] = prbs_q[ 6] ^ prbs_q[ 3] ;
    assign prbs_d[ 6] = prbs_q[ 5] ^ prbs_q[ 2] ;
    assign prbs_d[ 5] = prbs_q[ 4] ^ prbs_q[ 1] ;
    assign prbs_d[ 4] = prbs_q[ 3] ^ prbs_q[ 0] ;
    assign prbs_d[ 3] = prbs_q[ 6] ^ prbs_q[ 5] ^ prbs_q[ 2] ;
    assign prbs_d[ 2] = prbs_q[ 5] ^ prbs_q[ 4] ^ prbs_q[ 1] ;
    assign prbs_d[ 1] = prbs_q[ 4] ^ prbs_q[ 3] ^ prbs_q[ 0] ;
    assign prbs_d[ 0] = prbs_q[ 6] ^ prbs_q[ 5] ^ prbs_q[ 3] ^ prbs_q[ 2] ;


endmodule

===FILE_END===pattern_test/prbs7_64b.v===
===FILE_START===pattern_test/prbs_11.v===END_HEADER===
module prbs_11 (prbs_d, prbs_q);

parameter DW  = 160;
parameter DW2 = DW * 2;

input  [DW-1:0]  prbs_q;
output [DW-1:0]  prbs_d;

wire   [DW-1:0]  prbs_d;
wire   [DW2-1:0] prbs_p;

assign prbs_p = {prbs_q, prbs_d};

genvar i;
generate
  for (i = 0; i < DW; i = i + 1) begin:prbs_11_bk
    assign prbs_d[i] = prbs_p[i+9] ^ prbs_p[i+11];
  end
endgenerate

endmodule

===FILE_END===pattern_test/prbs_11.v===
===FILE_START===pattern_test/prbs7_8b.v===END_HEADER===
//PRBS7  G(X) = X^7 + X^6 +1    8 steps
module prbs_7_8b ( prbs_q, prbs_d);

output  [7:0] prbs_d    ;
input   [7:0] prbs_q    ;

wire    [7:0] prbs_d    ;

    assign prbs_d[ 7] = prbs_q[ 6] ^ prbs_q[ 5] ;
    assign prbs_d[ 6] = prbs_q[ 5] ^ prbs_q[ 4] ;
    assign prbs_d[ 5] = prbs_q[ 4] ^ prbs_q[ 3] ;
    assign prbs_d[ 4] = prbs_q[ 3] ^ prbs_q[ 2] ;
    assign prbs_d[ 3] = prbs_q[ 2] ^ prbs_q[ 1] ;
    assign prbs_d[ 2] = prbs_q[ 1] ^ prbs_q[ 0] ;
    assign prbs_d[ 1] = prbs_q[ 6] ^ prbs_q[ 5] ^ prbs_q[ 0] ;
    assign prbs_d[ 0] = prbs_q[ 6] ^ prbs_q[ 4] ;

endmodule

===FILE_END===pattern_test/prbs7_8b.v===
===FILE_START===pattern_test/prbs_16.v===END_HEADER===
module prbs_16 (prbs_q, prbs_d);

parameter DW  = 160;
parameter DW2 = DW * 2;

input  [DW-1:0]  prbs_q;
output [DW-1:0]  prbs_d;

wire   [DW-1:0]  prbs_d;
wire   [DW2-1:0] prbs_p;

assign prbs_p = {prbs_q, prbs_d};

genvar i;
generate
  for (i = 0; i < DW; i = i + 1) begin
    assign prbs_d[i] = prbs_p[i+1] ^ prbs_p[i+3] ^ prbs_p[i+12] ^ prbs_p[i+16];
  end
endgenerate

endmodule

===FILE_END===pattern_test/prbs_16.v===
===FILE_START===pattern_test/prbs_15.v===END_HEADER===
module prbs_15 (prbs_q, prbs_d);

parameter DW  = 160;
parameter DW2 = DW * 2;

input  [DW-1:0]  prbs_q;
output [DW-1:0]  prbs_d;

wire   [DW-1:0]  prbs_d;
wire   [DW2-1:0] prbs_p;

assign prbs_p = {prbs_q, prbs_d};

genvar i;
generate
  for (i = 0; i < DW; i = i + 1) begin:prbs_15_bk
    assign prbs_d[i] = prbs_p[i+14] ^ prbs_p[i+15];
  end
endgenerate

endmodule

===FILE_END===pattern_test/prbs_15.v===
===FILE_START===pattern_test/prbs_23.v===END_HEADER===
module prbs_23 (prbs_q, prbs_d);

parameter DW  = 160;
parameter DW2 = DW * 2;

input  [DW-1:0]  prbs_q;
output [DW-1:0]  prbs_d;

wire   [DW-1:0]  prbs_d;
wire   [DW2-1:0] prbs_p;

assign prbs_p = {prbs_q, prbs_d};

genvar i;
generate
  for (i = 0; i < DW; i = i + 1) begin:prbs_23_bk
    assign prbs_d[i] = prbs_p[i+18] ^ prbs_p[i+23];
  end
endgenerate

endmodule

===FILE_END===pattern_test/prbs_23.v===
===FILE_START===pattern_test/prbs_31.v===END_HEADER===
module prbs_31 (prbs_q, prbs_d);

parameter DW  = 160;
parameter DW2 = DW * 2;

input  [DW-1:0]  prbs_q;
output [DW-1:0]  prbs_d;

wire   [DW-1:0]  prbs_d;
wire   [DW2-1:0] prbs_p;

assign prbs_p = {prbs_q, prbs_d};

genvar i;
generate
  for (i = 0; i < DW; i = i + 1) begin:prbs_31_bk
    assign prbs_d[i] = prbs_p[i+28] ^ prbs_p[i+31];
  end
endgenerate

endmodule

===FILE_END===pattern_test/prbs_31.v===
===FILE_START===pattern_test/prbs_32.v===END_HEADER===
module prbs_32 (prbs_q, prbs_d);

parameter DW  = 160;
parameter DW2 = DW * 2;

input  [DW-1:0]  prbs_q;
output [DW-1:0]  prbs_d;

wire   [DW-1:0]  prbs_d;
wire   [DW2-1:0] prbs_p;

assign prbs_p = {prbs_q, prbs_d};

genvar i;
generate
  for (i = 0; i < DW; i = i + 1) begin
    assign prbs_d[i] = prbs_p[i+1] ^ prbs_p[i+2] ^ prbs_p[i+22] ^ prbs_p[i+32];
  end
endgenerate

endmodule

===FILE_END===pattern_test/prbs_32.v===
===FILE_START===pattern_test/prbs_7.v===END_HEADER===
module prbs_7 (prbs_q, prbs_d);

parameter DW  = 160;
parameter DW2 = DW * 2;

input  [DW-1:0]  prbs_q;
output [DW-1:0]  prbs_d;

wire   [DW-1:0]  prbs_d;
wire   [DW2-1:0] prbs_p;

assign prbs_p = {prbs_q, prbs_d};

genvar i;
generate
  for (i = 0; i < DW; i = i + 1) begin:prbs_7_bk
    assign prbs_d[i] = prbs_p[i+6] ^ prbs_p[i+7];
  end
endgenerate

endmodule // prbs_7

===FILE_END===pattern_test/prbs_7.v===
===FILE_START===pattern_test/prbs_9.v===END_HEADER===
module prbs_9 (prbs_q, prbs_d);

parameter DW  = 160;
parameter DW2 = DW * 2;

input  [DW-1:0]  prbs_q;
output [DW-1:0]  prbs_d;

wire   [DW-1:0]  prbs_d;
wire   [DW2-1:0] prbs_p;

assign prbs_p = {prbs_q, prbs_d};

genvar i;
generate
  for (i = 0; i < DW; i = i + 1) begin:prbs_9_bk
    assign prbs_d[i] = prbs_p[i+5] ^ prbs_p[i+9];
  end
endgenerate

endmodule

===FILE_END===pattern_test/prbs_9.v===
===FILE_START===pattern_test/scrambler_core_64bit.v===END_HEADER===
//X33 + X20 + 1
module scrambler_core_64bit(/*AUTOARG*/
   // Outputs
   data_out, lfsr_c,
   // Inputs
   data_in, lfsr_q
   );
    //inputs
    input      [63:0]                             data_in;
    input      [32:0]                             lfsr_q;

    //outputs
    output     [63:0]                             data_out;
    output reg [32:0]                             lfsr_c;

    reg        [63:0]                             data_c;

    //logic body
    assign data_out = data_c;

    always @(*)begin
        data_c[ 0] = data_in[ 0] ^ lfsr_q[32] ^ lfsr_q[19];
        data_c[ 1] = data_in[ 1] ^ lfsr_q[31] ^ lfsr_q[18];
        data_c[ 2] = data_in[ 2] ^ lfsr_q[30] ^ lfsr_q[17];
        data_c[ 3] = data_in[ 3] ^ lfsr_q[29] ^ lfsr_q[16];
        data_c[ 4] = data_in[ 4] ^ lfsr_q[28] ^ lfsr_q[15];
        data_c[ 5] = data_in[ 5] ^ lfsr_q[27] ^ lfsr_q[14];
        data_c[ 6] = data_in[ 6] ^ lfsr_q[26] ^ lfsr_q[13];
        data_c[ 7] = data_in[ 7] ^ lfsr_q[25] ^ lfsr_q[12];
        data_c[ 8] = data_in[ 8] ^ lfsr_q[24] ^ lfsr_q[11];
        data_c[ 9] = data_in[ 9] ^ lfsr_q[23] ^ lfsr_q[10];
        data_c[10] = data_in[10] ^ lfsr_q[22] ^ lfsr_q[ 9];
        data_c[11] = data_in[11] ^ lfsr_q[21] ^ lfsr_q[ 8];
        data_c[12] = data_in[12] ^ lfsr_q[20] ^ lfsr_q[ 7];
        data_c[13] = data_in[13] ^ lfsr_q[19] ^ lfsr_q[ 6];
        data_c[14] = data_in[14] ^ lfsr_q[18] ^ lfsr_q[ 5];
        data_c[15] = data_in[15] ^ lfsr_q[17] ^ lfsr_q[ 4];
        data_c[16] = data_in[16] ^ lfsr_q[16] ^ lfsr_q[ 3];
        data_c[17] = data_in[17] ^ lfsr_q[15] ^ lfsr_q[ 2];
        data_c[18] = data_in[18] ^ lfsr_q[14] ^ lfsr_q[ 1];
        data_c[19] = data_in[19] ^ lfsr_q[13] ^ lfsr_q[ 0];
        data_c[20] = data_in[20] ^ lfsr_q[32] ^ lfsr_q[19] ^ lfsr_q[12];
        data_c[21] = data_in[21] ^ lfsr_q[31] ^ lfsr_q[18] ^ lfsr_q[11];
        data_c[22] = data_in[22] ^ lfsr_q[30] ^ lfsr_q[17] ^ lfsr_q[10];
        data_c[23] = data_in[23] ^ lfsr_q[29] ^ lfsr_q[16] ^ lfsr_q[ 9];
        data_c[24] = data_in[24] ^ lfsr_q[28] ^ lfsr_q[15] ^ lfsr_q[ 8];
        data_c[25] = data_in[25] ^ lfsr_q[27] ^ lfsr_q[14] ^ lfsr_q[ 7];
        data_c[26] = data_in[26] ^ lfsr_q[26] ^ lfsr_q[13] ^ lfsr_q[ 6];
        data_c[27] = data_in[27] ^ lfsr_q[25] ^ lfsr_q[12] ^ lfsr_q[ 5];
        data_c[28] = data_in[28] ^ lfsr_q[24] ^ lfsr_q[11] ^ lfsr_q[ 4];
        data_c[29] = data_in[29] ^ lfsr_q[23] ^ lfsr_q[10] ^ lfsr_q[ 3];
        data_c[30] = data_in[30] ^ lfsr_q[22] ^ lfsr_q[ 9] ^ lfsr_q[ 2];
        data_c[31] = data_in[31] ^ lfsr_q[21] ^ lfsr_q[ 8] ^ lfsr_q[ 1];
        data_c[32] = data_in[32] ^ lfsr_q[20] ^ lfsr_q[ 7] ^ lfsr_q[ 0];
        data_c[33] = data_in[33] ^ lfsr_q[32] ^ lfsr_q[ 6];
        data_c[34] = data_in[34] ^ lfsr_q[31] ^ lfsr_q[ 5];
        data_c[35] = data_in[35] ^ lfsr_q[30] ^ lfsr_q[ 4];
        data_c[36] = data_in[36] ^ lfsr_q[29] ^ lfsr_q[ 3];
        data_c[37] = data_in[37] ^ lfsr_q[28] ^ lfsr_q[ 2];
        data_c[38] = data_in[38] ^ lfsr_q[27] ^ lfsr_q[ 1];
        data_c[39] = data_in[39] ^ lfsr_q[26] ^ lfsr_q[ 0];
        data_c[40] = data_in[40] ^ lfsr_q[32] ^ lfsr_q[25] ^ lfsr_q[19];
        data_c[41] = data_in[41] ^ lfsr_q[31] ^ lfsr_q[24] ^ lfsr_q[18];
        data_c[42] = data_in[42] ^ lfsr_q[30] ^ lfsr_q[23] ^ lfsr_q[17];
        data_c[43] = data_in[43] ^ lfsr_q[29] ^ lfsr_q[22] ^ lfsr_q[16];
        data_c[44] = data_in[44] ^ lfsr_q[28] ^ lfsr_q[21] ^ lfsr_q[15];
        data_c[45] = data_in[45] ^ lfsr_q[27] ^ lfsr_q[20] ^ lfsr_q[14];
        data_c[46] = data_in[46] ^ lfsr_q[26] ^ lfsr_q[19] ^ lfsr_q[13];
        data_c[47] = data_in[47] ^ lfsr_q[25] ^ lfsr_q[18] ^ lfsr_q[12];
        data_c[48] = data_in[48] ^ lfsr_q[24] ^ lfsr_q[17] ^ lfsr_q[11];
        data_c[49] = data_in[49] ^ lfsr_q[23] ^ lfsr_q[16] ^ lfsr_q[10];
        data_c[50] = data_in[50] ^ lfsr_q[22] ^ lfsr_q[15] ^ lfsr_q[ 9];
        data_c[51] = data_in[51] ^ lfsr_q[21] ^ lfsr_q[14] ^ lfsr_q[ 8];
        data_c[52] = data_in[52] ^ lfsr_q[20] ^ lfsr_q[13] ^ lfsr_q[ 7];
        data_c[53] = data_in[53] ^ lfsr_q[19] ^ lfsr_q[12] ^ lfsr_q[ 6];
        data_c[54] = data_in[54] ^ lfsr_q[18] ^ lfsr_q[11] ^ lfsr_q[ 5];
        data_c[55] = data_in[55] ^ lfsr_q[17] ^ lfsr_q[10] ^ lfsr_q[ 4];
        data_c[56] = data_in[56] ^ lfsr_q[16] ^ lfsr_q[ 9] ^ lfsr_q[ 3];
        data_c[57] = data_in[57] ^ lfsr_q[15] ^ lfsr_q[ 8] ^ lfsr_q[ 2];
        data_c[58] = data_in[58] ^ lfsr_q[14] ^ lfsr_q[ 7] ^ lfsr_q[ 1];
        data_c[59] = data_in[59] ^ lfsr_q[13] ^ lfsr_q[ 6] ^ lfsr_q[ 0];
        data_c[60] = data_in[60] ^ lfsr_q[32] ^ lfsr_q[19] ^ lfsr_q[12] ^ lfsr_q[ 5];
        data_c[61] = data_in[61] ^ lfsr_q[31] ^ lfsr_q[18] ^ lfsr_q[11] ^ lfsr_q[ 4];
        data_c[62] = data_in[62] ^ lfsr_q[30] ^ lfsr_q[17] ^ lfsr_q[10] ^ lfsr_q[ 3];
        data_c[63] = data_in[63] ^ lfsr_q[29] ^ lfsr_q[16] ^ lfsr_q[ 9] ^ lfsr_q[ 2];

        lfsr_c[32] = lfsr_q[21] ^ lfsr_q[ 8] ^ lfsr_q[ 1];
        lfsr_c[31] = lfsr_q[20] ^ lfsr_q[ 7] ^ lfsr_q[ 0];
        lfsr_c[30] = lfsr_q[32] ^ lfsr_q[ 6];
        lfsr_c[29] = lfsr_q[31] ^ lfsr_q[ 5];
        lfsr_c[28] = lfsr_q[30] ^ lfsr_q[ 4];
        lfsr_c[27] = lfsr_q[29] ^ lfsr_q[ 3];
        lfsr_c[26] = lfsr_q[28] ^ lfsr_q[ 2];
        lfsr_c[25] = lfsr_q[27] ^ lfsr_q[ 1];
        lfsr_c[24] = lfsr_q[26] ^ lfsr_q[ 0];
        lfsr_c[23] = lfsr_q[32] ^ lfsr_q[25] ^ lfsr_q[19];
        lfsr_c[22] = lfsr_q[31] ^ lfsr_q[24] ^ lfsr_q[18];
        lfsr_c[21] = lfsr_q[30] ^ lfsr_q[23] ^ lfsr_q[17];
        lfsr_c[20] = lfsr_q[29] ^ lfsr_q[22] ^ lfsr_q[16];
        lfsr_c[19] = lfsr_q[28] ^ lfsr_q[21] ^ lfsr_q[15];
        lfsr_c[18] = lfsr_q[27] ^ lfsr_q[20] ^ lfsr_q[14];
        lfsr_c[17] = lfsr_q[26] ^ lfsr_q[19] ^ lfsr_q[13];
        lfsr_c[16] = lfsr_q[25] ^ lfsr_q[18] ^ lfsr_q[12];
        lfsr_c[15] = lfsr_q[24] ^ lfsr_q[17] ^ lfsr_q[11];
        lfsr_c[14] = lfsr_q[23] ^ lfsr_q[16] ^ lfsr_q[10];
        lfsr_c[13] = lfsr_q[22] ^ lfsr_q[15] ^ lfsr_q[ 9];
        lfsr_c[12] = lfsr_q[21] ^ lfsr_q[14] ^ lfsr_q[ 8];
        lfsr_c[11] = lfsr_q[20] ^ lfsr_q[13] ^ lfsr_q[ 7];
        lfsr_c[10] = lfsr_q[19] ^ lfsr_q[12] ^ lfsr_q[ 6];
        lfsr_c[ 9] = lfsr_q[18] ^ lfsr_q[11] ^ lfsr_q[ 5];
        lfsr_c[ 8] = lfsr_q[17] ^ lfsr_q[10] ^ lfsr_q[ 4];
        lfsr_c[ 7] = lfsr_q[16] ^ lfsr_q[ 9] ^ lfsr_q[ 3];
        lfsr_c[ 6] = lfsr_q[15] ^ lfsr_q[ 8] ^ lfsr_q[ 2];
        lfsr_c[ 5] = lfsr_q[14] ^ lfsr_q[ 7] ^ lfsr_q[ 1];
        lfsr_c[ 4] = lfsr_q[13] ^ lfsr_q[ 6] ^ lfsr_q[ 0];
        lfsr_c[ 3] = lfsr_q[32] ^ lfsr_q[19] ^ lfsr_q[12] ^ lfsr_q[ 5];
        lfsr_c[ 2] = lfsr_q[31] ^ lfsr_q[18] ^ lfsr_q[11] ^ lfsr_q[ 4];
        lfsr_c[ 1] = lfsr_q[30] ^ lfsr_q[17] ^ lfsr_q[10] ^ lfsr_q[ 3];
        lfsr_c[ 0] = lfsr_q[29] ^ lfsr_q[16] ^ lfsr_q[ 9] ^ lfsr_q[ 2];
    end

endmodule

===FILE_END===pattern_test/scrambler_core_64bit.v===
===FILE_START===pattern_test/video_pattern_generator_idi.v===END_HEADER===
module video_pattern_generator_idi(/*AUTOARG*/
   // Outputs
   idi_word_count, idi_byte_en, idi_header_en, idi_data_en, idi_data,
   idi_vc, idi_vcx, idi_dt,
   // Inputs
   vpg_vsa_lines_qst, vpg_vfp_lines_qst, vpg_vcx_qst, vpg_vc_qst,
   vpg_vbp_lines_qst, vpg_vactive_lines_qst, vpg_step_line_num_qst,
   vpg_start_line_num_qst, vpg_pkt_size_qst, vpg_packet_lost_ack,
   vpg_orientation_qst, vpg_mode_qst, vpg_max_frame_num_qst,
   vpg_line_num_mode_qst, vpg_hsync_packet_en_qst, vpg_hsa_time_qst,
   vpg_hline_time_qst, vpg_hbp_time_qst, vpg_frame_num_mode_qst,
   vpg_en, vpg_dt_qst, vpg_bk_lines_qst, rst_n, clk,
   reg_app_vc_turn_over_en, reg_app_vc_turn_over_mode
   );

/*AUTOINPUT*/
// Beginning of automatic inputs (from unused autoinst inputs)
input			clk;			// To u_video_pattern_generator of video_pattern_generator.v
input			rst_n;			// To u_video_pattern_generator of video_pattern_generator.v
input [9:0]		vpg_bk_lines_qst;	// To u_video_pattern_generator of video_pattern_generator.v
input [5:0]		vpg_dt_qst;		// To u_video_pattern_generator of video_pattern_generator.v
input			vpg_en;			// To u_video_pattern_generator of video_pattern_generator.v
input			vpg_frame_num_mode_qst;	// To u_video_pattern_generator of video_pattern_generator.v
input [11:0]		vpg_hbp_time_qst;	// To u_video_pattern_generator of video_pattern_generator.v
input [14:0]		vpg_hline_time_qst;	// To u_video_pattern_generator of video_pattern_generator.v
input [11:0]		vpg_hsa_time_qst;	// To u_video_pattern_generator of video_pattern_generator.v
input			vpg_hsync_packet_en_qst;// To u_video_pattern_generator of video_pattern_generator.v
input [1:0]		vpg_line_num_mode_qst;	// To u_video_pattern_generator of video_pattern_generator.v
input [15:0]		vpg_max_frame_num_qst;	// To u_video_pattern_generator of video_pattern_generator.v
input			vpg_mode_qst;		// To u_video_pattern_generator of video_pattern_generator.v
input			vpg_orientation_qst;	// To u_video_pattern_generator of video_pattern_generator.v
input			vpg_packet_lost_ack;	// To u_video_pattern_generator of video_pattern_generator.v
input [13:0]		vpg_pkt_size_qst;	// To u_video_pattern_generator of video_pattern_generator.v
input [15:0]		vpg_start_line_num_qst;	// To u_video_pattern_generator of video_pattern_generator.v
input [15:0]		vpg_step_line_num_qst;	// To u_video_pattern_generator of video_pattern_generator.v
input [13:0]		vpg_vactive_lines_qst;	// To u_video_pattern_generator of video_pattern_generator.v
input [9:0]		vpg_vbp_lines_qst;	// To u_video_pattern_generator of video_pattern_generator.v
input [1:0]		vpg_vc_qst;		// To u_video_pattern_generator of video_pattern_generator.v
input [2:0]		vpg_vcx_qst;		// To u_video_pattern_generator of video_pattern_generator.v
input [9:0]		vpg_vfp_lines_qst;	// To u_video_pattern_generator of video_pattern_generator.v
input [9:0]		vpg_vsa_lines_qst;	// To u_video_pattern_generator of video_pattern_generator.v
// End of automatics
/*AUTOOUTPUT*/
input           reg_app_vc_turn_over_en;
input           reg_app_vc_turn_over_mode;
/*idi output*/
output    [15:0]        idi_word_count;
output    [2 :0]        idi_byte_en;
output                  idi_header_en;
output                  idi_data_en;
output    [63:0]        idi_data;
output    [1 :0]        idi_vc;
output    [1 :0]        idi_vcx;
output    [5 :0]        idi_dt;

//parameter   CSI2_DEVICE_VPG_BK_LINES_RS         = 10,    
//parameter   CSI2_DEVICE_VPG_DT_RS               =  6,
//parameter   CSI2_DEVICE_VPG_FRAME_NUM_MODE_RS   =  1,
//parameter   CSI2_DEVICE_VPG_HBP_TIME_RS         = 12,
//parameter   CSI2_DEVICE_VPG_HLINE_TIME_RS       = 15,
//parameter   CSI2_DEVICE_VPG_HSA_TIME_RS         = 12,
//parameter   CSI2_DEVICE_VPG_LINE_NUM_MODE_RS    =  2,
//parameter   CSI2_DEVICE_VPG_MAX_FRAME_NUM_RS    = 16,
//parameter   CSI2_DEVICE_VPG_PKT_SIZE_RS         = 14,
//parameter   CSI2_DEVICE_VPG_START_LINE_NUM_RS   = 16,
//parameter   CSI2_DEVICE_VPG_STEP_LINE_NUM_RS    = 16,
//parameter   CSI2_DEVICE_VPG_ACT_LINES_RS        = 14,
//parameter   CSI2_DEVICE_VPG_VBP_LINES_RS        = 10,
//parameter   CSI2_DEVICE_VPG_VC_RS               =  2,
//parameter   CSI2_DEVICE_VCX_DWIDTH              =  3,
//parameter   CSI2_DEVICE_VPG_VFP_LINES_RS        = 10,
//parameter   CSI2_DEVICE_VPG_VSA_LINES_RS        = 10,
//parameter   CSI2_DEVICE_HD_WIDTH                = 27,
//parameter   CSI2_DEVICE_NAP_PLD_WIDTH           = 64

reg                                     short_packet_cnt        ;
reg  [15:0]                             word_count              ;
reg  [15:0]                             idi_word_count          ;
reg   [2:0]                             idi_byte_en             ;
reg                                     idi_header_en           ;
reg                                     idi_data_en             ;
reg  [63:0]                             idi_data            ;
wire  [9:0]                             idi_vcdt                ;
wire  [1:0]                             idi_vc                  ;
wire  [1:0]                             idi_vcx                 ;
wire  [5:0]                             idi_dt                  ;
wire                                    vpg_header_gen_en       ;
wire                                    vpg_payload_gen_en      ;
wire                                    vpg_active              ;
wire                                    vpg_packet_lost         ;
wire                                    vpg_packet_req          ;
wire[27-1:0]                            vpg_header              ;
wire[64-1:0]                            vpg_payload             ;
wire                                    vpg_elastbuf_emptyz     ;
reg    [9:0]                            idi_vcdt_lock           ;
reg                                     idi_vcdt_lock_vld       ;
reg [1:0]                               vc_turn_over            ;
wire[1:0]                               vpg_vc                  ;
wire[1:0]                               turn_over_max           ;
wire[63:0]                              idi_prbs_data           ;
wire[63:0]                              idi_data                ;

assign    vpg_payload_gen_en            = 1'd1        ;

/*  video_pattern_generator  AUTO_TEMPLATE (
        .vpg_vc_qst        (vpg_vc_qst[2-1:0]),
        .vpg_vcx_qst        (vpg_vcx_qst[3-1:0]),
        .vpg_dt_qst        (vpg_dt_qst[6-1:0]),
        .vpg_pkt_size_qst    (vpg_pkt_size_qst[14-1:0]),
        .vpg_hsa_time_qst    (vpg_hsa_time_qst[12-1:0]),
        .vpg_hbp_time_qst    (vpg_hbp_time_qst[12-1:0]),
        .vpg_hline_time_qst    (vpg_hline_time_qst[15-1:0]),
        .vpg_vsa_lines_qst    (vpg_vsa_lines_qst[10-1:0]),
        .vpg_vbp_lines_qst    (vpg_vbp_lines_qst[10-1:0]),
        .vpg_vfp_lines_qst    (vpg_vfp_lines_qst[10-1:0]),
        .vpg_vactive_lines_qst(vpg_vactive_lines_qst[14-1:0]),
        .vpg_bk_lines_qst    (vpg_bk_lines_qst[10-1:0]),
        .vpg_frame_num_mode_qst(vpg_frame_num_mode_qst),
        .vpg_max_frame_num_qst(vpg_max_frame_num_qst[16-1:0]),
        .vpg_line_num_mode_qst(vpg_line_num_mode_qst[2-1:0]),
        .vpg_start_line_num_qst(vpg_start_line_num_qst[16-1:0]),
        .vpg_step_line_num_qst(vpg_step_line_num_qst[16-1:0]),
        .ppi_clk                         (clk),
        .ppi_clkrstz                     (rst_n),
        .\(.*\)                             (\1[]),
)*/
video_pattern_generator#(/*AUTOINSTPARAM*/)
u_video_pattern_generator(
                .vpg_active            (vpg_active),
                .vpg_packet_lost        (vpg_packet_lost),
                .vpg_packet_req        (vpg_packet_req),
                .vpg_header            (vpg_header[27-1:0]),
                .vpg_payload            (vpg_payload[64-1:0]),
                .vpg_elastbuf_emptyz    (vpg_elastbuf_emptyz),
                .vpg_header_gen_en    (vpg_header_gen_en),
                .vpg_payload_gen_en    (vpg_payload_gen_en),
                /*AUTOINST*/
			  // Inputs
			  .ppi_clk		(clk),		 // Templated
			  .ppi_clkrstz		(rst_n),	 // Templated
			  .vpg_en		(vpg_en),	 // Templated
			  .vpg_packet_lost_ack	(vpg_packet_lost_ack), // Templated
			  .vpg_orientation_qst	(vpg_orientation_qst), // Templated
			  .vpg_mode_qst		(vpg_mode_qst),	 // Templated
			  .vpg_hsync_packet_en_qst(vpg_hsync_packet_en_qst), // Templated
			  .vpg_vc_qst		(vpg_vc_qst[2-1:0]), // Templated
			  .vpg_vcx_qst		(vpg_vcx_qst[3-1:0]), // Templated
			  .vpg_dt_qst		(vpg_dt_qst[6-1:0]), // Templated
			  .vpg_pkt_size_qst	(vpg_pkt_size_qst[14-1:0]), // Templated
			  .vpg_hsa_time_qst	(vpg_hsa_time_qst[12-1:0]), // Templated
			  .vpg_hbp_time_qst	(vpg_hbp_time_qst[12-1:0]), // Templated
			  .vpg_hline_time_qst	(vpg_hline_time_qst[15-1:0]), // Templated
			  .vpg_vsa_lines_qst	(vpg_vsa_lines_qst[10-1:0]), // Templated
			  .vpg_vbp_lines_qst	(vpg_vbp_lines_qst[10-1:0]), // Templated
			  .vpg_vfp_lines_qst	(vpg_vfp_lines_qst[10-1:0]), // Templated
			  .vpg_vactive_lines_qst(vpg_vactive_lines_qst[14-1:0]), // Templated
			  .vpg_bk_lines_qst	(vpg_bk_lines_qst[10-1:0]), // Templated
			  .vpg_frame_num_mode_qst(vpg_frame_num_mode_qst), // Templated
			  .vpg_max_frame_num_qst(vpg_max_frame_num_qst[16-1:0]), // Templated
			  .vpg_line_num_mode_qst(vpg_line_num_mode_qst[2-1:0]), // Templated
			  .vpg_start_line_num_qst(vpg_start_line_num_qst[16-1:0]), // Templated
			  .vpg_step_line_num_qst(vpg_step_line_num_qst[16-1:0])); // Templated

always@(posedge clk or negedge rst_n)begin
    if(~rst_n)
        short_packet_cnt <= 1'd0;
    else if((vpg_header[5:2]==4'd0)&vpg_packet_req)
        short_packet_cnt <= short_packet_cnt ? 1'd0  : 1'd1;
    else 
        short_packet_cnt <= short_packet_cnt ? 1'd0 : short_packet_cnt;
end

assign    vpg_header_gen_en = ~short_packet_cnt & vpg_packet_req;

always@(posedge clk or negedge rst_n)begin
    if(~rst_n)
        word_count <= 16'd0;
    else if((vpg_header[5:2]!=4'd0)&vpg_packet_req)
        word_count <= vpg_header[23:8];
    else if(|word_count[15:3])
        word_count[15:3] <= word_count[15:3]-1'd1;
    else if((|word_count[2:0])& (~|word_count[15:3]))
        word_count <= 16'd0;
end

always@(*)begin
    if(|word_count[15:3])
        idi_byte_en = 3'b111;
    else if((|word_count[2:0])& (~|word_count[15:3]))
        idi_byte_en = word_count[2:0] - 1'd1;
    else
        idi_byte_en = 3'd0;
end

always@(*)begin
    if(vpg_header_gen_en)
        idi_header_en = 1'd1;
    else if(|word_count)
        idi_header_en = 1'd1;
    else
        idi_header_en = 1'd0;
end

always@(*)begin
    if(|word_count)
        idi_data_en = 1'd1;
    else
        idi_data_en = 1'd0;
end

always@(*)begin
    if(idi_data_en)
        idi_data = vpg_payload;
    else
        idi_data = 64'd0    ;
end

assign    idi_vcdt = vpg_packet_req ? {vpg_header[25:24],vpg_vc,vpg_header[5:0]} :
                idi_vcdt_lock_vld ? idi_vcdt_lock :
                8'd0;

assign {idi_vcx,idi_vc,idi_dt} = idi_vcdt;

assign idi_word_count = vpg_header[23:8];


assign turn_over_max = reg_app_vc_turn_over_mode? 2'b01 : 2'b11 ;

always@(posedge clk or negedge rst_n)begin
    if(~rst_n)begin
        idi_vcdt_lock      <= 10'd0;
        idi_vcdt_lock_vld <= 1'd0;
    end
    else if((vpg_packet_req)&&(vpg_header[5:2] != 4'd0))begin
        idi_vcdt_lock      <= {vpg_header[25:24],vpg_vc,vpg_header[5:0]};
        idi_vcdt_lock_vld <= 1'd1;
    end
    else if(word_count<=8)begin
        idi_vcdt_lock      <= 10'd0;
        idi_vcdt_lock_vld <= 1'd0;
    end
end

always@(posedge clk or negedge rst_n)begin
    if(~rst_n)
        vc_turn_over <= 2'd0;
    else if(idi_header_en&(idi_dt==2'b11))
        vc_turn_over <= (vc_turn_over == turn_over_max) ? 2'b00 : vc_turn_over+1'd1;
end


assign vpg_vc = reg_app_vc_turn_over_en ? vc_turn_over : vpg_header[7:6] ;

endmodule
// Local Variables:
// verilog-auto-inst-param-value:t
// End:

===FILE_END===pattern_test/video_pattern_generator_idi.v===
===FILE_START===pattern_test/sync_bus.v===END_HEADER===
module  sync_bus #(
    parameter BUS_WIDTH = 16,
    parameter INI_VALUE = {BUS_WIDTH{1'b0}}
)(
    src_clk,
    src_rstn,
    src_bus,
    dst_clk,
    dst_rstn,
    dst_bus
);

input  wire                             src_clk;
input  wire                             src_rstn;
input  wire [BUS_WIDTH-1:0]             src_bus;
input  wire                             dst_clk;
input  wire                             dst_rstn;
output wire [BUS_WIDTH-1:0]             dst_bus;

reg                                     update_src;
wire                                    update_src_d2;
reg  [BUS_WIDTH-1:0]                    src_bus_buf;
reg                                     update_dst;
wire                                    update_dst_d2;
reg  [BUS_WIDTH-1:0]                    dst_bus_buf;

always @( posedge src_clk or negedge src_rstn ) begin
    if ( !src_rstn ) begin
        update_src <= 1'b0;
    end
    else if ( update_src ) begin
        update_src <= ~update_dst_d2;
    end
    else if ( !update_dst_d2 ) begin
        update_src <= 1'b1;
    end
end

always @( posedge src_clk or negedge src_rstn ) begin
    if ( !src_rstn ) begin
        src_bus_buf <= INI_VALUE;
    end
    else if ( (!update_src) && (!update_dst_d2) ) begin
        src_bus_buf <= src_bus[BUS_WIDTH-1:0];
    end
end

sync2_cell_rstb  synchronizer_to_src  (
   .clk                                (src_clk),
   .reset_n                            (src_rstn),
   .data                               (update_dst),
   .qout                               (update_dst_d2)
);

assign  dst_bus                 = dst_bus_buf[BUS_WIDTH-1:0];

always @( posedge dst_clk or negedge dst_rstn ) begin
    if ( !dst_rstn ) begin
        update_dst <= 1'b0;
    end
    else begin
        update_dst <= update_src_d2;
    end
end

always @( posedge dst_clk or negedge dst_rstn ) begin
    if ( !dst_rstn ) begin
        dst_bus_buf <= INI_VALUE;
    end
    else if ( update_src_d2 ) begin
        dst_bus_buf <= src_bus_buf[BUS_WIDTH-1:0];
    end
end

sync2_cell_rstb  synchronizer_to_dst  (
   .clk                                (dst_clk),
   .reset_n                            (dst_rstn),
   .data                               (update_src),
   .qout                               (update_src_d2)
);

endmodule


===FILE_END===pattern_test/sync_bus.v===
===FILE_START===pattern_test/vprbs_err_inject.v===END_HEADER===
module vprbs_err_inject(/*autoarg*/
   // Outputs
   data_out,
   // Inputs
   clk, rst_n, data_in, data_en, err_inject_restart,
   reg_vprbs_err_inject_en, reg_vprbs_err_inject_intv_time,
   reg_vprbs_err_inject_intv_num
   );

    //inputs
    input                                         clk;
    input                                         rst_n;
    input      [63:0]                             data_in;
    input                                         data_en;
    input                                         err_inject_restart;
    input                                         reg_vprbs_err_inject_en;
    input      [ 7:0]                             reg_vprbs_err_inject_intv_time;
    input      [ 7:0]                             reg_vprbs_err_inject_intv_num;

    //outputs
    output     [63:0]                             data_out;

    reg        [63:0]                             data_c;
    wire       [32:0]                             scrb_out;
    reg        [ 7:0]                             vprbs_err_inject_intv_time_cnt;
    reg        [ 7:0]                             vprbs_err_inject_intv_num_cnt;
    wire       [ 7:0]                             reg_vprbs_err_inject_intv_num;
    wire       [ 7:0]                             reg_vprbs_err_inject_intv_time;
    wire                                          scrb_vld;
    reg        [32:0]                             scrb_save;

    assign scrb_vld = reg_vprbs_err_inject_en&&
                      (vprbs_err_inject_intv_time_cnt == (reg_vprbs_err_inject_intv_time))&&
                      (vprbs_err_inject_intv_num_cnt < (reg_vprbs_err_inject_intv_num));

    assign data_out = scrb_vld ? data_c : data_in ;
    

    always@(posedge clk or negedge rst_n)begin
        if(!rst_n)
            scrb_save <= {33{1'b1}};
        else if((data_en)&scrb_vld)
            scrb_save <= scrb_out;
    end
    
    always@(posedge clk or negedge rst_n)begin
        if(!rst_n)
            vprbs_err_inject_intv_time_cnt <= {8{1'b0}};
        else if(err_inject_restart)
            vprbs_err_inject_intv_time_cnt <= {8{1'b0}};
        else if(!reg_vprbs_err_inject_en)
            vprbs_err_inject_intv_time_cnt <= {8{1'b0}};
        else if(data_en)
            vprbs_err_inject_intv_time_cnt <= (vprbs_err_inject_intv_time_cnt >= (reg_vprbs_err_inject_intv_time)) ? {32{1'b0}}: vprbs_err_inject_intv_time_cnt + 1'd1;
    end

    always@(posedge clk or negedge rst_n)begin
        if(!rst_n)
            vprbs_err_inject_intv_num_cnt <= {8{1'b0}};
        else if(err_inject_restart)
            vprbs_err_inject_intv_num_cnt <= {8{1'b0}};
        else if(!reg_vprbs_err_inject_en)
            vprbs_err_inject_intv_num_cnt <= {8{1'b0}};
        else if((data_en)&&(vprbs_err_inject_intv_time_cnt == (reg_vprbs_err_inject_intv_time)))
            vprbs_err_inject_intv_num_cnt <= (vprbs_err_inject_intv_num_cnt == reg_vprbs_err_inject_intv_num) ? vprbs_err_inject_intv_num_cnt : vprbs_err_inject_intv_num_cnt + 1'd1;
    end

    scrambler_core_64bit u_scrambler_core_64bit(
       // Outputs
       .data_out    (data_c), 
       .lfsr_c      (scrb_out),
       // Inputs
       .data_in     (data_in), 
       .lfsr_q      (scrb_save)
       );



endmodule

===FILE_END===pattern_test/vprbs_err_inject.v===
===FILE_START===pattern_test/video_pattern_generator.v===END_HEADER===
// ------------------------------------------------------------------------------
// 
// Copyright 2015 - 2021 Synopsys, INC.
// 
// This Synopsys IP and all associated documentation are proprietary to
// Synopsys, Inc. and may only be used pursuant to the terms and conditions of a
// written license agreement with Synopsys, Inc. All other use, reproduction,
// modification, or distribution of the Synopsys IP or the associated
// documentation is strictly prohibited.
// 
// Component Name   : DWC_mipicsi2_device
// Component Version: 1.32a
// Release Type     : GA
// Build ID         : 85.222.61.51
// ------------------------------------------------------------------------------


`include "APP_device_all_rtl_includes.vh"

//-- Description : video Pattern Generator
module video_pattern_generator
(//---- PORT DECLARATION ------------------------------------------

  //System Interface
    input wire                                           ppi_clk                  ,
    input wire                                           ppi_clkrstz              ,

  //Configuration Interface
    input wire                                           vpg_en                   ,
    output reg                                           vpg_active               ,

    input wire                                           vpg_packet_lost_ack      ,
    output reg                                           vpg_packet_lost          ,

    input wire                                           vpg_orientation_qst      ,
    input wire                                           vpg_mode_qst             ,
    input wire                                           vpg_hsync_packet_en_qst  ,
    input wire  [`CSI2_DEVICE_VPG_VC_RS-1:0]             vpg_vc_qst               ,
    input  wire [`CSI2_DEVICE_VCX_DWIDTH-1:0]            vpg_vcx_qst              ,
    input wire  [`CSI2_DEVICE_VPG_DT_RS-1:0]             vpg_dt_qst               ,
    input wire  [`CSI2_DEVICE_VPG_PKT_SIZE_RS-1:0]       vpg_pkt_size_qst         ,
    input wire  [`CSI2_DEVICE_VPG_HSA_TIME_RS-1:0]       vpg_hsa_time_qst         ,
    input wire  [`CSI2_DEVICE_VPG_HBP_TIME_RS-1:0]       vpg_hbp_time_qst         ,
    input wire  [`CSI2_DEVICE_VPG_HLINE_TIME_RS-1:0]     vpg_hline_time_qst       ,
    input wire  [`CSI2_DEVICE_VPG_VSA_LINES_RS-1:0]      vpg_vsa_lines_qst        ,
    input wire  [`CSI2_DEVICE_VPG_VBP_LINES_RS-1:0]      vpg_vbp_lines_qst        ,
    input wire  [`CSI2_DEVICE_VPG_VFP_LINES_RS-1:0]      vpg_vfp_lines_qst        ,
    input wire  [`CSI2_DEVICE_VPG_ACT_LINES_RS-1:0]      vpg_vactive_lines_qst    ,
    input wire  [`CSI2_DEVICE_VPG_BK_LINES_RS -1:0]      vpg_bk_lines_qst         ,

    input wire  [`CSI2_DEVICE_VPG_FRAME_NUM_MODE_RS-1:0] vpg_frame_num_mode_qst   ,
    input wire  [`CSI2_DEVICE_VPG_MAX_FRAME_NUM_RS-1:0]  vpg_max_frame_num_qst    ,

    input wire  [`CSI2_DEVICE_VPG_LINE_NUM_MODE_RS-1:0]  vpg_line_num_mode_qst    ,
    input wire  [`CSI2_DEVICE_VPG_START_LINE_NUM_RS-1:0] vpg_start_line_num_qst   ,
    input wire  [`CSI2_DEVICE_VPG_STEP_LINE_NUM_RS-1:0]  vpg_step_line_num_qst    ,

  //Packet Interface
    output reg                                           vpg_packet_req           ,
    input  wire                                          vpg_header_gen_en        ,
    input  wire                                          vpg_payload_gen_en       ,
    output reg  [`CSI2_DEVICE_HD_WIDTH-1:0]              vpg_header               ,
    output wire [`CSI2_DEVICE_NAP_PLD_WIDTH-1:0]         vpg_payload              ,
    output wire                                          vpg_elastbuf_emptyz
  );

  //---- PARAMETERS DECLARATION ------------------------------------
  //Color components
  //For RAW and RGB
  localparam  [41:0]          WHITE      = {14'b11111111111111,14'b11111111111111,14'b11111111111111};  //RAW/RGB
  localparam  [41:0]          YELLOW     = {14'b11111111111111,14'b11111111111111,14'b00000000000000};
  localparam  [41:0]          CYAN       = {14'b00000000000000,14'b11111111111111,14'b11111111111111};
  localparam  [41:0]          GREEN      = {14'b00000000000000,14'b11111111111111,14'b00000000000000};
  localparam  [41:0]          MAGENTA    = {14'b11111111111111,14'b00000000000000,14'b11111111111111};
  localparam  [41:0]          RED        = {14'b11111111111111,14'b00000000000000,14'b00000000000000};
  localparam  [41:0]          BLUE       = {14'b00000000000000,14'b00000000000000,14'b11111111111111};
  localparam  [41:0]          BLACK      = {14'b00000000000000,14'b00000000000000,14'b00000000000000};

  //For YUV
  localparam  [29:0]          YUV_WHITE  = {10'd940, 10'd512,10'd512}; //YUV
  localparam  [29:0]          YUV_YELLOW = {10'd840, 10'd64 ,10'd584};
  localparam  [29:0]          YUV_CYAN   = {10'd680, 10'd664,10'd64 };
  localparam  [29:0]          YUV_GREEN  = {10'd580, 10'd216,10'd136};
  localparam  [29:0]          YUV_MAGENTA= {10'd424, 10'd808,10'd888};
  localparam  [29:0]          YUV_RED    = {10'd324, 10'd360,10'd960};
  localparam  [29:0]          YUV_BLUE   = {10'd164, 10'd960,10'd440};
  localparam  [29:0]          YUV_BLACK  = {10'd64 , 10'd512,10'd512};

  //For BER
  localparam  [7:0]           BER_COLOR1_COMPONENT = 8'b10101010;
  localparam  [7:0]           BER_COLOR2_COMPONENT = 8'b00110011;
  localparam  [7:0]           BER_COLOR3_COMPONENT = 8'b11110000;
  localparam  [7:0]           BER_COLOR4_COMPONENT = 8'b01111111;
  localparam  [7:0]           BER_COLOR5_COMPONENT = 8'b01010101;
  localparam  [7:0]           BER_COLOR6_COMPONENT = 8'b11001100;
  localparam  [7:0]           BER_COLOR7_COMPONENT = 8'b00001111;
  localparam  [7:0]           BER_COLOR8_COMPONENT = 8'b10000000;

  //---- SIGNALS DECLARATION -----------------------------------------------------
  reg                                         vpg_en_1d_r;
  reg                                         vpg_en_2d_r;
  wire                                        vpg_en_re;

  wire                                        all_request_finish;
  reg                                         vpg_packet_req_1d_r;
  wire                                        vpg_packet_req_fe;
  wire                                        vpg_active_clr;

  wire                                        count_en_clr;
  reg                                         count_en;
  reg  [14:0]                                 vcounter;
  reg  [15:0]                                 hcounter;
  wire [14:0]                                 vpg_vsa_vbp_lines_qst_sum;
  wire [14:0]                                 vpg_vsa_vbp_vactive_lines_qst_sum;
  wire [14:0]                                 frameline;
  wire [14:0]                                 frame_bk_line;
  wire [15:0]                                 linecycle;
  wire [15:0]                                 vpg_hsa_hbp_time_qst_sum;
  wire                                        vactline;
  wire                                        last_le_en;
  reg                                         frame_end;
  wire                                        vsync_start;

  wire                                        fs_req_en;
  wire                                        fe_req_en;
  wire                                        ls_req_en;
  wire                                        le_req_en;
  wire                                        vp_req_en;
  reg                                         fs_req;
  reg  [4:0]                                  fs_priority;
  reg                                         fe_req;
  reg  [4:0]                                  fe_priority;
  wire                                        hsync_start;
  reg                                         ls_req;
  reg  [4:0]                                  ls_priority;
  reg                                         le_req;
  reg  [4:0]                                  le_priority;
  wire                                        hactcycle_start;
  reg                                         vp_req;
  reg  [4:0]                                  vp_priority;
  wire  [2:0]                                 fs_priority_val;
  wire  [2:0]                                 fe_priority_val;
  wire  [2:0]                                 ls_priority_val;
  wire  [2:0]                                 le_priority_val;
  wire  [2:0]                                 vp_priority_val;
  wire                                        fs_req_lost_set;
  wire                                        fs_req_set;
  wire                                        fs_req_clr;
  wire                                        fs_priority_gen;
  wire                                        fs_priority_shift;
  wire                                        fe_req_lost_set;
  wire                                        fe_req_set;
  wire                                        fe_req_clr;
  wire                                        fe_priority_gen;
  wire                                        fe_priority_shift;
  wire                                        ls_req_lost_set;
  wire                                        ls_req_set;
  wire                                        ls_req_clr;
  wire                                        ls_priority_gen;
  wire                                        ls_priority_shift;
  wire                                        le_req_lost_set;
  wire                                        le_req_set;
  wire                                        le_req_clr;
  wire                                        le_priority_gen;
  wire                                        le_priority_shift;
  wire                                        vp_req_lost_set;
  wire                                        vp_req_set;
  wire                                        vp_req_clr;
  wire                                        vp_priority_gen;
  wire                                        vp_priority_shift;
  wire                                        fs_req_ack;
  wire                                        fe_req_ack;
  wire                                        ls_req_ack;
  wire                                        le_req_ack;
  wire                                        vp_req_ack;
  wire                                        req_ack;

  reg                                         odd_line;
  reg  [`CSI2_DEVICE_VPG_ACT_LINES_RS-1:0]    current_line;

  reg   [18:0]                                vpg_pkt_bits;

  wire  [15:0]                                vpg_wc;
  wire  [4:0]                                 req_ack_val;
  reg                                         fs_req_lost;
  reg                                         fe_req_lost;
  reg                                         ls_req_lost;
  reg                                         le_req_lost;
  reg                                         vp_req_lost;

  wire                                        vpg_packet_lost_en;

  reg [15:0]                                  line_number;
  reg [15:0]                                  frame_number;

  wire [10:0]                                 vertical_color_pixels;

  wire                                        vpg_orientation;

  wire [13:0]                                 horizontal_color1_position;
  wire [13:0]                                 horizontal_color2_position;
  wire [13:0]                                 horizontal_color3_position;
  wire [13:0]                                 horizontal_color4_position;
  wire [13:0]                                 horizontal_color5_position;
  wire [13:0]                                 horizontal_color6_position;
  wire [13:0]                                 horizontal_color7_position;

  reg  [13:0]                                 vertical_color1_position;
  reg  [13:0]                                 vertical_color2_position;
  reg  [13:0]                                 vertical_color3_position;
  reg  [13:0]                                 vertical_color4_position;
  reg  [13:0]                                 vertical_color5_position;
  reg  [13:0]                                 vertical_color6_position;
  reg  [13:0]                                 vertical_color7_position;

  wire [13:0]                                 vcolor1_pos_sent_pix_sub;
  wire [13:0]                                 vcolor2_pos_sent_pix_sub;
  wire [13:0]                                 vcolor3_pos_sent_pix_sub;
  wire [13:0]                                 vcolor4_pos_sent_pix_sub;
  wire [13:0]                                 vcolor5_pos_sent_pix_sub;
  wire [13:0]                                 vcolor6_pos_sent_pix_sub;
  wire [13:0]                                 vcolor7_pos_sent_pix_sub;

  reg  [5:0]                                  gen_pixels;
  reg  [13:0]                                 sent_pixels;
  wire [13:0]                                 sent_gen_pixels_sum;

  reg  [ 3:0]                                 gen_cnt_period;
  reg  [ 3:0]                                 current_gen_cnt;
  reg  [ 3:0]                                 next_gen_cnt;
  reg  [ 3:0]                                 current_gen_cnt_d1_r;
  reg  [ 3:0]                                 current_gen_cnt_d2_r;

  wire                                        data_in_zone0;
  wire                                        data_in_zone2;
  wire                                        data_in_zone4;
  wire                                        data_in_zone6;
  wire                                        data_in_zone8;
  wire                                        data_in_zone10;
  wire                                        data_in_zone12;
  wire                                        data_in_zone14;

  wire                                        data_in_zone1;
  wire                                        data_in_zone3;
  wire                                        data_in_zone5;
  wire                                        data_in_zone7;
  wire                                        data_in_zone9;
  wire                                        data_in_zone11;
  wire                                        data_in_zone13;

  reg                                         color_x_y;
  reg                                         color_2x_y;
  reg                                         color_3x_y;
  reg                                         color_4x_y;
  reg                                         color_5x_y;
  reg                                         color_6x_y;
  reg                                         color_7x_y;
  reg                                         color_8x_y;
  reg                                         color_9x_y;
  reg                                         color_10x_y;
  reg                                         color_11x_y;
  reg                                         color_12x_y;
  reg                                         color_13x_y;
  reg                                         color_14x_y;
  reg                                         color_15x_y;

  reg  [29:0]                                 odd_line_p_color1;
  reg  [29:0]                                 odd_line_p_color2;
  reg  [29:0]                                 odd_line_p_color3;
  reg  [29:0]                                 odd_line_p_color4;
  reg  [29:0]                                 odd_line_p_color5;
  reg  [29:0]                                 odd_line_p_color6;
  reg  [29:0]                                 odd_line_p_color7;
  reg  [29:0]                                 odd_line_p_color8;

  reg  [29:0]                                 even_line_p_color1;
  reg  [29:0]                                 even_line_p_color2;
  reg  [29:0]                                 even_line_p_color3;
  reg  [29:0]                                 even_line_p_color4;
  reg  [29:0]                                 even_line_p_color5;
  reg  [29:0]                                 even_line_p_color6;
  reg  [29:0]                                 even_line_p_color7;
  reg  [29:0]                                 even_line_p_color8;

  wire [29:0]                                 p_color1;
  wire [29:0]                                 p_color2;
  wire [29:0]                                 p_color3;
  wire [29:0]                                 p_color4;
  wire [29:0]                                 p_color5;
  wire [29:0]                                 p_color6;
  wire [29:0]                                 p_color7;
  wire [29:0]                                 p_color8;

  wire                                        color_0_is_p_color1;
  wire                                        color_0_is_p_color2;
  wire                                        color_0_is_p_color3;
  wire                                        color_0_is_p_color4;
  wire                                        color_0_is_p_color5;
  wire                                        color_0_is_p_color6;
  wire                                        color_0_is_p_color7;
  wire                                        color_0_is_p_color8;

  wire                                        color_1_is_p_color2;
  wire                                        color_1_is_p_color3;
  wire                                        color_1_is_p_color4;
  wire                                        color_1_is_p_color5;
  wire                                        color_1_is_p_color6;
  wire                                        color_1_is_p_color7;
  wire                                        color_1_is_p_color8;

  wire                                        color_2_is_p_color3;
  wire                                        color_2_is_p_color4;
  wire                                        color_2_is_p_color5;
  wire                                        color_2_is_p_color6;
  wire                                        color_2_is_p_color7;
  wire                                        color_2_is_p_color8;

  wire                                        color_3_is_p_color4;
  wire                                        color_3_is_p_color5;
  wire                                        color_3_is_p_color6;
  wire                                        color_3_is_p_color7;
  wire                                        color_3_is_p_color8;

  wire                                        color_4_is_p_color5;
  wire                                        color_4_is_p_color6;
  wire                                        color_4_is_p_color7;
  wire                                        color_4_is_p_color8;

  wire                                        color_5_is_p_color6;
  wire                                        color_5_is_p_color7;
  wire                                        color_5_is_p_color8;

  wire                                        color_6_is_p_color7;
  wire                                        color_6_is_p_color8;

  wire                                        color_7_is_p_color8;

  wire [7:0]                                  color_0_cal_nxt;
  wire [6:0]                                  color_1_cal_nxt;
  wire [5:0]                                  color_2_cal_nxt;
  wire [4:0]                                  color_3_cal_nxt;
  wire [3:0]                                  color_4_cal_nxt;
  wire [2:0]                                  color_5_cal_nxt;
  wire [1:0]                                  color_6_cal_nxt;
  wire                                        color_7_cal_nxt;

  reg  [7:0]                                  color_0_cal;
  reg  [6:0]                                  color_1_cal;
  reg  [5:0]                                  color_2_cal;
  reg  [4:0]                                  color_3_cal;
  reg  [3:0]                                  color_4_cal;
  reg  [2:0]                                  color_5_cal;
  reg  [1:0]                                  color_6_cal;
  reg                                         color_7_cal;

  reg  [29:0]                                 vpg_payload_color_0;
  reg  [29:0]                                 vpg_payload_color_1;
  reg  [29:0]                                 vpg_payload_color_2;
  reg  [29:0]                                 vpg_payload_color_3;
  reg  [29:0]                                 vpg_payload_color_4;
  reg  [29:0]                                 vpg_payload_color_5;
  reg  [29:0]                                 vpg_payload_color_6;
  reg  [29:0]                                 vpg_payload_color_7;

  reg                                         p2_index;
  reg  [1:0]                                  p3_index;
  reg  [1:0]                                  p4_index;
  reg  [2:0]                                  p5_index;
  reg  [2:0]                                  p6_index;
  reg  [2:0]                                  p7_index;
  reg  [2:0]                                  p8_index;
  reg  [2:0]                                  p9_index;
  reg  [2:0]                                  p10_index;
  reg  [2:0]                                  p11_index;
  reg  [2:0]                                  p12_index;
  reg  [2:0]                                  p13_index;
  reg  [2:0]                                  p14_index;
  reg  [2:0]                                  p15_index;
  reg  [2:0]                                  p16_index;

  reg                                        p2_index_nxt;
  reg [1:0]                                  p3_index_nxt;
  reg [1:0]                                  p4_index_nxt;
  reg [2:0]                                  p5_index_nxt;
  reg [2:0]                                  p6_index_nxt;
  reg [2:0]                                  p7_index_nxt;
  reg [2:0]                                  p8_index_nxt;
  reg [2:0]                                  p9_index_nxt;
  reg [2:0]                                  p10_index_nxt;
  reg [2:0]                                  p11_index_nxt;
  reg [2:0]                                  p12_index_nxt;
  reg [2:0]                                  p13_index_nxt;
  reg [2:0]                                  p14_index_nxt;
  reg [2:0]                                  p15_index_nxt;
  reg [2:0]                                  p16_index_nxt;



  wire [29:0]                                 p1;
  reg  [29:0]                                 p2;
  reg  [29:0]                                 p3;
  reg  [29:0]                                 p4;
  reg  [29:0]                                 p5;
  reg  [29:0]                                 p6;
  reg  [29:0]                                 p7;
  reg  [29:0]                                 p8;
  reg  [29:0]                                 p9;
  reg  [29:0]                                 p10;
  reg  [29:0]                                 p11;
  reg  [29:0]                                 p12;
  reg  [29:0]                                 p13;
  reg  [29:0]                                 p14;
  reg  [29:0]                                 p15;
  reg  [29:0]                                 p16;


  reg  [71:0]                                 first_category_pixels;
  reg  [63:0]                                 second_category_pixels;
  reg  [79:0]                                 third_category_pixels;
  reg  [111:0]                                fourth_category_pixels;
  reg  [95:0]                                 fifth_category_pixels;
  reg  [111:0]                                vpg_payload_shifter;
  wire                                        vpg_hdr_req;
  wire                                        vpg_pld_req;
  wire                                        vpg_pld_req_pre;
  reg                                         vpg_pld_req_1d_r;
  wire [15:0]                                 vpg_wc_minus1;
  reg  [15:0]                                 vpg_wc_init;
  wire                                        vpg_wc_init_mt_tx_num;
  reg  [15-`CSI2_DEVICE_PLD_BYTEEN_WIDTH:0]   vpg_pld_req_cnt;
  reg  [15-`CSI2_DEVICE_PLD_BYTEEN_WIDTH:0]   vpg_pld_req_cnt_nxt;
  reg                                         vpg_pld_gen_end;
  reg                                         vpg_pld_gen_end_nxt;
  wire                                        vpg_pld_req_cnt_lt_2;
  reg                                         vpg_pld_req_mt1_prd_nxt;
  reg                                         vpg_pld_req_mt1_prd;
  reg                                         vpg_pld_1st_req;
  wire                                        vpg_pld_1st_req_nxt;
  reg                                         buf_wr_req;
  reg                                         buf_wr_req_nxt;
  wire                                        buf_wr;
  wire                                        almost_full;
  wire                                        fullz;
  reg                                         vpg_packet_req_nxt;
  wire                                        vpg_hdr_req_ack;
  reg                                         vpg_packet_req_pre2;
  reg                                         vpg_packet_req_pre2_nxt;
  wire                                        vpg_header_req_ack_pre2;
  reg  [`CSI2_DEVICE_HD_WIDTH-1:0]            vpg_header_pre2;
  reg                                         vpg_packet_req_pre1;
  reg                                         vpg_packet_req_pre1_nxt;
  wire                                        vpg_header_req_ack_pre1;
  reg  [`CSI2_DEVICE_HD_WIDTH-1:0]            vpg_header_pre1;
  wire [`CSI2_DEVICE_NAP_PLD_WIDTH-1:0]       vpg_pld_shift_out;


  //---- COMBINATIONAL/SEQUENTIAL PROCESSES --------------------------------------

  ////////////////////////////////////////////////////////////////////////////////
  ////////////////////////// VPG CRTL ////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////

  //The rising edge detection pulse of vpg_en
  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : vpg_en_PROC
      if(~ppi_clkrstz) begin
          vpg_en_1d_r <= 1'b0;
          vpg_en_2d_r <= 1'b0;
      end else begin
          vpg_en_1d_r <= vpg_en;
          vpg_en_2d_r <= vpg_en_1d_r;
      end
  end //vpg_en_PROC

  assign vpg_en_re = vpg_en_1d_r & (~vpg_en_2d_r);

  //The counter enable generation
  //When vpg_en is de-asserted, complete frame timing should be finished and count_en should be de-asserted.
  assign count_en_clr = (hcounter == linecycle) & (vcounter == frameline) & (~vpg_en_1d_r);

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : count_en_PROC
      if(~ppi_clkrstz)
          count_en <= 1'b0;
      else
          if(vpg_en_re)
              count_en <= 1'b1;
          else
              if(count_en_clr)
                  count_en <= 1'b0;
  end //count_en_PROC

  //The vpg_active generation
  //When vpg_en is de-asserted, complete frame should be finished to send and vpg_active should be de-asserted.
  assign all_request_finish = (fs_priority == 5'b0) &
                              (fe_priority == 5'b0) &
                              (ls_priority == 5'b0) &
                              (le_priority == 5'b0) &
                              (vp_priority == 5'b0);

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : vpg_packet_req_1d_r_PROC
      if(~ppi_clkrstz)
          vpg_packet_req_1d_r <= 1'b0;
      else
          vpg_packet_req_1d_r <= vpg_packet_req;
  end //vpg_packet_req_1d_r_PROC

  assign vpg_packet_req_fe = (~vpg_packet_req) & vpg_packet_req_1d_r;

  //In normal case, when frame_end is one, all request is finished and vpg_packet_req is zero, so vpg_actvie will be de-asserted.
  //In error case, when all request is finished, vpg_packet_req will be de-asserted. So vpg_actvie will be de-asserted in the falling edge of vpg_packet_req.
  assign vpg_active_clr = (~count_en) & all_request_finish & (frame_end & (~vpg_packet_req)| vpg_packet_req_fe);

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : vpg_active_PROC
      if(~ppi_clkrstz)
          vpg_active <= 1'b0;
      else
          if(vpg_en_re)
              vpg_active <= 1'b1;
          else
              if(vpg_active_clr)
                  vpg_active <= 1'b0;
  end //vpg_active_PROC

  //Vertical counter for frame lines
  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : vcounter_PROC
      if(~ppi_clkrstz)
          vcounter <= 15'd0;
      else
          if(count_en) begin
              if(hcounter == linecycle) begin
                  if(vcounter == frame_bk_line)
                      vcounter <= 15'b0;
                  else
                  // spyglass disable_block W484
                  // SMD: Possible assignment overflow.
                  // SJ: Overflow can't occur. Protected by protocol.
                      vcounter <= vcounter + 15'd1;
                  // spyglass enable_block W484
              end else
                  vcounter <= vcounter;
          end else
              vcounter <= 15'b0;
  end //vcounter_PROC

  //Horizontal counter for ppi_clk cycles of line
  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : hcounter_PROC
      if(~ppi_clkrstz)
          hcounter <= 16'd0;
      else
          if(count_en) begin
              if(hcounter == linecycle)   // End of line
                  hcounter <= 16'b0;
              else
              // spyglass disable_block W484
              // SMD: Possible assignment overflow.
              // SJ: Overflow can't occur. Protected by protocol.
                  hcounter <= hcounter + 16'b1;
              // spyglass enable_block W484
          end else
              hcounter <= 16'b0;
  end //hcounter_PROC

  //The number of frame lines
  //VSA + VBP + VACTIVE + VFP
  // spyglass disable_block STARC05-2.10.6.6
  // SMD: The expression has more than one arithmetic operators
  // SJ: Better for code readability
  assign vpg_vsa_vbp_lines_qst_sum = (({5'd0,vpg_vsa_lines_qst} + {5'd0,vpg_vbp_lines_qst}) - 15'b1);
  // spyglass enable_block STARC05-2.10.6.6
  // spyglass disable_block W484
  // SMD: Possible assignment overflow.
  // SJ: Overflow can't occur. Protected by protocol.
  // spyglass disable_block W164a
  // SMD: LHS width is less than RHS width of assignment.
  // SJ: Overflow can't occur. Protected by protocol.
  assign vpg_vsa_vbp_vactive_lines_qst_sum = vpg_vsa_vbp_lines_qst_sum + {1'd0,vpg_vactive_lines_qst};
  assign frameline = vpg_vsa_vbp_vactive_lines_qst_sum + {5'd0,vpg_vfp_lines_qst};
  assign frame_bk_line = frameline + {5'd0,vpg_bk_lines_qst};
  // spyglass enable_block W164a
  // spyglass enable_block W484

  //The number of ppi_clk cycles of line
  //HLINE
  assign linecycle = {1'b0,vpg_hline_time_qst} - 16'b1;

  //The indication of VACTIVE
  //> VSA + VBP, <= VSA + VBP + VACTIVE
  assign vactline = (vcounter >  vpg_vsa_vbp_lines_qst_sum) &
                    (vcounter <= vpg_vsa_vbp_vactive_lines_qst_sum);

  //The end point of frame
  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : frame_end_PROC
      if(~ppi_clkrstz)
          frame_end <= 1'b0;
      else
          frame_end <= (hcounter == linecycle) & (vcounter == frameline);
  end //frame_end_PROC

  //Frame start packet request
  //If a request is not accepted and the same request is generated again, the same request will be lost.
  //When the condition of request is generated, check the other request and set the priority number of this request.
  //The 5'b00001 is highest priority and the 5'b10000 is lowest priority.
  //The request of FS is generated when the hcounter is 0.
  assign vsync_start = count_en & (hcounter == 16'b0) & (vcounter == 15'b0);
  assign fs_req_en   = vsync_start;

  // spyglass disable_block STARC05-2.10.6.6
  // SMD: The expression has more than one arithmetic operators
  // SJ: Better for code readability
  assign fs_priority_val = {2'b0,fe_req & (~fe_req_ack)} + {2'b0,ls_req & (~ls_req_ack)} +
                           {2'b0,le_req & (~le_req_ack)} + {2'b0,vp_req & (~vp_req_ack)};
  // spyglass enable_block STARC05-2.10.6.6

  // The generation of frame start request lost, frame start request and frame start request priority .
  // The -> means the fs_priority shift one bit to right.
  // The * means it generates the packet for the request which is highest priority base on the priority of all requests.
  // Current                                |     Next
  // fs_req_en  fs_req  fs_req_ack  req_ack | fs_req_lost    fs_req    fs_priority
  // ______________________________________ |_________________________________________
  //     0        0         0          0    |       0        fs_req    fs_priority
  //     0        0         0          1    |       0        fs_req    fs_priority
  //     0        1         0          0    |       0        fs_req    fs_priority
  //     0        1         0          1    |       0        fs_req    fs_priority->
  //     0        1         1          1    |       0           0      fs_priority->
  //
  //     1        0         0          0    |       0           1      fs_priority*
  //     1        0         0          1    |       0           1      fs_priority*
  //     1        1         0          0    |       1        fs_req    fs_priority
  //     1        1         0          1    |       1        fs_req    fs_priority->
  //     1        1         1          1    |       0        fs_req    fs_priority*

  // Current                                |     Next
  // fs_req_en  fs_req  fs_req_ack  req_ack | fs_req_lost
  // ______________________________________ |_____________
  //     1        1         0          0    |       1
  //     1        1         0          1    |       1
    assign fs_req_lost_set = fs_req_en & fs_req & (~fs_req_ack);

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : fs_req_lost_PROC
      if(~ppi_clkrstz)
          fs_req_lost  <= 1'd0;
      else
          if(vpg_en_re)
              fs_req_lost  <= 1'd0;
          else
              if(fs_req_lost_set)
                  fs_req_lost <= 1'b1;
              else
                  fs_req_lost <= 1'b0;
  end //fs_req_lost_PROC

  // Current                                |Next
  // fs_req_en  fs_req  fs_req_ack  req_ack |fs_req
  // ______________________________________ |______
  //     0        1         1          1    |   0
  //     1        0         0          0    |   1
  //     1        0         0          1    |   1
  assign fs_req_set = fs_req_en & (~fs_req) ;
  assign fs_req_clr = (~fs_req_en) & fs_req_ack;

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : fs_req_PROC
      if(~ppi_clkrstz)
          fs_req  <= 1'd0;
      else
          if(vpg_en_re)
              fs_req  <= 1'd0;
          else
              if(fs_req_set)
                  fs_req <= 1'b1;
              else
                  if(fs_req_clr)
                      fs_req <= 1'b0;
  end //fs_req_PROC

  // Current                                |Next
  // fs_req_en  fs_req  fs_req_ack  req_ack |fs_priority
  // ______________________________________ |_______________
  //     0        1         1          1    |fs_priority->
  //     0        1         0          1    |fs_priority->
  //     1        1         0          1    |fs_priority->
  //     1        0         0          0    |fs_priority*
  //     1        0         0          1    |fs_priority*
  //     1        1         1          1    |fs_priority*
  assign fs_priority_gen  =  (fs_req_en & (~fs_req))|
                             (fs_req_en & fs_req_ack) ;

  assign fs_priority_shift = ((~fs_req_en) & fs_req & req_ack) |
                              (fs_req & (~fs_req_ack) & req_ack);

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : fs_priority_PROC
      if(~ppi_clkrstz)
          fs_priority  <= 5'b0;
      else
          if(vpg_en_re)
              fs_priority  <= 5'b0;
          else
              if(fs_priority_gen)
                  case(fs_priority_val)
                      3'd0: fs_priority <= 5'b00001;
                      3'd1: fs_priority <= 5'b00010;
                      3'd2: fs_priority <= 5'b00100;
                      3'd3: fs_priority <= 5'b01000;
                      default: fs_priority <= 5'b10000;
                  endcase
              else
                  if(fs_priority_shift)
                      fs_priority   <= {1'b0,fs_priority[4:1]};
  end //fs_priority_PROC

  //Frame end packet request
  //When vpg_en is de-asserted, complete frame timing should be finished and a Frame End Packet should be sent.
  //If a request is not accepted and the same request is generated again, the same request will be lost.
  //When the condition of request is generated, check the other request and set the priority number of this request.
  //The 5'b00001 is highest priority and the 5'b10000 is lowest priority.
  //The request of LS is generated when the hcounter is 3. When hline is less than 3, the request of LS is generated when the hcounter is hline.
  assign fe_req_en   = count_en & (vcounter == frameline) & ((linecycle < 16'h3)? (hcounter == linecycle):
                                                                                  (hcounter == 16'h3));
  // spyglass disable_block STARC05-2.10.6.6
  // SMD: The expression has more than one arithmetic operators
  // SJ: Better for code readability
  assign fe_priority_val = {2'b0,fs_req & (~fs_req_ack)} + {2'b0,ls_req & (~ls_req_ack)} +
                           {2'b0,le_req & (~le_req_ack)} + {2'b0,vp_req & (~vp_req_ack)};
  // spyglass enable_block STARC05-2.10.6.6

  // The generation of frame start request lost, frame start request and frame start request priority .
  // The -> means the fs_priority shift one bit to right.
  // The * means it generates the packet for the request which is highest priority base on the priority of all requests.
  // Current                                |     Next
  // fe_req_en  fe_req  fe_req_ack  req_ack | fe_req_lost    fe_req    fe_priority
  // ______________________________________ |_________________________________________
  //     0        0         0          0    |       0        fe_req    fe_priority
  //     0        0         0          1    |       0        fe_req    fe_priority
  //     0        1         0          0    |       0        fe_req    fe_priority
  //     0        1         0          1    |       0        fe_req    fe_priority->
  //     0        1         1          1    |       0           0      fe_priority->
  //
  //     1        0         0          0    |       0           1      fe_priority*
  //     1        0         0          1    |       0           1      fe_priority*
  //     1        1         0          0    |       1        fe_req    fe_priority
  //     1        1         0          1    |       1        fe_req    fe_priority->
  //     1        1         1          1    |       0        fe_req    fe_priority*

  // Current                                |     Next
  // fe_req_en  fe_req  fe_req_ack  req_ack | fe_req_lost
  // ______________________________________ |_____________
  //     1        1         0          0    |       1
  //     1        1         0          1    |       1
  assign fe_req_lost_set = fe_req_en & fe_req & (~fe_req_ack);

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : fe_req_lost_PROC
      if(~ppi_clkrstz)
          fe_req_lost  <= 1'd0;
      else
          if(vpg_en_re)
              fe_req_lost  <= 1'd0;
          else
              if(fe_req_lost_set)
                  fe_req_lost <= 1'b1;
              else
                  fe_req_lost <= 1'b0;
  end //fe_req_lost_PROC

  // Current                                |Next
  // fe_req_en  fe_req  fe_req_ack  req_ack |fe_req
  // ______________________________________ |______
  //     0        1         1          1    |   0
  //     1        0         0          0    |   1
  //     1        0         0          1    |   1
  assign fe_req_set = fe_req_en & (~fe_req);
  assign fe_req_clr = (~fe_req_en) & fe_req_ack;

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : fe_req_PROC
      if(~ppi_clkrstz)
          fe_req  <= 1'd0;
      else
          if(vpg_en_re)
              fe_req  <= 1'd0;
          else
              if(fe_req_set)
                  fe_req <= 1'b1;
              else
                  if(fe_req_clr)
                      fe_req <= 1'b0;
  end //fe_req_PROC

  // Current                                |Next
  // fe_req_en  fe_req  fe_req_ack  req_ack |fe_priority
  // ______________________________________ |_______________
  //     0        1         1          1    |fe_priority->
  //     0        1         0          1    |fe_priority->
  //     1        1         0          1    |fe_priority->
  //     1        0         0          0    |fe_priority*
  //     1        0         0          1    |fe_priority*
  //     1        1         1          1    |fe_priority*
  assign fe_priority_gen  =  (fe_req_en & (~fe_req))|
                             (fe_req_en & fe_req_ack) ;

  assign fe_priority_shift = ((~fe_req_en) & fe_req & req_ack) |
                              (fe_req & (~fe_req_ack) & req_ack);

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : fe_priority_PROC
      if(~ppi_clkrstz)
          fe_priority  <= 5'b0;
      else
          if(vpg_en_re)
              fe_priority  <= 5'b0;
          else
              if(fe_priority_gen)
                  case(fe_priority_val)
                      3'd0: fe_priority <= 5'b00001;
                      3'd1: fe_priority <= 5'b00010;
                      3'd2: fe_priority <= 5'b00100;
                      3'd3: fe_priority <= 5'b01000;
                      default: fe_priority <= 5'b10000;
                  endcase
              else
                  if(fe_priority_shift)
                      fe_priority   <= {1'b0,fe_priority[4:1]};
  end //fe_priority_PROC

  //Line start packet request
  //If a request is not accepted and the same request is generated again, the same request will be lost.
  //When the condition of request is generated, check the other request and set the priority number of this request.
  //The 5'b00001 is highest priority and the 5'b10000 is lowest priority.
  //The request of LS is generated when the hcounter is 1. When hline is less than 1, the request of LS is generated when the hcounter is hline.
  assign ls_req_en         = count_en & (vcounter <= frameline) & ((linecycle < 16'h1)? (hcounter == linecycle):
                                                                                        (hcounter == 16'h1));
  // spyglass disable_block STARC05-2.10.6.6
  // SMD: The expression has more than one arithmetic operators
  // SJ: Better for code readability
  assign ls_priority_val = {2'b0,fe_req & (~fe_req_ack)} + {2'b0,fs_req & (~fs_req_ack)} +
                           {2'b0,le_req & (~le_req_ack)} + {2'b0,vp_req & (~vp_req_ack)};
  // spyglass enable_block STARC05-2.10.6.6

  // The generation of frame start request lost, frame start request and frame start request priority .
  // The -> means the fs_priority shift one bit to right.
  // The * means it generates the packet for the request which is highest priority base on the priority of all requests.
  // Current                                |     Next
  // ls_req_en  ls_req  ls_req_ack  req_ack | ls_req_lost    ls_req    ls_priority
  // ______________________________________ |_________________________________________
  //     0        0         0          0    |       0        ls_req    ls_priority
  //     0        0         0          1    |       0        ls_req    ls_priority
  //     0        1         0          0    |       0        ls_req    ls_priority
  //     0        1         0          1    |       0        ls_req    ls_priority->
  //     0        1         1          1    |       0           0      ls_priority->
  //
  //     1        0         0          0    |       0           1      ls_priority*
  //     1        0         0          1    |       0           1      ls_priority*
  //     1        1         0          0    |       1        ls_req    ls_priority
  //     1        1         0          1    |       1        ls_req    ls_priority->
  //     1        1         1          1    |       0        ls_req    ls_priority*

  // Current                                |     Next
  // ls_req_en  ls_req  ls_req_ack  req_ack | ls_req_lost
  // ______________________________________ |_____________
  //     1        1         0          0    |       1
  //     1        1         0          1    |       1
  assign ls_req_lost_set = ls_req_en & ls_req & (~ls_req_ack);

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : ls_req_lost_PROC
      if(~ppi_clkrstz)
          ls_req_lost  <= 1'd0;
      else
          if(vpg_en_re|(~vpg_hsync_packet_en_qst))
              ls_req_lost  <= 1'd0;
          else
              if(ls_req_lost_set)
                  ls_req_lost <= 1'b1;
              else
                  ls_req_lost <= 1'b0;
  end //ls_req_lost_PROC

  // Current                                |Next
  // ls_req_en  ls_req  ls_req_ack  req_ack |ls_req
  // ______________________________________ |______
  //     0        1         1          1    |   0
  //     1        0         0          0    |   1
  //     1        0         0          1    |   1
  assign ls_req_set = ls_req_en & (~ls_req);
  assign ls_req_clr = (~ls_req_en) & ls_req_ack;

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : ls_req_PROC
      if(~ppi_clkrstz)
          ls_req  <= 1'd0;
      else
          if(vpg_en_re|(~vpg_hsync_packet_en_qst))
              ls_req  <= 1'd0;
          else
              if(ls_req_set)
                  ls_req <= 1'b1;
              else
                  if(ls_req_clr)
                      ls_req <= 1'b0;
  end //ls_req_PROC

  // Current                                |Next
  // ls_req_en  ls_req  ls_req_ack  req_ack |ls_priority
  // ______________________________________ |_______________
  //     0        1         1          1    |ls_priority->
  //     0        1         0          1    |ls_priority->
  //     1        1         0          1    |ls_priority->
  //     1        0         0          0    |ls_priority*
  //     1        0         0          1    |ls_priority*
  //     1        1         1          1    |ls_priority*
  assign ls_priority_gen  =  (ls_req_en & (~ls_req))|
                             (ls_req_en & ls_req_ack) ;

  assign ls_priority_shift = ((~ls_req_en) & ls_req & req_ack) |
                              (ls_req & (~ls_req_ack) & req_ack);

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : ls_priority_PROC
      if(~ppi_clkrstz)
          ls_priority  <= 5'b0;
      else
          if(vpg_en_re|(~vpg_hsync_packet_en_qst))
              ls_priority  <= 5'b0;
          else
              if(ls_priority_gen)
                  case(ls_priority_val)
                      3'd0: ls_priority <= 5'b00001;
                      3'd1: ls_priority <= 5'b00010;
                      3'd2: ls_priority <= 5'b00100;
                      3'd3: ls_priority <= 5'b01000;
                      default: ls_priority <= 5'b10000;
                  endcase
              else
                  if(ls_priority_shift)
                      ls_priority   <= {1'b0,ls_priority[4:1]};
  end //ls_priority_PROC

  //Line end packet request
  //If a request is not accepted and the same request is generated again, the same request will be lost.
  //When the condition of request is generated, check the other request and set the priority number of this request.
  //The 5'b00001 is highest priority and the 5'b10000 is lowest priority.
  //The request of LE is generated when the hcounter is 0. The request of Last LE is generated when the hcounter is 2.
  //When hline is less than 2, the request of Last LS is generated when the hcounter is hline.
  assign hsync_start    = count_en & (hcounter == 16'b0) & (vcounter <= frameline);
  assign last_le_en     = count_en & (vcounter == frameline) & ((linecycle < 16'h2)? (hcounter == linecycle):
                                                                                     (hcounter == 16'h2));
  assign le_req_en      = (hsync_start & (~vsync_start)) | last_le_en;

  // spyglass disable_block STARC05-2.10.6.6
  // SMD: The expression has more than one arithmetic operators
  // SJ: Better for code readability
  assign le_priority_val = {2'b0,fe_req & (~fe_req_ack)} + {2'b0,fs_req & (~fs_req_ack)} +
                           {2'b0,ls_req & (~ls_req_ack)} + {2'b0,vp_req & (~vp_req_ack)};
  // spyglass enable_block STARC05-2.10.6.6

  // The generation of frame start request lost, frame start request and frame start request priority .
  // The -> means the fs_priority shift one bit to right.
  // The * means it generates the packet for the request which is highest priority base on the priority of all requests.
  // Current                                |     Next
  // le_req_en  le_req  le_req_ack  req_ack | le_req_lost    le_req    le_priority
  // ______________________________________ |_________________________________________
  //     0        0         0          0    |       0        le_req    le_priority
  //     0        0         0          1    |       0        le_req    le_priority
  //     0        1         0          0    |       0        le_req    le_priority
  //     0        1         0          1    |       0        le_req    le_priority->
  //     0        1         1          1    |       0           0      le_priority->
  //
  //     1        0         0          0    |       0           1      le_priority*
  //     1        0         0          1    |       0           1      le_priority*
  //     1        1         0          0    |       1        le_req    le_priority
  //     1        1         0          1    |       1        le_req    le_priority->
  //     1        1         1          1    |       0        le_req    le_priority*

  // Current                                |     Next
  // le_req_en  le_req  le_req_ack  req_ack | le_req_lost
  // ______________________________________ |_____________
  //     1        1         0          0    |       1
  //     1        1         0          1    |       1
  assign le_req_lost_set = le_req_en & le_req & (~le_req_ack);

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : le_req_lost_PROC
      if(~ppi_clkrstz)
          le_req_lost  <= 1'd0;
      else
          if(vpg_en_re|(~vpg_hsync_packet_en_qst))
              le_req_lost  <= 1'd0;
          else
              if(le_req_lost_set)
                  le_req_lost <= 1'b1;
              else
                  le_req_lost <= 1'b0;
  end //le_req_lost_PROC

  // Current                                |Next
  // le_req_en  le_req  le_req_ack  req_ack |le_req
  // ______________________________________ |______
  //     0        1         1          1    |   0
  //     1        0         0          0    |   1
  //     1        0         0          1    |   1
  assign le_req_set = le_req_en & (~le_req);
  assign le_req_clr = (~le_req_en) & le_req_ack;

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : le_req_PROC
      if(~ppi_clkrstz)
          le_req  <= 1'd0;
      else
          if(vpg_en_re|(~vpg_hsync_packet_en_qst))
              le_req  <= 1'd0;
          else
              if(le_req_set)
                  le_req <= 1'b1;
              else
                  if(le_req_clr)
                      le_req <= 1'b0;
  end //le_req_PROC

  // Current                                |Next
  // le_req_en  le_req  le_req_ack  req_ack |le_priority
  // ______________________________________ |_______________
  //     0        1         1          1    |le_priority->
  //     0        1         0          1    |le_priority->
  //     1        1         0          1    |le_priority->
  //     1        0         0          0    |le_priority*
  //     1        0         0          1    |le_priority*
  //     1        1         1          1    |le_priority*
  assign le_priority_gen  =  (le_req_en & (~le_req))|
                             (le_req_en & le_req_ack) ;

  assign le_priority_shift = ((~le_req_en) & le_req & req_ack) |
                              (le_req & (~le_req_ack) & req_ack);

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : le_priority_PROC
      if(~ppi_clkrstz)
          le_priority  <= 5'b0;
      else
          if(vpg_en_re|(~vpg_hsync_packet_en_qst))
              le_priority  <= 5'b0;
          else
              if(le_priority_gen)
                  case(le_priority_val)
                      3'd0: le_priority <= 5'b00001;
                      3'd1: le_priority <= 5'b00010;
                      3'd2: le_priority <= 5'b00100;
                      3'd3: le_priority <= 5'b01000;
                      default: le_priority <= 5'b10000;
                  endcase
              else
                  if(le_priority_shift)
                      le_priority   <= {1'b0,le_priority[4:1]};
  end //le_priority_PROC

  //video pattern packet request
  //If a request is not accepted and the same request is generated again, the same request will be lost.
  //When the condition of request is generated, check the other request and set the priority number of this request.
  //The 5'b00001 is highest priority and the 5'b10000 is lowest priority.
  //The request of Data Packet is generated when the hcounter is vpg_hsa_time_qst + vpg_hbp_time_qst.
  //When hline is less than vpg_hsa_time_qst + vpg_hbp_time_qst, the request of LS is generated when the hcounter is hline.
  assign vpg_hsa_hbp_time_qst_sum = ({4'd0,vpg_hsa_time_qst} + {4'd0,vpg_hbp_time_qst});
  assign hactcycle_start  = vactline & ((linecycle < vpg_hsa_hbp_time_qst_sum)?(hcounter == linecycle):
                                                                               (hcounter == vpg_hsa_hbp_time_qst_sum));
//  assign vline_end = vactline & (hcounter == linecycle);
  assign vp_req_en        = hactcycle_start;

  // spyglass disable_block STARC05-2.10.6.6
  // SMD: The expression has more than one arithmetic operators
  // SJ: Better for code readability
  assign vp_priority_val = {2'b0,fs_req & (~fs_req_ack)} + {2'b0,fe_req & (~fe_req_ack)} +
                           {2'b0,ls_req & (~ls_req_ack)} + {2'b0,le_req & (~le_req_ack)};
  // spyglass enable_block STARC05-2.10.6.6

  // The generation of frame start request lost, frame start request and frame start request priority .
  // The -> means the fs_priority shift one bit to right.
  // The * means it generates the packet for the request which is highest priority base on the priority of all requests.
  // Current                                |     Next
  // vp_req_en  vp_req  vp_req_ack  req_ack | vp_req_lost   vp_req    vp_priority
  // _______________________________________|_________________________________________________
  //     0         0        0          0    |      0        vp_req    vp_priority
  //     0         0        0          1    |      0        vp_req    vp_priority
  //     0         1        0          0    |      0        vp_req    vp_priority
  //     0         1        0          1    |      0        vp_req    vp_priority->
  //     0         1        1          1    |      0           0      vp_priority->
  //
  //     1         0        0          0    |      0           1      vp_priority*
  //     1         0        0          1    |      0           1      vp_priority*
  //     1         1        0          0    |      1        vp_req    vp_priority
  //     1         1        0          1    |      1        vp_req    vp_priority->
  //     1         1        1          1    |      0        vp_req    vp_priority*

  // Current                                |     Next
  // vp_req_en  vp_req  vp_req_ack  req_ack | vp_req_lost
  // _______________________________________|_____________
  //     1        1          0         0    |       1
  //     1        1          0         1    |       1
  assign vp_req_lost_set = vp_req_en & vp_req & (~vp_req_ack);

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : vp_req_lost_PROC
      if(~ppi_clkrstz)
          vp_req_lost  <= 1'd0;
      else
          if(vpg_en_re)
              vp_req_lost  <= 1'd0;
          else
              if(vp_req_lost_set)
                  vp_req_lost <= 1'b1;
              else
                  vp_req_lost <= 1'b0;
  end //vp_req_lost_PROC

  // Current                                |Next
  // vp_req_en  vp_req  vp_req_ack  req_ack |vp_req
  // ______________________________________ |______
  //     0        1         1          1    |   0
  //     1        0         0          0    |   1
  //     1        0         0          1    |   1
  assign vp_req_set = vp_req_en & (~vp_req) ;
  assign vp_req_clr = (~vp_req_en) & vp_req_ack;

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : vp_req_PROC
      if(~ppi_clkrstz)
          vp_req  <= 1'd0;
      else
          if(vpg_en_re)
              vp_req  <= 1'd0;
          else
              if(vp_req_set)
                  vp_req <= 1'b1;
              else
                  if(vp_req_clr)
                      vp_req <= 1'b0;
  end //vp_req_PROC

  // Current                                |Next
  // vp_req_en  vp_req  vp_req_ack  req_ack |vp_priority
  // ______________________________________ |_______________
  //     0        1         1          1    |vp_priority->
  //     0        1         0          1    |vp_priority->
  //     1        1         0          1    |vp_priority->
  //     1        0         0          0    |vp_priority*
  //     1        0         0          1    |vp_priority*
  //     1        1         1          1    |vp_priority*
  assign vp_priority_gen  =  (vp_req_en & (~vp_req))|
                             (vp_req_en & vp_req_ack) ;

  assign vp_priority_shift = (((~vp_req_en) & vp_req & req_ack) |
                              (vp_req & (~vp_req_ack) & req_ack)) & (sent_pixels == 14'b0);

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : vp_priority_PROC
      if(~ppi_clkrstz)
          vp_priority  <= 5'b0;
      else
          if(vpg_en_re)
              vp_priority  <= 5'b0;
          else
              if(vp_priority_gen)
                  case(vp_priority_val)
                      3'd0: vp_priority <= 5'b00001;
                      3'd1: vp_priority <= 5'b00010;
                      3'd2: vp_priority <= 5'b00100;
                      3'd3: vp_priority <= 5'b01000;
                      default: vp_priority <= 5'b10000;
                  endcase
              else
                  if(vp_priority_shift)
                      vp_priority   <= {1'b0,vp_priority[4:1]};
  end //vp_priority_PROC

  //Current Line and Odd/Even Lineindication in VACTIVE
  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : current_line_PROC
      if(~ppi_clkrstz)begin
          current_line <= `CSI2_DEVICE_VPG_ACT_LINES_RS'b0;
      end else begin
          if(fs_req_ack)begin
              current_line <= `CSI2_DEVICE_VPG_ACT_LINES_RS'b1;
          end else begin
              if(vpg_pld_gen_end)begin
              // spyglass disable_block W484
              // SMD: Possible assignment overflow.
              // SJ: Overflow can't occur. Protected by protocol.
                  current_line <= current_line + `CSI2_DEVICE_VPG_ACT_LINES_RS'b1;
              // spyglass enable_block W484
              end
          end
      end
  end //current_odd_line_PROC

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : odd_line_PROC
      if(~ppi_clkrstz)
          odd_line     <= 1'b0;
      else
          if(fs_req_ack)
              odd_line <= 1'b1;
          else
              if(vpg_pld_gen_end)
                  odd_line <= ~odd_line;
  end //odd_line_PROC

  assign vpg_hdr_req = fs_req | fe_req | ls_req | le_req | vp_req;

  //The ack for packet request
  //The requested order should be guaranteed.
  assign req_ack           = ~(vpg_packet_req_pre2 & (~vpg_header_req_ack_pre2));
  assign vpg_hdr_req_ack   = vpg_hdr_req & req_ack;

  assign vp_req_ack         = vp_priority[0] & req_ack & (sent_pixels == 14'b0);
  assign fs_req_ack         = fs_priority[0] & req_ack;
  assign fe_req_ack         = fe_priority[0] & req_ack;
  assign ls_req_ack         = ls_priority[0] & req_ack;
  assign le_req_ack         = le_priority[0] & req_ack;

  //If there is a request is not accepted by state machine and the same request is happened again, the second request will be lost.
  //If a packet request is lost, the packet lost alarm will happen.
  assign vpg_packet_lost_en = fs_req_lost | fe_req_lost | ls_req_lost | le_req_lost| vp_req_lost;

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : vpg_packet_lost_PROC
      if(~ppi_clkrstz)
          vpg_packet_lost <= 1'b0;
      else
          if(vpg_packet_lost_ack)
              vpg_packet_lost <= 1'b0;
          else
              if(vpg_packet_lost_en)
                  vpg_packet_lost <= 1'b1;
  end //vpg_packet_lost_PROC

  ////////////////////////////////////////////////////////////////////////////////
  ////////////////////////// HEADER INFORMATION GENERATION ///////////////////////
  ////////////////////////////////////////////////////////////////////////////////
  //Calculate the bit number of one packet based on data type and packet size and odd/even line
//  assign next_odd_line = ~odd_line;
  always @* begin : vpg_pkt_bits_PROC
      case(vpg_dt_qst)
          `CSI2_RAW6: begin // Bits of one pixel is 6
              vpg_pkt_bits    = {3'b0,vpg_pkt_size_qst,2'b0} +
                                {4'b0,vpg_pkt_size_qst,1'b0} ;
          end
          `CSI2_RAW7: begin // Bits of one pixel is 7
              // spyglass disable_block STARC05-2.10.6.6
              // SMD: The expression has more than one arithmetic operators
              // SJ: Better for code readability
              vpg_pkt_bits    = {3'b0,vpg_pkt_size_qst,2'b0} +
                                {4'b0,vpg_pkt_size_qst,1'b0} +
                                {5'b0,vpg_pkt_size_qst} ;
              // spyglass enable_block STARC05-2.10.6.6
          end
          `CSI2_RAW8:begin // Bits of one pixel is 8
              vpg_pkt_bits    = {2'b0,vpg_pkt_size_qst,3'b0};
          end
          `CSI2_CSPS_Y420_8B,
          `CSI2_Y420_8B:begin
              if(odd_line)  // Bits of one pixel is 8
                  vpg_pkt_bits    = {2'b0,vpg_pkt_size_qst,3'b0};
              else         // Bits of one pixel is 16
                  vpg_pkt_bits    = {1'b0,vpg_pkt_size_qst,4'b0};
          end
          `CSI2_RAW10:begin // Bits of one pixel is 10
              vpg_pkt_bits    = {2'b0,vpg_pkt_size_qst,3'b0} +
                                {4'b0,vpg_pkt_size_qst,1'b0};
          end
          `CSI2_CSPS_Y420_10B,
          `CSI2_Y420_10B:begin
              if(odd_line)  // Bits of one pixel is 8
                  vpg_pkt_bits    = {2'b0,vpg_pkt_size_qst,3'b0} +
                                    {4'b0,vpg_pkt_size_qst,1'b0};
              else        // Bits of one pixel is 20
                  vpg_pkt_bits    = {1'b0,vpg_pkt_size_qst,4'b0} +
                                    {3'b0,vpg_pkt_size_qst,2'b0} ;
          end
          `CSI2_RAW12,
          `CSI2_LY420_8B:begin // Bits of one pixel is 12
              vpg_pkt_bits    = {2'b0,vpg_pkt_size_qst,3'b0} +
                                {3'b0,vpg_pkt_size_qst,2'b0};
          end
          `CSI2_RAW14:begin // Bits of one pixel is 14
              // spyglass disable_block STARC05-2.10.6.6
              // SMD: The expression has more than one arithmetic operators
              // SJ: Better for code readability
              vpg_pkt_bits    = {2'b0,vpg_pkt_size_qst,3'b0} +
                                {3'b0,vpg_pkt_size_qst,2'b0} +
                                {4'b0,vpg_pkt_size_qst,1'b0} ;
              // spyglass enable_block STARC05-2.10.6.6
          end
          `CSI2_RGB444,
          `CSI2_RGB555,
          `CSI2_RGB565,
          `CSI2_Y422_8B,
          `CSI2_RAW16:begin // Bits of one pixel is 16
              vpg_pkt_bits    = {1'b0,vpg_pkt_size_qst,4'b0};
          end
          `CSI2_RGB666:begin // Bits of one pixel is 18
              vpg_pkt_bits    = {1'b0,vpg_pkt_size_qst,4'b0} +
                                {4'b0,vpg_pkt_size_qst,1'b0};
          end
          `CSI2_Y422_10B,
          `CSI2_RAW20:begin // Bits of one pixel is 20
              vpg_pkt_bits    = {1'b0,vpg_pkt_size_qst,4'b0} +
                                {3'b0,vpg_pkt_size_qst,2'b0};
          end
          `CSI2_RAW24,
          `CSI2_RGB888:begin // Bits of one pixel is 24
              vpg_pkt_bits    = {1'b0,vpg_pkt_size_qst,4'b0} +
                                {2'b0,vpg_pkt_size_qst,3'b0};
          end
          default:begin
              // spyglass disable_block UnloadedNet-ML
              // SMD: Unloaded but driven net detected in the design
              // SJ: Some bits of the signal may not be needed in different configurations
              // spyglass disable_block checkNetReceiver
              // SMD: Each internal net must have at least one receiver.
              // SJ: Some bits of the signal may not be needed in different configurations.
              vpg_pkt_bits = 19'b0;
              // spyglass enable_block checkNetReceiver
              // spyglass enable_block UnloadedNet-ML
          end
      endcase
  end //vpg_pkt_bits_PROC

  //word count = one_packet_bits/8
  assign vpg_wc = vpg_pkt_bits[18:3];

  //Frame number
  //0: Frame Number Zero mode.
  //1: Frame Number Increments One mode
  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : frame_number_PROC
    if(~ppi_clkrstz)
        frame_number    <= 16'b0;
    else
        if(vpg_frame_num_mode_qst)
            if(vpg_en_re)
                frame_number    <= 16'b1;
            else
                if(fe_req_ack)
                    if(frame_number == vpg_max_frame_num_qst)
                        frame_number    <= 16'b1;
                    else
                    // spyglass disable_block W484
                    // SMD: Possible assignment overflow.
                    // SJ: Overflow can't occur. Protected by protocol.
                        frame_number    <= frame_number + 16'b1;
                    // spyglass enable_block W484
                else
                    frame_number    <= frame_number;
        else
            frame_number    <= 16'b0;
  end //frame_number_PROC

  //Line number
  //00: Line Number Zero mode.
  //01: Line Number Increments One mode
  //10: Line Number Increments Arbitrary Value mode
  //11: Reserved
  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : line_number_PROC
    if(~ppi_clkrstz)
        line_number    <= 16'b0;
    else
        case(vpg_line_num_mode_qst)
            2'b01:begin
                if(fs_req_ack|vpg_en_re)
                    line_number    <= 16'b1;
                else
                    if(le_req_ack)
                    // spyglass disable_block W484
                    // SMD: Possible assignment overflow.
                    // SJ: Overflow can't occur. Protected by protocol.
                        line_number    <= line_number + 16'b1;
                    // spyglass enable_block W484
                    else
                        line_number    <= line_number;
            end
            2'b10:begin
                if(fs_req_ack|vpg_en_re)
                    line_number    <= vpg_start_line_num_qst;
                else
                    if(le_req_ack)
                    // spyglass disable_block W484
                    // SMD: Possible assignment overflow.
                    // SJ: Overflow can't occur. Protected by protocol.
                    // spyglass disable_block W164a
                    // SMD: LHS width is less than RHS width of assignment.
                    // SJ: Overflow can't occur. Protected by protocol.
                        line_number    <= line_number + vpg_step_line_num_qst;
                    // spyglass enable_block W164a
                    // spyglass enable_block W484
                    else
                        line_number    <= line_number;
            end
            default:begin
                line_number    <= 16'b0;
            end
        endcase
  end //line_number_PROC

  //Header information generation
  assign req_ack_val = {vp_req_ack,fs_req_ack,fe_req_ack,ls_req_ack,le_req_ack};

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : header_gen_PROC
    if(~ppi_clkrstz) begin
      vpg_header_pre2  <= {`CSI2_DEVICE_HD_WIDTH{1'b0}};
    end else begin
        if(vpg_hdr_req_ack) begin
            vpg_header_pre2[`CSI2_DEVICE_HD_WIDTH-1:24] <= vpg_vcx_qst;
            case(req_ack_val)
                5'b00001:begin //Line End Packet
                    vpg_header_pre2[23:0] <= {line_number[15:0],vpg_vc_qst,`CSI2_LINE_END_CODE};
                end
                5'b00010:begin //Line Start Packet
                    vpg_header_pre2[23:0] <= {line_number[15:0],vpg_vc_qst,`CSI2_LINE_START_CODE};
                end
                5'b00100:begin //Frame EnPROCd Packet
                    vpg_header_pre2[23:0] <= {frame_number[15:0],vpg_vc_qst,`CSI2_FRAME_END_CODE};
                end
                5'b01000:begin //Frame Start Packet
                    vpg_header_pre2[23:0] <= {frame_number[15:0],vpg_vc_qst,`CSI2_FRAME_START_CODE};
                end
                default:begin //5'b10000 video pattern packet
                    vpg_header_pre2[23:0] <= {vpg_wc[15:0],vpg_vc_qst,vpg_dt_qst};
                end
            endcase
        end
    end
  end //header_gen_PROC

  ////////////////////////////////////////////////////////////////////////////////
  ////////////////////////// PIXEL ENCODING //////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////
  //The position of the previous seven color bar in vertical mode
  //1 * vertical_color_pixels
  //2 * vertical_color_pixels
  //3 * vertical_color_pixels
  //4 * vertical_color_pixels
  //5 * vertical_color_pixels
  //6 * vertical_color_pixels
  //7 * vertical_color_pixels
  assign vertical_color_pixels = vpg_pkt_size_qst[13:3];
  // spyglass disable_block FlopDataConstant
  // SMD: Flip-flop data pin driven by a constant value
  // SJ: Extra bits are added intentionally
  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : vertical_color_position_PROC
      if(~ppi_clkrstz) begin
          vertical_color1_position <= 14'b0;
          vertical_color2_position <= 14'b0;
          vertical_color3_position <= 14'b0;
          vertical_color4_position <= 14'b0;
          vertical_color5_position <= 14'b0;
          vertical_color6_position <= 14'b0;
          vertical_color7_position <= 14'b0;
      end else begin
          if(hsync_start)begin
              vertical_color1_position <= {3'b0,vertical_color_pixels};
              vertical_color2_position <= {2'b0,vertical_color_pixels,1'b0};
              vertical_color3_position <= {2'b0,vertical_color_pixels,1'b0} +
                                          {3'b0,vertical_color_pixels};
              vertical_color4_position <= {1'b0,vertical_color_pixels,2'b0};
              vertical_color5_position <= {1'b0,vertical_color_pixels,2'b0} +
                                          {3'b0,vertical_color_pixels};
              vertical_color6_position <= {1'b0,vertical_color_pixels,2'b0} +
                                          {2'b0,vertical_color_pixels,1'b0};
              // spyglass disable_block STARC05-2.10.6.6
              // SMD: The expression has more than one arithmetic operators
              // SJ: Better for code readability
              vertical_color7_position <= {1'b0,vertical_color_pixels,2'b0} +
                                          {2'b0,vertical_color_pixels,1'b0} +
                                          {3'b0,vertical_color_pixels};
              // spyglass enable_block STARC05-2.10.6.6
          end
      end
  end //vertical_color_position_PROC
  // spyglass enable_block FlopDataConstant

  //Calculate the number of each generated pixels based on data type and packet size and odd/even line
//  assign line_for_gen_pixels = vp_req_ack ? next_odd_line : odd_line;

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : gen_pixels_PROC
      if(~ppi_clkrstz)
          gen_pixels    <= 6'b0;
      else
      case(vpg_dt_qst)
          `CSI2_RAW6: begin
               if((next_gen_cnt == 4'd0) | (next_gen_cnt == 4'd1))
                   gen_pixels <= 6'd12;
               else
                   gen_pixels <= 6'd8;
          end
          `CSI2_RAW12,
          `CSI2_LY420_8B: begin
               if((next_gen_cnt == 4'd0) | (next_gen_cnt == 4'd1))
                   gen_pixels <= 6'd6;
               else
                   gen_pixels <= 6'd4;
          end
          `CSI2_RAW24,
          `CSI2_RGB888: begin
               if(next_gen_cnt == 4'd0)
                   gen_pixels <= 6'd4;
               else
                   gen_pixels <= 6'd2;
          end
          `CSI2_RAW8: begin
               gen_pixels <= 6'd8;
          end
          `CSI2_RAW16,
          `CSI2_RGB444,
          `CSI2_RGB555,
          `CSI2_RGB565,
          `CSI2_Y422_8B: begin
               gen_pixels <= 6'd4;
          end
          `CSI2_CSPS_Y420_8B,
          `CSI2_Y420_8B:begin
              if(odd_line)
                  gen_pixels <= 6'd8;
              else
                  gen_pixels <= 6'd4;
          end
          `CSI2_RAW10: begin
               if((next_gen_cnt == 4'd0) | (next_gen_cnt == 4'd1) | (next_gen_cnt == 4'd3))
                   gen_pixels <= 6'd8;
               else
                   gen_pixels <= 6'd4;
          end
          `CSI2_Y422_10B,
          `CSI2_RAW20: begin
               if((next_gen_cnt == 4'd0) | (next_gen_cnt == 4'd1) | (next_gen_cnt == 4'd3))
                   gen_pixels <= 6'd4;
               else
                   gen_pixels <= 6'd2;
          end
          `CSI2_CSPS_Y420_10B,
          `CSI2_Y420_10B:begin
              if(odd_line)
                  if((next_gen_cnt == 4'd0) | (next_gen_cnt == 4'd1) | (next_gen_cnt == 4'd3))
                      gen_pixels <= 6'd8;
                  else
                      gen_pixels <= 6'd4;
              else
                  if((next_gen_cnt == 4'd0) | (next_gen_cnt == 4'd1) | (next_gen_cnt == 4'd3))
                      gen_pixels <= 6'd4;
                  else
                      gen_pixels <= 6'd2;
          end
          `CSI2_RAW7: begin
               if(next_gen_cnt == 4'd0)
                   gen_pixels <= 6'd16;
               else
                   gen_pixels <= 6'd8;
          end
          `CSI2_RAW14: begin
               if(next_gen_cnt == 4'd0)
                   gen_pixels <= 6'd8;
               else
                   gen_pixels <= 6'd4;
          end
          `CSI2_RGB666:begin
               if((next_gen_cnt == 4'd4) | (next_gen_cnt == 4'd8))
                   gen_pixels <= 6'd2;
               else
                   gen_pixels <= 6'd4;
          end
          default:begin
          // spyglass disable_block FlopDataConstant
          // SMD: Flip-flop data pin driven by a constant value
          // SJ: Default value for this signal
              gen_pixels <= 6'd0;
          // spyglass enable_block FlopDataConstant
          end
      endcase
  end //gen_pixels_PROC

  //The bits of the video pattern has been sent
  //Every time send 128bits vpg_payload
  // spyglass disable_block W484
  // SMD: Possible assignment overflow.
  // SJ: Overflow can't occur. Protected by protocol.
  // spyglass disable_block W164a
  // SMD: LHS width is less than RHS width of assignment.
  // SJ: Overflow can't occur. Protected by protocol.
  assign sent_gen_pixels_sum = (sent_pixels + {8'b0,gen_pixels});
  // spyglass enable_block W164a
  // spyglass enable_block W484

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : sent_bits_PROC
      if(~ppi_clkrstz)
          sent_pixels    <= 14'b0;
      else
          if(vpg_pld_gen_end)
                sent_pixels    <= 14'b0;
          else
              if(vpg_pld_req_pre)
                sent_pixels    <= sent_gen_pixels_sum;
  end //sent_bits_PROC

  //The position of the previous seven color bar in horizontal mode
  //1 * horizontal_color_lines
  assign horizontal_color1_position = {3'b0,vpg_vactive_lines_qst[13:3]};

  //2 * horizontal_color_lines
  assign horizontal_color2_position = {2'b0,vpg_vactive_lines_qst[13:3],1'b0};

  //3 * horizontal_color_lines
  assign horizontal_color3_position = {2'b0,vpg_vactive_lines_qst[13:3],1'b0} +
                                      {3'b0,vpg_vactive_lines_qst[13:3]};

  //4 * horizontal_color_lines
  assign horizontal_color4_position = {1'b0,vpg_vactive_lines_qst[13:3],2'b0};

  //5 * horizontal_color_lines
  assign horizontal_color5_position = {1'b0,vpg_vactive_lines_qst[13:3],2'b0} +
                                      {3'b0,vpg_vactive_lines_qst[13:3]};

  //6 * horizontal_color_lines
  assign horizontal_color6_position = {1'b0,vpg_vactive_lines_qst[13:3],2'b0} +
                                      {2'b0,vpg_vactive_lines_qst[13:3],1'b0};

  //7 * horizontal_color_lines
  // spyglass disable_block STARC05-2.10.6.6
  // SMD: The expression has more than one arithmetic operators
  // SJ: Better for code readability
  assign horizontal_color7_position = {1'b0,vpg_vactive_lines_qst[13:3],2'b0} +
                                      {2'b0,vpg_vactive_lines_qst[13:3],1'b0} +
                                      {3'b0,vpg_vactive_lines_qst[13:3]};
  // spyglass enable_block STARC05-2.10.6.6

  //The zones of vpg_payload which is ready to be sent
  //In zone0/ zone2/ zone4/ zone6/ zone8/ zone10/ zone12/ zone14 the values of all the pixels are the same.
  //zone0/ zone2/ zone4/ zone6/ zone8/ zone10/ zone12/ zone14 are Respective for 8 kinds of color from left to right in video pattern.
  //In vertical mode or horizontal mode.
  assign vpg_orientation = vpg_mode_qst? 1'b0 : vpg_orientation_qst;

  assign data_in_zone0  = vpg_orientation ? (current_line <= horizontal_color1_position) :
                                            (sent_gen_pixels_sum <= vertical_color1_position);

  assign data_in_zone2  = vpg_orientation ? ((current_line <= horizontal_color2_position) & (current_line > horizontal_color1_position)) :
                                            ((sent_gen_pixels_sum <= vertical_color2_position) & (sent_pixels >= vertical_color1_position));

  assign data_in_zone4  = vpg_orientation ? ((current_line <= horizontal_color3_position) & (current_line > horizontal_color2_position)) :
                                            ((sent_gen_pixels_sum <= vertical_color3_position) & (sent_pixels >= vertical_color2_position));

  assign data_in_zone6  = vpg_orientation ? ((current_line <= horizontal_color4_position) & (current_line > horizontal_color3_position)) :
                                            ((sent_gen_pixels_sum <= vertical_color4_position) & (sent_pixels >= vertical_color3_position));

  assign data_in_zone8  = vpg_orientation ? ((current_line <= horizontal_color5_position) & (current_line > horizontal_color4_position)) :
                                            ((sent_gen_pixels_sum <= vertical_color5_position) & (sent_pixels >= vertical_color4_position));

  assign data_in_zone10 = vpg_orientation ? ((current_line <= horizontal_color6_position) & (current_line > horizontal_color5_position)) :
                                            ((sent_gen_pixels_sum <= vertical_color6_position) & (sent_pixels >= vertical_color5_position));

  assign data_in_zone12 = vpg_orientation ? ((current_line <= horizontal_color7_position) & (current_line > horizontal_color6_position)) :
                                            ((sent_gen_pixels_sum <= vertical_color7_position) & (sent_pixels >= vertical_color6_position));

  assign data_in_zone14 = vpg_orientation ? (current_line > horizontal_color7_position) :
                                            (sent_pixels >= vertical_color7_position);


  //In vertical mode, there are different values of pixels in zone1/ zone3/ zone5/ zone7/ zone9/ zone11/ zone13.
  //The zones of vpg_payload which is ready to be sent
  assign data_in_zone1  = (~vpg_orientation) & (sent_gen_pixels_sum > vertical_color1_position)&
                                               ( sent_pixels        < vertical_color1_position);
  assign data_in_zone3  = (~vpg_orientation) & (sent_gen_pixels_sum > vertical_color2_position)&
                                               ( sent_pixels        < vertical_color2_position);
  assign data_in_zone5  = (~vpg_orientation) & (sent_gen_pixels_sum > vertical_color3_position)&
                                               ( sent_pixels        < vertical_color3_position);
  assign data_in_zone7  = (~vpg_orientation) & (sent_gen_pixels_sum > vertical_color4_position)&
                                               ( sent_pixels        < vertical_color4_position);
  assign data_in_zone9  = (~vpg_orientation) & (sent_gen_pixels_sum > vertical_color5_position)&
                                               ( sent_pixels        < vertical_color5_position);
  assign data_in_zone11 = (~vpg_orientation) & (sent_gen_pixels_sum > vertical_color6_position)&
                                               ( sent_pixels        < vertical_color6_position);
  assign data_in_zone13 = (~vpg_orientation) & (sent_gen_pixels_sum > vertical_color7_position)&
                                               ( sent_pixels        < vertical_color7_position);
  //In zone0/ zone2/ zone4/ zone6/ zone8/ zone10/ zone12/ zone14 the values of all the pixels are the same, so the color mode is color_x.
  //To detect color mode in  zone1/ zone3/ zone5/ zone7/ zone9/ zone11/ zone13
  //To detect whether there is color_x_y in the generated pixels which is ready to be sent
  // spyglass disable_block W484
  // SMD: Possible assignment overflow.
  // SJ: Overflow can't occur. Protected by protocol.
  // spyglass disable_block W164a
  // SMD: LHS width is less than RHS width of assignment.
  // SJ: Overflow can't occur. Protected by protocol.
  assign vcolor1_pos_sent_pix_sub = (vertical_color1_position - sent_pixels );
  assign vcolor2_pos_sent_pix_sub = (vertical_color2_position - sent_pixels );
  assign vcolor3_pos_sent_pix_sub = (vertical_color3_position - sent_pixels );
  assign vcolor4_pos_sent_pix_sub = (vertical_color4_position - sent_pixels );
  assign vcolor5_pos_sent_pix_sub = (vertical_color5_position - sent_pixels );
  assign vcolor6_pos_sent_pix_sub = (vertical_color6_position - sent_pixels );
  assign vcolor7_pos_sent_pix_sub = (vertical_color7_position - sent_pixels );
  // spyglass enable_block W164a
  // spyglass enable_block W484

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : color_x_y_PROC
      if(~ppi_clkrstz)
         color_x_y <= 1'b0;
//      else if(vpg_payload_gen_en_pre)
      else if(vpg_pld_req_pre)
         color_x_y <=  ((vcolor1_pos_sent_pix_sub == 14'd1 ) & data_in_zone1 ) |
                       ((vcolor3_pos_sent_pix_sub == 14'd1 ) & data_in_zone5 ) |
                       ((vcolor5_pos_sent_pix_sub == 14'd1 ) & data_in_zone9 ) |
                       ((vcolor7_pos_sent_pix_sub == 14'd1 ) & data_in_zone13) ;
  end
  //To detect whether there is color_2x_y in the generated pixels which is ready to be sent
  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : color_2x_y_PROC
      if(~ppi_clkrstz)
        color_2x_y  <= 1'b0;
      else if(vpg_pld_req_pre)
        color_2x_y  <=  ((vcolor1_pos_sent_pix_sub == 14'd2 ) & data_in_zone1 ) |
                        ((vcolor2_pos_sent_pix_sub == 14'd2 ) & data_in_zone3 ) |
                        ((vcolor3_pos_sent_pix_sub == 14'd2 ) & data_in_zone5 ) |
                        ((vcolor4_pos_sent_pix_sub == 14'd2 ) & data_in_zone7 ) |
                        ((vcolor5_pos_sent_pix_sub == 14'd2 ) & data_in_zone9 ) |
                        ((vcolor6_pos_sent_pix_sub == 14'd2 ) & data_in_zone11) |
                        ((vcolor7_pos_sent_pix_sub == 14'd2 ) & data_in_zone13) ;
  end
  //To detect whether there is color_3x_y in the generated pixels which is ready to be sent
  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : color_3x_y_PROC
      if(~ppi_clkrstz)
        color_3x_y  <= 1'b0;
      else if(vpg_pld_req_pre)
        color_3x_y  <=  ((vcolor1_pos_sent_pix_sub == 14'd3 ) & data_in_zone1 ) |
                        ((vcolor3_pos_sent_pix_sub == 14'd3 ) & data_in_zone5 ) |
                        ((vcolor5_pos_sent_pix_sub == 14'd3 ) & data_in_zone9 ) |
                        ((vcolor7_pos_sent_pix_sub == 14'd3 ) & data_in_zone13) ;
  end
  //To detect whether there is color_4x_y in the generated pixels which is ready to be sent
  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : color_4x_y_PROC
      if(~ppi_clkrstz)
        color_4x_y  <= 1'b0;
      else if(vpg_pld_req_pre)
        color_4x_y  <=  ((vcolor1_pos_sent_pix_sub == 14'd4 ) & data_in_zone1 ) |
                        ((vcolor2_pos_sent_pix_sub == 14'd4 ) & data_in_zone3 ) |
                        ((vcolor3_pos_sent_pix_sub == 14'd4 ) & data_in_zone5 ) |
                        ((vcolor4_pos_sent_pix_sub == 14'd4 ) & data_in_zone7 ) |
                        ((vcolor5_pos_sent_pix_sub == 14'd4 ) & data_in_zone9 ) |
                        ((vcolor6_pos_sent_pix_sub == 14'd4 ) & data_in_zone11) |
                        ((vcolor7_pos_sent_pix_sub == 14'd4 ) & data_in_zone13) ;
  end
  //To detect whether there is color_5x_y in the generated pixels which is ready to be sent
  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : color_5x_y_PROC
      if(~ppi_clkrstz)
        color_5x_y  <= 1'b0;
      else if(vpg_pld_req_pre)
        color_5x_y  <=  ((vcolor1_pos_sent_pix_sub == 14'd5 ) & data_in_zone1 ) |
                        ((vcolor3_pos_sent_pix_sub == 14'd5 ) & data_in_zone5 ) |
                        ((vcolor5_pos_sent_pix_sub == 14'd5 ) & data_in_zone9 ) |
                        ((vcolor7_pos_sent_pix_sub == 14'd5 ) & data_in_zone13) ;
  end
  //To detect whether there is color_6x_y in the generated pixels which is ready to be sent
  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : color_6x_y_PROC
      if(~ppi_clkrstz)
        color_6x_y  <= 1'b0;
      else if(vpg_pld_req_pre)
        color_6x_y  <=  ((vcolor1_pos_sent_pix_sub == 14'd6 ) & data_in_zone1 ) |
                        ((vcolor2_pos_sent_pix_sub == 14'd6 ) & data_in_zone3 ) |
                        ((vcolor3_pos_sent_pix_sub == 14'd6 ) & data_in_zone5 ) |
                        ((vcolor4_pos_sent_pix_sub == 14'd6 ) & data_in_zone7 ) |
                        ((vcolor5_pos_sent_pix_sub == 14'd6 ) & data_in_zone9 ) |
                        ((vcolor6_pos_sent_pix_sub == 14'd6 ) & data_in_zone11) |
                        ((vcolor7_pos_sent_pix_sub == 14'd6 ) & data_in_zone13) ;
  end
  //To detect whether there is color_7x_y in the generated pixels which is ready to be sent
  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : color_7x_y_PROC
      if(~ppi_clkrstz)
        color_7x_y  <= 1'b0;
      else if(vpg_pld_req_pre)
        color_7x_y  <=  ((vcolor1_pos_sent_pix_sub == 14'd7 ) & data_in_zone1 ) |
                        ((vcolor3_pos_sent_pix_sub == 14'd7 ) & data_in_zone5 ) |
                        ((vcolor5_pos_sent_pix_sub == 14'd7 ) & data_in_zone9 ) |
                        ((vcolor7_pos_sent_pix_sub == 14'd7 ) & data_in_zone13) ;
  end
  //To detect whether there is color_8x_y in the generated pixels which is ready to be sent
  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : color_8x_y_PROC
      if(~ppi_clkrstz)
        color_8x_y  <= 1'b0;
      else if(vpg_pld_req_pre)
        color_8x_y  <=  ((vcolor1_pos_sent_pix_sub == 14'd8 ) & data_in_zone1 ) |
                        ((vcolor2_pos_sent_pix_sub == 14'd8 ) & data_in_zone3 ) |
                        ((vcolor3_pos_sent_pix_sub == 14'd8 ) & data_in_zone5 ) |
                        ((vcolor4_pos_sent_pix_sub == 14'd8 ) & data_in_zone7 ) |
                        ((vcolor5_pos_sent_pix_sub == 14'd8 ) & data_in_zone9 ) |
                        ((vcolor6_pos_sent_pix_sub == 14'd8 ) & data_in_zone11) |
                        ((vcolor7_pos_sent_pix_sub == 14'd8 ) & data_in_zone13) ;
  end
  //To detect whether there is color_9x_y in the generated pixels which is ready to be sent
  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : color_9x_y_PROC
      if(~ppi_clkrstz)
        color_9x_y  <= 1'b0;
      else if(vpg_pld_req_pre)
        color_9x_y  <=  ((vcolor1_pos_sent_pix_sub == 14'd9 ) & data_in_zone1 ) |
                        ((vcolor3_pos_sent_pix_sub == 14'd9 ) & data_in_zone5 ) |
                        ((vcolor5_pos_sent_pix_sub == 14'd9 ) & data_in_zone9 ) |
                        ((vcolor7_pos_sent_pix_sub == 14'd9 ) & data_in_zone13) ;
  end
  //To detect whether there is color_10x_y in the generated pixels which is ready to be sent
  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : color_10x_y_PROC
      if(~ppi_clkrstz)
        color_10x_y  <= 1'b0;
      else if(vpg_pld_req_pre)
        color_10x_y  <=  ((vcolor1_pos_sent_pix_sub == 14'd10 ) & data_in_zone1 ) |
                         ((vcolor2_pos_sent_pix_sub == 14'd10 ) & data_in_zone3 ) |
                         ((vcolor3_pos_sent_pix_sub == 14'd10 ) & data_in_zone5 ) |
                         ((vcolor4_pos_sent_pix_sub == 14'd10 ) & data_in_zone7 ) |
                         ((vcolor5_pos_sent_pix_sub == 14'd10 ) & data_in_zone9 ) |
                         ((vcolor6_pos_sent_pix_sub == 14'd10 ) & data_in_zone11) |
                         ((vcolor7_pos_sent_pix_sub == 14'd10 ) & data_in_zone13) ;
  end
  //To detect whether there is color_11x_y in the generated pixels which is ready to be sent
  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : color_11x_y_PROC
      if(~ppi_clkrstz)
        color_11x_y  <= 1'b0;
      else if(vpg_pld_req_pre)
        color_11x_y  <=  ((vcolor1_pos_sent_pix_sub == 14'd11 ) & data_in_zone1 ) |
                         ((vcolor3_pos_sent_pix_sub == 14'd11 ) & data_in_zone5 ) |
                         ((vcolor5_pos_sent_pix_sub == 14'd11 ) & data_in_zone9 ) |
                         ((vcolor7_pos_sent_pix_sub == 14'd11 ) & data_in_zone13) ;
  end
  //To detect whether there is color_12x_y in the generated pixels which is ready to be sent
  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : color_12x_y_PROC
      if(~ppi_clkrstz)
        color_12x_y  <= 1'b0;
      else if(vpg_pld_req_pre)
        color_12x_y  <=  ((vcolor1_pos_sent_pix_sub == 14'd12 ) & data_in_zone1 ) |
                         ((vcolor2_pos_sent_pix_sub == 14'd12 ) & data_in_zone3 ) |
                         ((vcolor3_pos_sent_pix_sub == 14'd12 ) & data_in_zone5 ) |
                         ((vcolor4_pos_sent_pix_sub == 14'd12 ) & data_in_zone7 ) |
                         ((vcolor5_pos_sent_pix_sub == 14'd12 ) & data_in_zone9 ) |
                         ((vcolor6_pos_sent_pix_sub == 14'd12 ) & data_in_zone11) |
                         ((vcolor7_pos_sent_pix_sub == 14'd12 ) & data_in_zone13) ;
  end
  //To detect whether there is color_13x_y in the generated pixels which is ready to be sent
  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : color_13x_y_PROC
      if(~ppi_clkrstz)
        color_13x_y  <= 1'b0;
      else if(vpg_pld_req_pre)
        color_13x_y  <=  ((vcolor1_pos_sent_pix_sub == 14'd13 ) & data_in_zone1 ) |
                         ((vcolor3_pos_sent_pix_sub == 14'd13 ) & data_in_zone5 ) |
                         ((vcolor5_pos_sent_pix_sub == 14'd13 ) & data_in_zone9 ) |
                         ((vcolor7_pos_sent_pix_sub == 14'd13 ) & data_in_zone13) ;
  end
  //To detect whether there is color_14x_y in the generated pixels which is ready to be sent
  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : color_14x_y_PROC
      if(~ppi_clkrstz)
        color_14x_y  <= 1'b0;
      else if(vpg_pld_req_pre)
        color_14x_y  <=  ((vcolor1_pos_sent_pix_sub == 14'd14 ) & data_in_zone1 ) |
                         ((vcolor2_pos_sent_pix_sub == 14'd14 ) & data_in_zone3 ) |
                         ((vcolor3_pos_sent_pix_sub == 14'd14 ) & data_in_zone5 ) |
                         ((vcolor4_pos_sent_pix_sub == 14'd14 ) & data_in_zone7 ) |
                         ((vcolor5_pos_sent_pix_sub == 14'd14 ) & data_in_zone9 ) |
                         ((vcolor6_pos_sent_pix_sub == 14'd14 ) & data_in_zone11) |
                         ((vcolor7_pos_sent_pix_sub == 14'd14 ) & data_in_zone13) ;
  end
  //To detect whether there is color_15x_y in the generated pixels which is ready to be sent
  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : color_15x_y_PROC
      if(~ppi_clkrstz)
        color_15x_y  <= 1'b0;
      else if(vpg_pld_req_pre)
        color_15x_y  <=  ((vcolor1_pos_sent_pix_sub == 14'd15 ) & data_in_zone1 ) |
                         ((vcolor3_pos_sent_pix_sub == 14'd15 ) & data_in_zone5 ) |
                         ((vcolor5_pos_sent_pix_sub == 14'd15 ) & data_in_zone9 ) |
                         ((vcolor7_pos_sent_pix_sub == 14'd15 ) & data_in_zone13) ;
  end
  ////////////////////////////////////////////////////////////////////////////////
  ////////////////////////// Color Components ////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////
  //using different components in different data type and different lines
  //Supprot that swap_bayer is 2'b00 for RAW format
  //The p_color1 is used for the first color
  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : odd_line_p_color1_PROC
      if(~ppi_clkrstz)
        odd_line_p_color1  <= 30'b0;
      else
      case(vpg_dt_qst)
          `CSI2_RAW24,
          `CSI2_RAW20,
          `CSI2_RAW16:begin
              odd_line_p_color1[29:0] <= {WHITE[27],WHITE[27:14],WHITE[13],WHITE[13:0]};  //gb
          end
          `CSI2_RAW6,
          `CSI2_RAW7,
          `CSI2_RAW10,
          `CSI2_RAW12,
          `CSI2_RAW14:begin
              odd_line_p_color1[29:0] <= {WHITE[27:14],1'b0,WHITE[13:0],1'b0};  //gb
          end
          `CSI2_RAW8:begin
              if(vpg_mode_qst) //BER video
                  odd_line_p_color1[29:0] <= {BER_COLOR1_COMPONENT,7'b0,BER_COLOR1_COMPONENT,7'b0};
              else
                  odd_line_p_color1[29:0] <= {WHITE[27:14],1'b0,WHITE[13:0],1'b0};  //gb
          end
          `CSI2_RGB444:begin
              odd_line_p_color1[29:0] <= {WHITE[41:38],6'b100000,WHITE[27:24],6'b100000,WHITE[13:10],6'b100000};//rgb
          end
          `CSI2_RGB555:begin
              odd_line_p_color1[29:0] <= {WHITE[41:37],5'b0,WHITE[27:23],5'b0,WHITE[13:9],5'b0};//rgb
          end
          `CSI2_RGB565,
          `CSI2_RGB666:begin
              odd_line_p_color1[29:0] <= {WHITE[41:36],4'b0,WHITE[27:22],4'b0,WHITE[13:8],4'b0};//rgb
          end
          `CSI2_RGB888:begin
              if(vpg_mode_qst) //BER video
                  odd_line_p_color1[29:0] <= {BER_COLOR1_COMPONENT,2'b0,BER_COLOR1_COMPONENT,2'b0,BER_COLOR1_COMPONENT,2'b0};//rgb
              else
                  odd_line_p_color1[29:0] <= {WHITE[41:34],2'b0,WHITE[27:20],2'b0,WHITE[13:6],2'b0};//rgb
          end
          `CSI2_Y422_8B,
          `CSI2_Y422_10B:begin
              odd_line_p_color1[29:0] <= YUV_WHITE;//YUV
          end
          `CSI2_LY420_8B:begin
              odd_line_p_color1[29:0] <= {YUV_WHITE[29:20],5'b0,YUV_WHITE[19:10],5'b0};//YU
          end
          `CSI2_Y420_8B,
          `CSI2_Y420_10B,
          `CSI2_CSPS_Y420_8B,
          `CSI2_CSPS_Y420_10B:begin
              odd_line_p_color1[29:0] <= {YUV_WHITE[29:20],20'b0};//Y
          end
          default:begin
          // spyglass disable_block FlopDataConstant
          // SMD: Flip-flop data pin driven by a constant value
          // SJ: Default value for this signal
              odd_line_p_color1 <= 30'b0;
          // spyglass enable_block FlopDataConstant
          end
      endcase
  end //odd_line_p_color1_PROC

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : even_line_p_color1_PROC
      if(~ppi_clkrstz)
        even_line_p_color1  <= 30'b0;
      else
      case(vpg_dt_qst)
          `CSI2_RAW24,
          `CSI2_RAW20,
          `CSI2_RAW16:begin
              even_line_p_color1[29:0] <= {WHITE[41],WHITE[41:28],WHITE[27],WHITE[27:14]};  //rg
          end
          `CSI2_RAW6,
          `CSI2_RAW7,
          `CSI2_RAW10,
          `CSI2_RAW12,
          `CSI2_RAW14:begin
              even_line_p_color1[29:0] <= {WHITE[41:28],1'b0,WHITE[27:14],1'b0}; //rg
          end
          `CSI2_RAW8:begin
              if(vpg_mode_qst) //BER video
                  even_line_p_color1[29:0] <= {BER_COLOR1_COMPONENT,7'b0,BER_COLOR1_COMPONENT,7'b0};
              else
                  even_line_p_color1[29:0] <= {WHITE[41:28],1'b0,WHITE[27:14],1'b0}; //rg
          end
          `CSI2_RGB444:begin
              even_line_p_color1[29:0] <= {WHITE[41:38],6'b100000,WHITE[27:24],6'b100000,WHITE[13:10],6'b100000};//rgb
          end
          `CSI2_RGB555:begin
              even_line_p_color1[29:0] <= {WHITE[41:37],5'b0,WHITE[27:23],5'b0,WHITE[13:9],5'b0};//rgb
          end
          `CSI2_RGB565,
          `CSI2_RGB666:begin
              even_line_p_color1[29:0] <= {WHITE[41:36],4'b0,WHITE[27:22],4'b0,WHITE[13:8],4'b0};//rgb
          end
          `CSI2_RGB888:begin
              if(vpg_mode_qst) //BER video
                  even_line_p_color1[29:0] <= {BER_COLOR1_COMPONENT,2'b0,BER_COLOR1_COMPONENT,2'b0,BER_COLOR1_COMPONENT,2'b0};//rgb
              else
                  even_line_p_color1[29:0] <= {WHITE[41:34],2'b0,WHITE[27:20],2'b0,WHITE[13:6],2'b0};//rgb
          end
          `CSI2_Y422_8B,
          `CSI2_Y422_10B:begin
              even_line_p_color1[29:0] <= YUV_WHITE;//YUV
          end
          `CSI2_LY420_8B:begin
              even_line_p_color1[29:0] <= {YUV_WHITE[29:20],5'b0,YUV_WHITE[9:0],5'b0};  //YV
          end
          `CSI2_Y420_8B,
          `CSI2_Y420_10B,
          `CSI2_CSPS_Y420_8B,
          `CSI2_CSPS_Y420_10B:begin
              even_line_p_color1[29:0] <= YUV_WHITE;  //YUV
          end
          default:begin
          // spyglass disable_block FlopDataConstant
          // SMD: Flip-flop data pin driven by a constant value
          // SJ: Default value for this signal
              even_line_p_color1 <= 30'b0;
          // spyglass enable_block FlopDataConstant
          end
      endcase
  end //even_line_p_color1_PROC

  assign p_color1 = odd_line ? odd_line_p_color1 : even_line_p_color1;

  //The p_color2 is used for the second color
  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : odd_line_p_color2_PROC
      if(~ppi_clkrstz)
        odd_line_p_color2  <= 30'b0;
      else
      case(vpg_dt_qst)
          `CSI2_RAW24,
          `CSI2_RAW20,
          `CSI2_RAW16:begin
              odd_line_p_color2[29:0] <= {YELLOW[27],YELLOW[27:14],YELLOW[13],YELLOW[13:0]};  //gb
          end
          `CSI2_RAW6,
          `CSI2_RAW7,
          `CSI2_RAW10,
          `CSI2_RAW12,
          `CSI2_RAW14:begin
              odd_line_p_color2[29:0] <= {YELLOW[27:14],1'b0,YELLOW[13:0],1'b0};  //gb
          end
          `CSI2_RAW8:begin
              if(vpg_mode_qst) //BER video
                  odd_line_p_color2[29:0] <= {BER_COLOR2_COMPONENT,7'b0,BER_COLOR2_COMPONENT,7'b0};
              else
                  odd_line_p_color2[29:0] <= {YELLOW[27:14],1'b0,YELLOW[13:0],1'b0};  //gb
          end
          `CSI2_RGB444:begin
              odd_line_p_color2[29:0] <= {YELLOW[41:38],6'b100000,YELLOW[27:24],6'b100000,YELLOW[13:10],6'b100000};//rgb
          end
          `CSI2_RGB555:begin
              odd_line_p_color2[29:0] <= {YELLOW[41:37],5'b0,YELLOW[27:23],5'b0,YELLOW[13:9],5'b0};//rgb
          end
          `CSI2_RGB565,
          `CSI2_RGB666:begin
              odd_line_p_color2[29:0] <= {YELLOW[41:36],4'b0,YELLOW[27:22],4'b0,YELLOW[13:8],4'b0};//rgb
          end
          `CSI2_RGB888:begin
              if(vpg_mode_qst) //BER video
                  odd_line_p_color2[29:0] <= {BER_COLOR2_COMPONENT,2'b0,BER_COLOR2_COMPONENT,2'b0,BER_COLOR2_COMPONENT,2'b0};//rgb
              else
                  odd_line_p_color2[29:0] <= {YELLOW[41:34],2'b0,YELLOW[27:20],2'b0,YELLOW[13:6],2'b0};//rgb
          end
          `CSI2_Y422_8B,
          `CSI2_Y422_10B:begin
              odd_line_p_color2[29:0] <= YUV_YELLOW;//YUV
          end
          `CSI2_LY420_8B:begin
              odd_line_p_color2[29:0] <= {YUV_YELLOW[29:20],5'b0,YUV_YELLOW[19:10],5'b0};//YU
          end
          `CSI2_Y420_8B,
          `CSI2_Y420_10B,
          `CSI2_CSPS_Y420_8B,
          `CSI2_CSPS_Y420_10B:begin
              odd_line_p_color2[29:0] <= {YUV_YELLOW[29:20],20'b0};//Y
          end
          default:begin
          // spyglass disable_block FlopDataConstant
          // SMD: Flip-flop data pin driven by a constant value
          // SJ: Default value for this signal
              odd_line_p_color2 <= 30'b0;
          // spyglass enable_block FlopDataConstant
          end
      endcase
  end //odd_line_p_color2_PROC

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : even_line_p_color2_PROC
      if(~ppi_clkrstz)
        even_line_p_color2  <= 30'b0;
      else
      case(vpg_dt_qst)
          `CSI2_RAW24,
          `CSI2_RAW20,
          `CSI2_RAW16:begin
              even_line_p_color2[29:0] <= {YELLOW[41],YELLOW[41:28],YELLOW[27],YELLOW[27:14]};  //rg
          end
          `CSI2_RAW6,
          `CSI2_RAW7,
          `CSI2_RAW10,
          `CSI2_RAW12,
          `CSI2_RAW14:begin
              even_line_p_color2[29:0] <= {YELLOW[41:28],1'b0,YELLOW[27:14],1'b0}; //rg
          end
          `CSI2_RAW8:begin
              if(vpg_mode_qst) //BER video
                  even_line_p_color2[29:0] <= {BER_COLOR2_COMPONENT,7'b0,BER_COLOR2_COMPONENT,7'b0};
              else
                  even_line_p_color2[29:0] <= {YELLOW[41:28],1'b0,YELLOW[27:14],1'b0}; //rg
          end
          `CSI2_RGB444:begin
              even_line_p_color2[29:0] <= {YELLOW[41:38],6'b100000,YELLOW[27:24],6'b100000,YELLOW[13:10],6'b100000};//rgb
          end
          `CSI2_RGB555:begin
              even_line_p_color2[29:0] <= {YELLOW[41:37],5'b0,YELLOW[27:23],5'b0,YELLOW[13:9],5'b0};//rgb
          end
          `CSI2_RGB565,
          `CSI2_RGB666:begin
              even_line_p_color2[29:0] <= {YELLOW[41:36],4'b0,YELLOW[27:22],4'b0,YELLOW[13:8],4'b0};//rgb
          end
          `CSI2_RGB888:begin
              if(vpg_mode_qst) //BER video
                  even_line_p_color2[29:0] <= {BER_COLOR2_COMPONENT,2'b0,BER_COLOR2_COMPONENT,2'b0,BER_COLOR2_COMPONENT,2'b0};//rgb
              else
                  even_line_p_color2[29:0] <= {YELLOW[41:34],2'b0,YELLOW[27:20],2'b0,YELLOW[13:6],2'b0};//rgb
          end
          `CSI2_Y422_8B,
          `CSI2_Y422_10B:begin
              even_line_p_color2[29:0] <= YUV_YELLOW;//YUV
          end
          `CSI2_LY420_8B:begin
              even_line_p_color2[29:0] <= {YUV_YELLOW[29:20],5'b0,YUV_YELLOW[9:0],5'b0};  //YV
          end
          `CSI2_Y420_8B,
          `CSI2_Y420_10B,
          `CSI2_CSPS_Y420_8B,
          `CSI2_CSPS_Y420_10B:begin
              even_line_p_color2[29:0] <= YUV_YELLOW;  //YUV
          end
          default:begin
          // spyglass disable_block FlopDataConstant
          // SMD: Flip-flop data pin driven by a constant value
          // SJ: Default value for this signal
              even_line_p_color2 <= 30'b0;
          // spyglass enable_block FlopDataConstant
          end
      endcase
  end //even_line_p_color2_PROC

  assign p_color2 = odd_line ? odd_line_p_color2 : even_line_p_color2;

  //The p_color3 is used for the third color
  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : odd_line_p_color3_PROC
      if(~ppi_clkrstz)
        odd_line_p_color3  <= 30'b0;
      else
      case(vpg_dt_qst)
          `CSI2_RAW24,
          `CSI2_RAW20,
          `CSI2_RAW16:begin
              odd_line_p_color3[29:0] <= {CYAN[27],CYAN[27:14],CYAN[13],CYAN[13:0]};  //gb
          end
          `CSI2_RAW6,
          `CSI2_RAW7,
          `CSI2_RAW10,
          `CSI2_RAW12,
          `CSI2_RAW14:begin
              odd_line_p_color3[29:0] <= {CYAN[27:14],1'b0,CYAN[13:0],1'b0};  //gb
          end
          `CSI2_RAW8:begin
              if(vpg_mode_qst) //BER video
                  odd_line_p_color3[29:0] <= {BER_COLOR3_COMPONENT,7'b0,BER_COLOR3_COMPONENT,7'b0};
              else
                  odd_line_p_color3[29:0] <= {CYAN[27:14],1'b0,CYAN[13:0],1'b0};  //gb
          end
          `CSI2_RGB444:begin
              odd_line_p_color3[29:0] <= {CYAN[41:38],6'b100000,CYAN[27:24],6'b100000,CYAN[13:10],6'b100000};//rgb
          end
          `CSI2_RGB555:begin
              odd_line_p_color3[29:0] <= {CYAN[41:37],5'b0,CYAN[27:23],5'b0,CYAN[13:9],5'b0};//rgb
          end
          `CSI2_RGB565,
          `CSI2_RGB666:begin
              odd_line_p_color3[29:0] <= {CYAN[41:36],4'b0,CYAN[27:22],4'b0,CYAN[13:8],4'b0};//rgb
          end
          `CSI2_RGB888:begin
              if(vpg_mode_qst)//BER video
                  odd_line_p_color3[29:0] <= {BER_COLOR3_COMPONENT,2'b0,BER_COLOR3_COMPONENT,2'b0,BER_COLOR3_COMPONENT,2'b0};//rgb
              else
                  odd_line_p_color3[29:0] <= {CYAN[41:34],2'b0,CYAN[27:20],2'b0,CYAN[13:6],2'b0};//rgb
          end
          `CSI2_Y422_8B,
          `CSI2_Y422_10B:begin
              odd_line_p_color3[29:0] <= YUV_CYAN;//YUV
          end
          `CSI2_LY420_8B:begin
              odd_line_p_color3[29:0] <= {YUV_CYAN[29:20],5'b0,YUV_CYAN[19:10],5'b0};//YU
          end
          `CSI2_Y420_8B,
          `CSI2_Y420_10B,
          `CSI2_CSPS_Y420_8B,
          `CSI2_CSPS_Y420_10B:begin
              odd_line_p_color3[29:0] <= {YUV_CYAN[29:20],20'b0};//Y
          end
          default:begin
          // spyglass disable_block FlopDataConstant
          // SMD: Flip-flop data pin driven by a constant value
          // SJ: Default value for this signal
              odd_line_p_color3 <= 30'b0;
          // spyglass enable_block FlopDataConstant
          end
      endcase
  end //odd_line_p_color3_PROC

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : even_line_p_color3_PROC
      if(~ppi_clkrstz)
        even_line_p_color3  <= 30'b0;
      else
      case(vpg_dt_qst)
          `CSI2_RAW24,
          `CSI2_RAW20,
          `CSI2_RAW16:begin
              even_line_p_color3[29:0] <= {CYAN[41],CYAN[41:28],CYAN[27],CYAN[27:14]};  //rg
          end
          `CSI2_RAW6,
          `CSI2_RAW7,
          `CSI2_RAW10,
          `CSI2_RAW12,
          `CSI2_RAW14:begin
              even_line_p_color3[29:0] <= {CYAN[41:28],1'b0,CYAN[27:14],1'b0}; //rg
          end
          `CSI2_RAW8:begin
              if(vpg_mode_qst) //BER video
                  even_line_p_color3[29:0] <= {BER_COLOR3_COMPONENT,7'b0,BER_COLOR3_COMPONENT,7'b0};
              else
                  even_line_p_color3[29:0] <= {CYAN[41:28],1'b0,CYAN[27:14],1'b0}; //rg
          end
          `CSI2_RGB444:begin
              even_line_p_color3[29:0] <= {CYAN[41:38],6'b100000,CYAN[27:24],6'b100000,CYAN[13:10],6'b100000};//rgb
          end
          `CSI2_RGB555:begin
              even_line_p_color3[29:0] <= {CYAN[41:37],5'b0,CYAN[27:23],5'b0,CYAN[13:9],5'b0};//rgb
          end
          `CSI2_RGB565,
          `CSI2_RGB666:begin
              even_line_p_color3[29:0] <= {CYAN[41:36],4'b0,CYAN[27:22],4'b0,CYAN[13:8],4'b0};//rgb
          end
          `CSI2_RGB888:begin
              if(vpg_mode_qst)//BER video
                  even_line_p_color3[29:0] <= {BER_COLOR3_COMPONENT,2'b0,BER_COLOR3_COMPONENT,2'b0,BER_COLOR3_COMPONENT,2'b0};//rgb
              else
                  even_line_p_color3[29:0] <= {CYAN[41:34],2'b0,CYAN[27:20],2'b0,CYAN[13:6],2'b0};//rgb
          end
          `CSI2_Y422_8B,
          `CSI2_Y422_10B:begin
              even_line_p_color3[29:0] <= YUV_CYAN;//YUV
          end
          `CSI2_LY420_8B:begin
              even_line_p_color3[29:0] <= {YUV_CYAN[29:20],5'b0,YUV_CYAN[9:0],5'b0};  //YV
          end
          `CSI2_Y420_8B,
          `CSI2_Y420_10B,
          `CSI2_CSPS_Y420_8B,
          `CSI2_CSPS_Y420_10B:begin
              even_line_p_color3[29:0] <= YUV_CYAN;  //YUV
          end
          default:begin
          // spyglass disable_block FlopDataConstant
          // SMD: Flip-flop data pin driven by a constant value
          // SJ: Default value for this signal
              even_line_p_color3 <= 30'b0;
          // spyglass enable_block FlopDataConstant
          end
      endcase
  end //even_line_p_color3_PROC

  assign p_color3 = odd_line ? odd_line_p_color3 : even_line_p_color3;

  //The p_color4 is used for the forth color
  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : odd_line_p_color4_PROC
      if(~ppi_clkrstz)
        odd_line_p_color4  <= 30'b0;
      else
      case(vpg_dt_qst)
          `CSI2_RAW24,
          `CSI2_RAW20,
          `CSI2_RAW16:begin
              odd_line_p_color4[29:0] <= {GREEN[27],GREEN[27:14],GREEN[13],GREEN[13:0]};  //gb
          end
          `CSI2_RAW6,
          `CSI2_RAW7,
          `CSI2_RAW10,
          `CSI2_RAW12,
          `CSI2_RAW14:begin
             odd_line_p_color4[29:0] <= {GREEN[27:14],1'b0,GREEN[13:0],1'b0};  //gb
          end
          `CSI2_RAW8:begin
              if(vpg_mode_qst) //BER video
                  odd_line_p_color4[29:0] <= {BER_COLOR4_COMPONENT,7'b0,BER_COLOR4_COMPONENT,7'b0};
              else
                  odd_line_p_color4[29:0] <= {GREEN[27:14],1'b0,GREEN[13:0],1'b0};  //gb
          end
          `CSI2_RGB444:begin
              odd_line_p_color4[29:0] <= {GREEN[41:38],6'b100000,GREEN[27:24],6'b100000,GREEN[13:10],6'b100000};//rgb
          end
          `CSI2_RGB555:begin
              odd_line_p_color4[29:0] <= {GREEN[41:37],5'b0,GREEN[27:23],5'b0,GREEN[13:9],5'b0};//rgb
          end
          `CSI2_RGB565,
          `CSI2_RGB666:begin
              odd_line_p_color4[29:0] <= {GREEN[41:36],4'b0,GREEN[27:22],4'b0,GREEN[13:8],4'b0};//rgb
          end
          `CSI2_RGB888:begin
              if(vpg_mode_qst) //BER video
                  odd_line_p_color4[29:0] <= {BER_COLOR4_COMPONENT,2'b0,BER_COLOR4_COMPONENT,2'b0,BER_COLOR4_COMPONENT,2'b0};//rgb
              else
                  odd_line_p_color4[29:0] <= {GREEN[41:34],2'b0,GREEN[27:20],2'b0,GREEN[13:6],2'b0};//rgb
          end
          `CSI2_Y422_8B,
          `CSI2_Y422_10B:begin
              odd_line_p_color4[29:0] <= YUV_GREEN;//YUV
          end
          `CSI2_LY420_8B:begin
              odd_line_p_color4[29:0] <= {YUV_GREEN[29:20],5'b0,YUV_GREEN[19:10],5'b0};//YU
          end
          `CSI2_Y420_8B,
          `CSI2_Y420_10B,
          `CSI2_CSPS_Y420_8B,
          `CSI2_CSPS_Y420_10B:begin
              odd_line_p_color4[29:0] <= {YUV_GREEN[29:20],20'b0};//Y
          end
          default:begin
          // spyglass disable_block FlopDataConstant
          // SMD: Flip-flop data pin driven by a constant value
          // SJ: Default value for this signal
              odd_line_p_color4 <= 30'b0;
          // spyglass enable_block FlopDataConstant
          end
      endcase
  end //odd_line_p_color4_PROC

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : even_line_p_color4_PROC
      if(~ppi_clkrstz)
        even_line_p_color4  <= 30'b0;
      else
      case(vpg_dt_qst)
          `CSI2_RAW24,
          `CSI2_RAW20,
          `CSI2_RAW16:begin
              even_line_p_color4[29:0] <= {GREEN[41],GREEN[41:28],GREEN[27],GREEN[27:14]};  //rg
          end
          `CSI2_RAW6,
          `CSI2_RAW7,
          `CSI2_RAW10,
          `CSI2_RAW12,
          `CSI2_RAW14:begin
             even_line_p_color4[29:0] <= {GREEN[41:28],1'b0,GREEN[27:14],1'b0}; //rg
          end
          `CSI2_RAW8:begin
              if(vpg_mode_qst) //BER video
                  even_line_p_color4[29:0] <= {BER_COLOR4_COMPONENT,7'b0,BER_COLOR4_COMPONENT,7'b0};
              else
                  even_line_p_color4[29:0] <= {GREEN[41:28],1'b0,GREEN[27:14],1'b0}; //rg
          end
          `CSI2_RGB444:begin
              even_line_p_color4[29:0] <= {GREEN[41:38],6'b100000,GREEN[27:24],6'b100000,GREEN[13:10],6'b100000};//rgb
          end
          `CSI2_RGB555:begin
              even_line_p_color4[29:0] <= {GREEN[41:37],5'b0,GREEN[27:23],5'b0,GREEN[13:9],5'b0};//rgb
          end
          `CSI2_RGB565,
          `CSI2_RGB666:begin
              even_line_p_color4[29:0] <= {GREEN[41:36],4'b0,GREEN[27:22],4'b0,GREEN[13:8],4'b0};//rgb
          end
          `CSI2_RGB888:begin
              if(vpg_mode_qst) //BER video
                  even_line_p_color4[29:0] <= {BER_COLOR4_COMPONENT,2'b0,BER_COLOR4_COMPONENT,2'b0,BER_COLOR4_COMPONENT,2'b0};//rgb
              else
                  even_line_p_color4[29:0] <= {GREEN[41:34],2'b0,GREEN[27:20],2'b0,GREEN[13:6],2'b0};//rgb
          end
          `CSI2_Y422_8B,
          `CSI2_Y422_10B:begin
              even_line_p_color4[29:0] <= YUV_GREEN;//YUV
          end
          `CSI2_LY420_8B:begin
              even_line_p_color4[29:0] <= {YUV_GREEN[29:20],5'b0,YUV_GREEN[9:0],5'b0};  //YV
          end
          `CSI2_Y420_8B,
          `CSI2_Y420_10B,
          `CSI2_CSPS_Y420_8B,
          `CSI2_CSPS_Y420_10B:begin
              even_line_p_color4[29:0] <= YUV_GREEN;  //YUV
          end
          default:begin
          // spyglass disable_block FlopDataConstant
          // SMD: Flip-flop data pin driven by a constant value
          // SJ: Default value for this signal
              even_line_p_color4 <= 30'b0;
          // spyglass enable_block FlopDataConstant
          end
      endcase
  end //even_line_p_color4_PROC

  assign p_color4 = odd_line ? odd_line_p_color4 : even_line_p_color4;

  //The p_color5 is used for the fifth color
  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : odd_line_p_color5_PROC
      if(~ppi_clkrstz)
        odd_line_p_color5  <= 30'b0;
      else
      case(vpg_dt_qst)
          `CSI2_RAW24,
          `CSI2_RAW20,
          `CSI2_RAW16:begin
              odd_line_p_color5[29:0] <= {MAGENTA[27],MAGENTA[27:14],MAGENTA[13],MAGENTA[13:0]};  //gb
          end
          `CSI2_RAW6,
          `CSI2_RAW7,
          `CSI2_RAW10,
          `CSI2_RAW12,
          `CSI2_RAW14:begin
              odd_line_p_color5[29:0] <= {MAGENTA[27:14],1'b0,MAGENTA[13:0],1'b0};  //gb
          end
          `CSI2_RAW8:begin
            if(vpg_mode_qst) //BER video
                odd_line_p_color5[29:0] <= {BER_COLOR5_COMPONENT,7'b0,BER_COLOR5_COMPONENT,7'b0};
            else
                odd_line_p_color5[29:0] <= {MAGENTA[27:14],1'b0,MAGENTA[13:0],1'b0};  //gb
          end
          `CSI2_RGB444:begin
              odd_line_p_color5[29:0] <= {MAGENTA[41:38],6'b100000,MAGENTA[27:24],6'b100000,MAGENTA[13:10],6'b100000};//rgb
          end
          `CSI2_RGB555:begin
              odd_line_p_color5[29:0] <= {MAGENTA[41:37],5'b0,MAGENTA[27:23],5'b0,MAGENTA[13:9],5'b0};//rgb
          end
          `CSI2_RGB565,
          `CSI2_RGB666:begin
              odd_line_p_color5[29:0] <= {MAGENTA[41:36],4'b0,MAGENTA[27:22],4'b0,MAGENTA[13:8],4'b0};//rgb
          end
          `CSI2_RGB888:begin
              if(vpg_mode_qst) //BER video
                  odd_line_p_color5[29:0] <= {BER_COLOR5_COMPONENT,2'b0,BER_COLOR5_COMPONENT,2'b0,BER_COLOR5_COMPONENT,2'b0};//rgb
              else
                  odd_line_p_color5[29:0] <= {MAGENTA[41:34],2'b0,MAGENTA[27:20],2'b0,MAGENTA[13:6],2'b0};//rgb
          end
          `CSI2_Y422_8B,
          `CSI2_Y422_10B:begin
              odd_line_p_color5[29:0] <= YUV_MAGENTA;//YUV
          end
          `CSI2_LY420_8B:begin
              odd_line_p_color5[29:0] <= {YUV_MAGENTA[29:20],5'b0,YUV_MAGENTA[19:10],5'b0};//YU
          end
          `CSI2_Y420_8B,
          `CSI2_Y420_10B,
          `CSI2_CSPS_Y420_8B,
          `CSI2_CSPS_Y420_10B:begin
              odd_line_p_color5[29:0] <= {YUV_MAGENTA[29:20],20'b0};//Y
          end
          default:begin
          // spyglass disable_block FlopDataConstant
          // SMD: Flip-flop data pin driven by a constant value
          // SJ: Default value for this signal
              odd_line_p_color5 <= 30'b0;
          // spyglass enable_block FlopDataConstant
          end
      endcase
  end //odd_line_p_color5_PROC

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : even_line_p_color5_PROC
      if(~ppi_clkrstz)
        even_line_p_color5  <= 30'b0;
      else
      case(vpg_dt_qst)
          `CSI2_RAW24,
          `CSI2_RAW20,
          `CSI2_RAW16:begin
              even_line_p_color5[29:0] <= {MAGENTA[41],MAGENTA[41:28],MAGENTA[27],MAGENTA[27:14]};  //rg
          end
          `CSI2_RAW6,
          `CSI2_RAW7,
          `CSI2_RAW10,
          `CSI2_RAW12,
          `CSI2_RAW14:begin
              even_line_p_color5[29:0] <= {MAGENTA[41:28],1'b0,MAGENTA[27:14],1'b0}; //rg
          end
          `CSI2_RAW8:begin
            if(vpg_mode_qst) //BER video
                even_line_p_color5[29:0] <= {BER_COLOR5_COMPONENT,7'b0,BER_COLOR5_COMPONENT,7'b0};
            else
                even_line_p_color5[29:0] <= {MAGENTA[41:28],1'b0,MAGENTA[27:14],1'b0}; //rg
          end
          `CSI2_RGB444:begin
              even_line_p_color5[29:0] <= {MAGENTA[41:38],6'b100000,MAGENTA[27:24],6'b100000,MAGENTA[13:10],6'b100000};//rgb
          end
          `CSI2_RGB555:begin
              even_line_p_color5[29:0] <= {MAGENTA[41:37],5'b0,MAGENTA[27:23],5'b0,MAGENTA[13:9],5'b0};//rgb
          end
          `CSI2_RGB565,
          `CSI2_RGB666:begin
              even_line_p_color5[29:0] <= {MAGENTA[41:36],4'b0,MAGENTA[27:22],4'b0,MAGENTA[13:8],4'b0};//rgb
          end
          `CSI2_RGB888:begin
              if(vpg_mode_qst) //BER video
                  even_line_p_color5[29:0] <= {BER_COLOR5_COMPONENT,2'b0,BER_COLOR5_COMPONENT,2'b0,BER_COLOR5_COMPONENT,2'b0};//rgb
              else
                  even_line_p_color5[29:0] <= {MAGENTA[41:34],2'b0,MAGENTA[27:20],2'b0,MAGENTA[13:6],2'b0};//rgb
          end
          `CSI2_Y422_8B,
          `CSI2_Y422_10B:begin
              even_line_p_color5[29:0] <= YUV_MAGENTA;//YUV
          end
          `CSI2_LY420_8B:begin
              even_line_p_color5[29:0] <= {YUV_MAGENTA[29:20],5'b0,YUV_MAGENTA[9:0],5'b0};  //YV
          end
          `CSI2_Y420_8B,
          `CSI2_Y420_10B,
          `CSI2_CSPS_Y420_8B,
          `CSI2_CSPS_Y420_10B:begin
              even_line_p_color5[29:0] <= YUV_MAGENTA;  //YUV
          end
          default:begin
          // spyglass disable_block FlopDataConstant
          // SMD: Flip-flop data pin driven by a constant value
          // SJ: Default value for this signal
              even_line_p_color5 <= 30'b0;
          // spyglass enable_block FlopDataConstant
          end
      endcase
  end //even_line_p_color5_PROC

  assign p_color5 = odd_line ? odd_line_p_color5 : even_line_p_color5;

  //The p_color6 is used for the sixth color
  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : odd_line_p_color6_PROC
      if(~ppi_clkrstz)
        odd_line_p_color6  <= 30'b0;
      else
      case(vpg_dt_qst)
          `CSI2_RAW24,
          `CSI2_RAW20,
          `CSI2_RAW16:begin
              odd_line_p_color6[29:0] <= {RED[27],RED[27:14],RED[13],RED[13:0]};  //gb
          end
          `CSI2_RAW6,
          `CSI2_RAW7,
          `CSI2_RAW10,
          `CSI2_RAW12,
          `CSI2_RAW14:begin
              odd_line_p_color6[29:0] <= {RED[27:14],1'b0,RED[13:0],1'b0};  //gb
          end
          `CSI2_RAW8:begin
              if(vpg_mode_qst) //BER video
                  odd_line_p_color6[29:0] <= {BER_COLOR6_COMPONENT,7'b0,BER_COLOR6_COMPONENT,7'b0};
              else
                  odd_line_p_color6[29:0] <= {RED[27:14],1'b0,RED[13:0],1'b0};  //gb
          end
          `CSI2_RGB444:begin
               odd_line_p_color6[29:0] <= {RED[41:38],6'b100000,RED[27:24],6'b100000,RED[13:10],6'b100000};//rgb
          end
          `CSI2_RGB555:begin
               odd_line_p_color6[29:0] <= {RED[41:37],5'b0,RED[27:23],5'b0,RED[13:9],5'b0};//rgb
          end
          `CSI2_RGB565,
          `CSI2_RGB666:begin
              odd_line_p_color6[29:0] <= {RED[41:36],4'b0,RED[27:22],4'b0,RED[13:8],4'b0};//rgb
          end
          `CSI2_RGB888:begin
              if(vpg_mode_qst) //BER video
                  odd_line_p_color6[29:0] <= {BER_COLOR6_COMPONENT,2'b0,BER_COLOR6_COMPONENT,2'b0,BER_COLOR6_COMPONENT,2'b0};//rgb
              else
                  odd_line_p_color6[29:0] <= {RED[41:34],2'b0,RED[27:20],2'b0,RED[13:6],2'b0};//rgb
          end
          `CSI2_Y422_8B,
          `CSI2_Y422_10B:begin
              odd_line_p_color6[29:0] <= YUV_RED;//YUV
          end
          `CSI2_LY420_8B:begin
              odd_line_p_color6[29:0] <= {YUV_RED[29:20],5'b0,YUV_RED[19:10],5'b0};//YU
          end
          `CSI2_Y420_8B,
          `CSI2_Y420_10B,
          `CSI2_CSPS_Y420_8B,
          `CSI2_CSPS_Y420_10B:begin
              odd_line_p_color6[29:0] <= {YUV_RED[29:20],20'b0};//Y
          end
          default:begin
          // spyglass disable_block FlopDataConstant
          // SMD: Flip-flop data pin driven by a constant value
          // SJ: Default value for this signal
              odd_line_p_color6 <= 30'b0;
          // spyglass enable_block FlopDataConstant
          end
      endcase
  end //odd_line_p_color6_PROC

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : even_line_p_color6_PROC
      if(~ppi_clkrstz)
        even_line_p_color6  <= 30'b0;
      else
      case(vpg_dt_qst)
          `CSI2_RAW24,
          `CSI2_RAW20,
          `CSI2_RAW16:begin
              even_line_p_color6[29:0] <= {RED[41],RED[41:28],RED[27],RED[27:14]};  //rg
          end
          `CSI2_RAW6,
          `CSI2_RAW7,
          `CSI2_RAW10,
          `CSI2_RAW12,
          `CSI2_RAW14:begin
              even_line_p_color6[29:0] <= {RED[41:28],1'b0,RED[27:14],1'b0}; //rg
          end
          `CSI2_RAW8:begin
              if(vpg_mode_qst) //BER video
                  even_line_p_color6[29:0] <= {BER_COLOR6_COMPONENT,7'b0,BER_COLOR6_COMPONENT,7'b0};
              else
                  even_line_p_color6[29:0] <= {RED[41:28],1'b0,RED[27:14],1'b0}; //rg
          end
          `CSI2_RGB444:begin
               even_line_p_color6[29:0] <= {RED[41:38],6'b100000,RED[27:24],6'b100000,RED[13:10],6'b100000};//rgb
          end
          `CSI2_RGB555:begin
               even_line_p_color6[29:0] <= {RED[41:37],5'b0,RED[27:23],5'b0,RED[13:9],5'b0};//rgb
          end
          `CSI2_RGB565,
          `CSI2_RGB666:begin
              even_line_p_color6[29:0] <= {RED[41:36],4'b0,RED[27:22],4'b0,RED[13:8],4'b0};//rgb
          end
          `CSI2_RGB888:begin
              if(vpg_mode_qst) //BER video
                  even_line_p_color6[29:0] <= {BER_COLOR6_COMPONENT,2'b0,BER_COLOR6_COMPONENT,2'b0,BER_COLOR6_COMPONENT,2'b0};//rgb
              else
                  even_line_p_color6[29:0] <= {RED[41:34],2'b0,RED[27:20],2'b0,RED[13:6],2'b0};//rgb
          end
          `CSI2_Y422_8B,
          `CSI2_Y422_10B:begin
              even_line_p_color6[29:0] <= YUV_RED;//YUV
          end
          `CSI2_LY420_8B:begin
              even_line_p_color6[29:0] <= {YUV_RED[29:20],5'b0,YUV_RED[9:0],5'b0};  //YV
          end
          `CSI2_Y420_8B,
          `CSI2_Y420_10B,
          `CSI2_CSPS_Y420_8B,
          `CSI2_CSPS_Y420_10B:begin
              even_line_p_color6[29:0] <= YUV_RED;  //YUV
          end
          default:begin
          // spyglass disable_block FlopDataConstant
          // SMD: Flip-flop data pin driven by a constant value
          // SJ: Default value for this signal
              even_line_p_color6 <= 30'b0;
          // spyglass enable_block FlopDataConstant
          end
      endcase
  end //even_line_p_color6_PROC

  assign p_color6 = odd_line ? odd_line_p_color6 : even_line_p_color6;

  //The p_color7 is used for the seventh color
  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : odd_line_p_color7_PROC
      if(~ppi_clkrstz)
        odd_line_p_color7  <= 30'b0;
      else
      case(vpg_dt_qst)
          `CSI2_RAW24,
          `CSI2_RAW20,
          `CSI2_RAW16:begin
              odd_line_p_color7[29:0] <= {BLUE[27],BLUE[27:14],BLUE[13],BLUE[13:0]};  //gb
          end
          `CSI2_RAW6,
          `CSI2_RAW7,
          `CSI2_RAW10,
          `CSI2_RAW12,
          `CSI2_RAW14:begin
              odd_line_p_color7[29:0] <= {BLUE[27:14],1'b0,BLUE[13:0],1'b0};  //gb
          end
          `CSI2_RAW8:begin
            if(vpg_mode_qst) //BER video
                odd_line_p_color7[29:0] <= {BER_COLOR7_COMPONENT,7'b0,BER_COLOR7_COMPONENT,7'b0};
            else
                odd_line_p_color7[29:0] <= {BLUE[27:14],1'b0,BLUE[13:0],1'b0};  //gb
          end
          `CSI2_RGB444:begin
               odd_line_p_color7[29:0] <= {BLUE[41:38],6'b100000,BLUE[27:24],6'b100000,BLUE[13:10],6'b100000};//rgb
          end
          `CSI2_RGB555:begin
               odd_line_p_color7[29:0] <= {BLUE[41:37],5'b0,BLUE[27:23],5'b0,BLUE[13:9],5'b0};//rgb
          end
          `CSI2_RGB565,
          `CSI2_RGB666:begin
              odd_line_p_color7[29:0] <= {BLUE[41:36],4'b0,BLUE[27:22],4'b0,BLUE[13:8],4'b0};//rgb
          end
          `CSI2_RGB888:begin
              if(vpg_mode_qst) //BER video
                  odd_line_p_color7[29:0] <= {BER_COLOR7_COMPONENT,2'b0,BER_COLOR7_COMPONENT,2'b0,BER_COLOR7_COMPONENT,2'b0};//rgb
              else
                  odd_line_p_color7[29:0] <= {BLUE[41:34],2'b0,BLUE[27:20],2'b0,BLUE[13:6],2'b0};//rgb
          end
          `CSI2_Y422_8B,
          `CSI2_Y422_10B:begin
              odd_line_p_color7[29:0] <= YUV_BLUE;//YUV
          end
          `CSI2_LY420_8B:begin
              odd_line_p_color7[29:0] <= {YUV_BLUE[29:20],5'b0,YUV_BLUE[19:10],5'b0};//YU
          end
          `CSI2_Y420_8B,
          `CSI2_Y420_10B,
          `CSI2_CSPS_Y420_8B,
          `CSI2_CSPS_Y420_10B:begin
              odd_line_p_color7[29:0] <= {YUV_BLUE[29:20],20'b0};//Y
          end
          default:begin
          // spyglass disable_block FlopDataConstant
          // SMD: Flip-flop data pin driven by a constant value
          // SJ: Default value for this signal
              odd_line_p_color7 <= 30'b0;
          // spyglass enable_block FlopDataConstant
          end
      endcase
  end //odd_line_p_color7_PROC

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : even_line_p_color7_PROC
      if(~ppi_clkrstz)
        even_line_p_color7  <= 30'b0;
      else
      case(vpg_dt_qst)
          `CSI2_RAW24,
          `CSI2_RAW20,
          `CSI2_RAW16:begin
              even_line_p_color7[29:0] <= {BLUE[41],BLUE[41:28],BLUE[27],BLUE[27:14]};  //rg
          end
          `CSI2_RAW6,
          `CSI2_RAW7,
          `CSI2_RAW10,
          `CSI2_RAW12,
          `CSI2_RAW14:begin
              even_line_p_color7[29:0] <= {BLUE[41:28],1'b0,BLUE[27:14],1'b0}; //rg
          end
          `CSI2_RAW8:begin
            if(vpg_mode_qst) //BER video
                even_line_p_color7[29:0] <= {BER_COLOR7_COMPONENT,7'b0,BER_COLOR7_COMPONENT,7'b0};
            else
                even_line_p_color7[29:0] <= {BLUE[41:28],1'b0,BLUE[27:14],1'b0}; //rg
          end
          `CSI2_RGB444:begin
               even_line_p_color7[29:0] <= {BLUE[41:38],6'b100000,BLUE[27:24],6'b100000,BLUE[13:10],6'b100000};//rgb
          end
          `CSI2_RGB555:begin
               even_line_p_color7[29:0] <= {BLUE[41:37],5'b0,BLUE[27:23],5'b0,BLUE[13:9],5'b0};//rgb
          end
          `CSI2_RGB565,
          `CSI2_RGB666:begin
              even_line_p_color7[29:0] <= {BLUE[41:36],4'b0,BLUE[27:22],4'b0,BLUE[13:8],4'b0};//rgb
          end
          `CSI2_RGB888:begin
              if(vpg_mode_qst) //BER video
                  even_line_p_color7[29:0] <= {BER_COLOR7_COMPONENT,2'b0,BER_COLOR7_COMPONENT,2'b0,BER_COLOR7_COMPONENT,2'b0};//rgb
              else
                  even_line_p_color7[29:0] <= {BLUE[41:34],2'b0,BLUE[27:20],2'b0,BLUE[13:6],2'b0};//rgb
          end
          `CSI2_Y422_8B,
          `CSI2_Y422_10B:begin
              even_line_p_color7[29:0] <= YUV_BLUE;//YUV
          end
          `CSI2_LY420_8B:begin
              even_line_p_color7[29:0] <= {YUV_BLUE[29:20],5'b0,YUV_BLUE[9:0],5'b0};  //YV
          end
          `CSI2_Y420_8B,
          `CSI2_Y420_10B,
          `CSI2_CSPS_Y420_8B,
          `CSI2_CSPS_Y420_10B:begin
              even_line_p_color7[29:0] <= YUV_BLUE;  //YUV
          end
          default:begin
          // spyglass disable_block FlopDataConstant
          // SMD: Flip-flop data pin driven by a constant value
          // SJ: Default value for this signal
              even_line_p_color7 <= 30'b0;
          // spyglass enable_block FlopDataConstant
          end
      endcase
  end //even_line_p_color7_PROC

  assign p_color7 = odd_line ? odd_line_p_color7 : even_line_p_color7;

  //The p_color8 is used for the eighth color
  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : odd_line_p_color8_PROC
      if(~ppi_clkrstz)
        odd_line_p_color8  <= 30'b0;
      else
      case(vpg_dt_qst)
          `CSI2_RAW24,
          `CSI2_RAW20,
          `CSI2_RAW16:begin
              odd_line_p_color8[29:0] <= {BLACK[27],BLACK[27:14],BLACK[13],BLACK[13:0]};  //gb
          end
          `CSI2_RAW6,
          `CSI2_RAW7,
          `CSI2_RAW10,
          `CSI2_RAW12,
          `CSI2_RAW14:begin
              odd_line_p_color8[29:0] <= {BLACK[27:14],1'b0,BLACK[13:0],1'b0};  //gb
          end
          `CSI2_RAW8:begin
              if(vpg_mode_qst) //BER video
                  odd_line_p_color8[29:0] <= {BER_COLOR8_COMPONENT,7'b0,BER_COLOR8_COMPONENT,7'b0};
              else
                  odd_line_p_color8[29:0] <= {BLACK[27:14],1'b0,BLACK[13:0],1'b0};  //gb
          end
          `CSI2_RGB444:begin
              odd_line_p_color8[29:0] <= {BLACK[41:38],6'b100000,BLACK[27:24],6'b100000,BLACK[13:10],6'b100000};//rgb
          end
          `CSI2_RGB555:begin
              odd_line_p_color8[29:0] <= {BLACK[41:37],5'b0,BLACK[27:23],5'b0,BLACK[13:9],5'b0};//rgb
          end
          `CSI2_RGB565,
          `CSI2_RGB666:begin
              odd_line_p_color8[29:0] <= {BLACK[41:36],4'b0,BLACK[27:22],4'b0,BLACK[13:8],4'b0};//rgb
          end
          `CSI2_RGB888:begin
              if(vpg_mode_qst) //BER video
                  odd_line_p_color8[29:0] <= {BER_COLOR8_COMPONENT,2'b0,BER_COLOR8_COMPONENT,2'b0,BER_COLOR8_COMPONENT,2'b0};//rgb
              else
                  odd_line_p_color8[29:0] <= {BLACK[41:34],2'b0,BLACK[27:20],2'b0,BLACK[13:6],2'b0};//rgb
          end
          `CSI2_Y422_8B,
          `CSI2_Y422_10B:begin
              odd_line_p_color8[29:0] <= YUV_BLACK;//YUV
          end
          `CSI2_LY420_8B:begin
              odd_line_p_color8[29:0] <= {YUV_BLACK[29:20],5'b0,YUV_BLACK[19:10],5'b0};//YU
          end
          `CSI2_Y420_8B,
          `CSI2_Y420_10B,
          `CSI2_CSPS_Y420_8B,
          `CSI2_CSPS_Y420_10B:begin
              odd_line_p_color8[29:0] <= {YUV_BLACK[29:20],20'b0};//Y
          end
          default:begin
          // spyglass disable_block FlopDataConstant
          // SMD: Flip-flop data pin driven by a constant value
          // SJ: Default value for this signal
              odd_line_p_color8 <= 30'b0;
          // spyglass enable_block FlopDataConstant
          end
      endcase
  end //odd_line_p_color8_PROC

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : even_line_p_color8_PROC
      if(~ppi_clkrstz)
        even_line_p_color8  <= 30'b0;
      else
      case(vpg_dt_qst)
          `CSI2_RAW24,
          `CSI2_RAW20,
          `CSI2_RAW16:begin
              even_line_p_color8[29:0] <= {BLACK[41],BLACK[41:28],BLACK[27],BLACK[27:14]};  //rg
          end
          `CSI2_RAW6,
          `CSI2_RAW7,
          `CSI2_RAW10,
          `CSI2_RAW12,
          `CSI2_RAW14:begin
              even_line_p_color8[29:0] <= {BLACK[41:28],1'b0,BLACK[27:14],1'b0}; //rg
          end
          `CSI2_RAW8:begin
              if(vpg_mode_qst) //BER video
                  even_line_p_color8[29:0] <= {BER_COLOR8_COMPONENT,7'b0,BER_COLOR8_COMPONENT,7'b0};
              else
                  even_line_p_color8[29:0] <= {BLACK[41:28],1'b0,BLACK[27:14],1'b0}; //rg
          end
          `CSI2_RGB444:begin
              even_line_p_color8[29:0] <= {BLACK[41:38],6'b100000,BLACK[27:24],6'b100000,BLACK[13:10],6'b100000};//rgb
          end
          `CSI2_RGB555:begin
              even_line_p_color8[29:0] <= {BLACK[41:37],5'b0,BLACK[27:23],5'b0,BLACK[13:9],5'b0};//rgb
          end
          `CSI2_RGB565,
          `CSI2_RGB666:begin
              even_line_p_color8[29:0] <= {BLACK[41:36],4'b0,BLACK[27:22],4'b0,BLACK[13:8],4'b0};//rgb
          end
          `CSI2_RGB888:begin
              if(vpg_mode_qst) //BER video
                  even_line_p_color8[29:0] <= {BER_COLOR8_COMPONENT,2'b0,BER_COLOR8_COMPONENT,2'b0,BER_COLOR8_COMPONENT,2'b0};//rgb
              else
                  even_line_p_color8[29:0] <= {BLACK[41:34],2'b0,BLACK[27:20],2'b0,BLACK[13:6],2'b0};//rgb
          end
          `CSI2_Y422_8B,
          `CSI2_Y422_10B:begin
              even_line_p_color8[29:0] <= YUV_BLACK;//YUV
          end
          `CSI2_LY420_8B:begin
              even_line_p_color8[29:0] <= {YUV_BLACK[29:20],5'b0,YUV_BLACK[9:0],5'b0};  //YV
          end
          `CSI2_Y420_8B,
          `CSI2_Y420_10B,
          `CSI2_CSPS_Y420_8B,
          `CSI2_CSPS_Y420_10B:begin
              even_line_p_color8[29:0] <= YUV_BLACK;  //YUV
          end
          default:begin
          // spyglass disable_block FlopDataConstant
          // SMD: Flip-flop data pin driven by a constant value
          // SJ: Default value for this signal
              even_line_p_color8 <= 30'b0;
          // spyglass enable_block FlopDataConstant
          end
      endcase
  end //even_line_p_color8_PROC

  assign p_color8 = odd_line ? odd_line_p_color8 : even_line_p_color8;

  ////////////////////////////////////////////////////////////////////////////////
  ////////////////////////// Pixel Bus Calculation ///////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////
  //The vpg_payload_color[i] is using to successively save the color in a vpg_payload.
  //There are up to eight different colors in a vpg_payload.
  //Calculation of the colors in a vpg_payload

  // In Zone0, all pixels belong to color1
  // In Zone2, all pixels belong to color2
  // In Zone4, all pixels belong to color3
  // In Zone6, all pixels belong to color4
  // In Zone8, all pixels belong to color5
  // In Zone10, all pixels belong to color6
  // In Zone12, all pixels belong to color7
  // In Zone14, all pixels belong to color8

  // The Zones in a vpg_payload                     vpg_payload_color[i] - the colors in a vpg_payload
  // Zone1 Zone3 Zone5 Zone7 Zone9 Zone11 Zone13     0      1      2      3      4      5      6      7
  //   1     0     0     0     0     0     0       Color1 Color2   x      x      x      x      x      x
  //   0     1     0     0     0     0     0       Color2 Color3   x      x      x      x      x      x
  //   0     0     1     0     0     0     0       Color3 Color4   x      x      x      x      x      x
  //   0     0     0     1     0     0     0       Color4 Color5   x      x      x      x      x      x
  //   0     0     0     0     1     0     0       Color5 Color6   x      x      x      x      x      x
  //   0     0     0     0     0     1     0       Color6 Color7   x      x      x      x      x      x
  //   0     0     0     0     0     0     1       Color7 Color8   x      x      x      x      x      x
  //   1     1     0     0     0     0     0       Color1 Color2 Color3   x      x      x      x      x
  //   0     1     1     0     0     0     0       Color2 Color3 Color4   x      x      x      x      x
  //   0     0     1     1     0     0     0       Color3 Color4 Color5   x      x      x      x      x
  //   0     0     0     1     1     0     0       Color4 Color5 Color6   x      x      x      x      x
  //   0     0     0     0     1     1     0       Color5 Color6 Color7   x      x      x      x      x
  //   0     0     0     0     0     1     1       Color6 Color7 Color8   x      x      x      x      x
  //   1     1     1     0     0     0     0       Color1 Color2 Color3 Color4   x      x      x      x
  //   0     1     1     1     0     0     0       Color2 Color3 Color4 Color5   x      x      x      x
  //   0     0     1     1     1     0     0       Color3 Color4 Color5 Color6   x      x      x      x
  //   0     0     0     1     1     1     0       Color4 Color5 Color6 Color7   x      x      x      x
  //   0     0     0     0     1     1     1       Color5 Color6 Color7 Color8   x      x      x      x
  //   1     1     1     1     0     0     0       Color1 Color2 Color3 Color4 Color5   x      x      x
  //   0     1     1     1     1     0     0       Color2 Color3 Color4 Color5 Color6   x      x      x
  //   0     0     1     1     1     1     0       Color3 Color4 Color5 Color6 Color7   x      x      x
  //   0     0     0     1     1     1     1       Color4 Color5 Color6 Color7 Color8   x      x      x
  //   1     1     1     1     1     0     0       Color1 Color2 Color3 Color4 Color5 Color6   x      x
  //   0     1     1     1     1     1     0       Color2 Color3 Color4 Color5 Color6 Color7   x      x
  //   0     0     1     1     1     1     1       Color3 Color4 Color5 Color6 Color7 Color8   x      x
  //   1     1     1     1     1     1     0       Color1 Color2 Color3 Color4 Color5 Color6 Color7   x
  //   0     1     1     1     1     1     1       Color2 Color3 Color4 Color5 Color6 Color7 Color8   x
  //   1     1     1     1     1     1     1       Color1 Color2 Color3 Color4 Color5 Color6 Color7 Color8

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : color_N_cal_PROC
      if(~ppi_clkrstz) begin
          color_0_cal <= 8'b0;
          color_1_cal <= 7'b0;
          color_2_cal <= 6'b0;
          color_3_cal <= 5'b0;
          color_4_cal <= 4'b0;
          color_5_cal <= 3'b0;
          color_6_cal <= 2'b0;
          color_7_cal <= 1'b0;
      end else if(vpg_pld_req_pre) begin
          color_0_cal <= color_0_cal_nxt;
          color_1_cal <= color_1_cal_nxt;
          color_2_cal <= color_2_cal_nxt;
          color_3_cal <= color_3_cal_nxt;
          color_4_cal <= color_4_cal_nxt;
          color_5_cal <= color_5_cal_nxt;
          color_6_cal <= color_6_cal_nxt;
          color_7_cal <= color_7_cal_nxt;
      end
  end //color_N_cal_PROC

  //The first color in a vpg_payload
  assign color_0_is_p_color1 =   data_in_zone0  | data_in_zone1  ;

  assign color_0_is_p_color2 =   data_in_zone2  | ((~data_in_zone1) &   data_in_zone3)  ;

  assign color_0_is_p_color3 =   data_in_zone4  | ((~data_in_zone3) &   data_in_zone5)  ;

  assign color_0_is_p_color4 =   data_in_zone6  | ((~data_in_zone5) &   data_in_zone7)  ;

  assign color_0_is_p_color5 =   data_in_zone8  | ((~data_in_zone7) &   data_in_zone9)  ;

  assign color_0_is_p_color6 =   data_in_zone10 | ((~data_in_zone9) &   data_in_zone11) ;

  assign color_0_is_p_color7 =   data_in_zone12 | ((~data_in_zone11)&   data_in_zone13) ;

  assign color_0_is_p_color8 =   data_in_zone14 ;

  assign color_0_cal_nxt = {color_0_is_p_color8,color_0_is_p_color7,color_0_is_p_color6,color_0_is_p_color5,
                            color_0_is_p_color4,color_0_is_p_color3,color_0_is_p_color2,color_0_is_p_color1};

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : vpg_payload_color_0_PROC
      if(~ppi_clkrstz)
          vpg_payload_color_0 <= 30'b0;
      else
      case(color_0_cal)
          8'b00000001:vpg_payload_color_0 <= p_color1;
          8'b00000010:vpg_payload_color_0 <= p_color2;
          8'b00000100:vpg_payload_color_0 <= p_color3;
          8'b00001000:vpg_payload_color_0 <= p_color4;
          8'b00010000:vpg_payload_color_0 <= p_color5;
          8'b00100000:vpg_payload_color_0 <= p_color6;
          8'b01000000:vpg_payload_color_0 <= p_color7;
          8'b10000000:vpg_payload_color_0 <= p_color8;
          default    :vpg_payload_color_0 <= 30'b0;
      endcase
  end //vpg_payload_color_0_PROC

  //The second color in a vpg_payload
  assign color_1_is_p_color2 =   data_in_zone1  ;

  assign color_1_is_p_color3 = (~data_in_zone1) & data_in_zone3  ;

  assign color_1_is_p_color4 = (~data_in_zone3) & data_in_zone5  ;

  assign color_1_is_p_color5 = (~data_in_zone5) & data_in_zone7  ;

  assign color_1_is_p_color6 = (~data_in_zone7) & data_in_zone9  ;

  assign color_1_is_p_color7 = (~data_in_zone9) & data_in_zone11 ;

  assign color_1_is_p_color8 = (~data_in_zone11)& data_in_zone13 ;

  assign color_1_cal_nxt = {color_1_is_p_color8,color_1_is_p_color7,color_1_is_p_color6,color_1_is_p_color5,
                            color_1_is_p_color4,color_1_is_p_color3,color_1_is_p_color2};

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : vpg_payload_color_1_PROC
      if(~ppi_clkrstz)
          vpg_payload_color_1 <= 30'b0;
      else
      case(color_1_cal)
          7'b0000001:vpg_payload_color_1 <= p_color2;
          7'b0000010:vpg_payload_color_1 <= p_color3;
          7'b0000100:vpg_payload_color_1 <= p_color4;
          7'b0001000:vpg_payload_color_1 <= p_color5;
          7'b0010000:vpg_payload_color_1 <= p_color6;
          7'b0100000:vpg_payload_color_1 <= p_color7;
          7'b1000000:vpg_payload_color_1 <= p_color8;
          default   :vpg_payload_color_1 <= 30'b0;
      endcase
  end //vpg_payload_color_1_PROC

  //The third color in a vpg_payload
  assign color_2_is_p_color3 =   data_in_zone1  & data_in_zone3  ;

  assign color_2_is_p_color4 = (~data_in_zone1) & data_in_zone3  & data_in_zone5  ;

  assign color_2_is_p_color5 = (~data_in_zone3) & data_in_zone5  & data_in_zone7  ;

  assign color_2_is_p_color6 = (~data_in_zone5) & data_in_zone7  & data_in_zone9  ;

  assign color_2_is_p_color7 = (~data_in_zone7) & data_in_zone9  & data_in_zone11 ;

  assign color_2_is_p_color8 = (~data_in_zone9) & data_in_zone11 & data_in_zone13 ;

  assign color_2_cal_nxt = {color_2_is_p_color8,color_2_is_p_color7,color_2_is_p_color6,color_2_is_p_color5,
                            color_2_is_p_color4,color_2_is_p_color3};

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : vpg_payload_color_2_PROC
      if(~ppi_clkrstz)
          vpg_payload_color_2 <= 30'b0;
      else
      case(color_2_cal)
          6'b000001:vpg_payload_color_2 <= p_color3;
          //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
          6'b000010:vpg_payload_color_2 <= p_color4;
          //ccx_line_end
          6'b000100:vpg_payload_color_2 <= p_color5;
          //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
          6'b001000:vpg_payload_color_2 <= p_color6;
          //ccx_line_end
          6'b010000:vpg_payload_color_2 <= p_color7;
          6'b100000:vpg_payload_color_2 <= p_color8;
          default  :vpg_payload_color_2 <= 30'b0;
      endcase
  end //vpg_payload_color_2_PROC

  //The fourth color in a vpg_payload
  assign color_3_is_p_color4 =   data_in_zone1  & data_in_zone5 ;

  assign color_3_is_p_color5 = (~data_in_zone1) & data_in_zone3 & data_in_zone7  ;

  assign color_3_is_p_color6 = (~data_in_zone3) & data_in_zone5 & data_in_zone9  ;

  assign color_3_is_p_color7 = (~data_in_zone5) & data_in_zone7 & data_in_zone11 ;

  assign color_3_is_p_color8 = (~data_in_zone7) & data_in_zone9 & data_in_zone13 ;

  assign color_3_cal_nxt = {color_3_is_p_color8,color_3_is_p_color7,color_3_is_p_color6,color_3_is_p_color5,
                            color_3_is_p_color4};

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : vpg_payload_color_3_PROC
      if(~ppi_clkrstz)
          vpg_payload_color_3 <= 30'b0;
      else
      case(color_3_cal)
          5'b00001:vpg_payload_color_3 <= p_color4;
          //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
          5'b00010:vpg_payload_color_3 <= p_color5;
          //ccx_line_end
          5'b00100:vpg_payload_color_3 <= p_color6;
          //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
          5'b01000:vpg_payload_color_3 <= p_color7;
          //ccx_line_end
          5'b10000:vpg_payload_color_3 <= p_color8;
          // spyglass disable_block UnUsedFlopOutput-ML
          // SMD: Unreachable sequential element must be removed from the design
          // SJ: Depending of the configuration, this line can be unreachable.
          default :vpg_payload_color_3 <= 30'b0;
          // spyglass enable_block UnUsedFlopOutput-ML
      endcase
  end //vpg_payload_color_3_PROC

  //The fifth color in a vpg_payload
  assign color_4_is_p_color5 =   data_in_zone1  & data_in_zone7 ;

  assign color_4_is_p_color6 = (~data_in_zone1) & data_in_zone3 & data_in_zone9  ;

  assign color_4_is_p_color7 = (~data_in_zone3) & data_in_zone5 & data_in_zone11 ;

  assign color_4_is_p_color8 = (~data_in_zone5) & data_in_zone7 & data_in_zone13 ;

  assign color_4_cal_nxt = {color_4_is_p_color8,color_4_is_p_color7,color_4_is_p_color6,color_4_is_p_color5};

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : vpg_payload_color_4_PROC
      if(~ppi_clkrstz)
          vpg_payload_color_4 <= 30'b0;
      else
      case(color_4_cal)
          4'b0001:vpg_payload_color_4 <= p_color5;
          //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
          4'b0010:vpg_payload_color_4 <= p_color6;
          //ccx_line_end
          //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
          4'b0100:vpg_payload_color_4 <= p_color7;
          //ccx_line_end
          //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
          4'b1000:vpg_payload_color_4 <= p_color8;
          //ccx_line_end
          // spyglass disable_block UnUsedFlopOutput-ML
          // SMD: Unreachable sequential element must be removed from the design
          // SJ: Depending of the configuration, this line can be unreachable.
          default:vpg_payload_color_4 <= 30'b0;
          // spyglass enable_block UnUsedFlopOutput-ML
      endcase
  end //vpg_payload_color_4_PROC

  //The sixth color in a vpg_payload
  assign color_5_is_p_color6 =   data_in_zone1  & data_in_zone9 ;

  assign color_5_is_p_color7 = (~data_in_zone1) & data_in_zone3 & data_in_zone11 ;

  assign color_5_is_p_color8 = (~data_in_zone3) & data_in_zone5 & data_in_zone13 ;

  assign color_5_cal_nxt = {color_5_is_p_color8,color_5_is_p_color7,color_5_is_p_color6};

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : vpg_payload_color_5_PROC
      if(~ppi_clkrstz)
          vpg_payload_color_5 <= 30'b0;
      else
      case(color_5_cal)
          3'b001 :vpg_payload_color_5 <= p_color6;
          //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
          3'b010 :vpg_payload_color_5 <= p_color7;
          //ccx_line_end
          //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
          3'b100 :vpg_payload_color_5 <= p_color8;
          //ccx_line_end
          // spyglass disable_block UnUsedFlopOutput-ML
          // SMD: Unreachable sequential element must be removed from the design
          // SJ: Depending of the configuration, this line can be unreachable.
          default:vpg_payload_color_5 <= 30'b0;
          // spyglass enable_block UnUsedFlopOutput-ML
      endcase
  end //vpg_payload_color_5_PROC

  //The seventh color in a vpg_payload
  assign color_6_is_p_color7 =   data_in_zone1 & data_in_zone11 ;

  assign color_6_is_p_color8 = (~data_in_zone1)& data_in_zone3 & data_in_zone13 ;

  assign color_6_cal_nxt = {color_6_is_p_color8,color_6_is_p_color7};

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : vpg_payload_color_6_PROC
      if(~ppi_clkrstz)
          vpg_payload_color_6 <= 30'b0;
      else
      case(color_6_cal)
          2'b01  :vpg_payload_color_6 <= p_color7;
          //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
          2'b10  :vpg_payload_color_6 <= p_color8;
          //ccx_line_end
          // spyglass disable_block UnUsedFlopOutput-ML
          // SMD: Unreachable sequential element must be removed from the design
          // SJ: Depending of the configuration, this line can be unreachable.
          default:vpg_payload_color_6 <= 30'b0;
          // spyglass enable_block UnUsedFlopOutput-ML
      endcase
  end //vpg_payload_color_6_PROC

  //The eighth color in a vpg_payload
  assign color_7_is_p_color8 = data_in_zone1 & data_in_zone13 ;

  assign color_7_cal_nxt = color_7_is_p_color8;

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : vpg_payload_color_7_PROC
      if(~ppi_clkrstz)
          vpg_payload_color_7 <= 30'b0;
      else
      case(color_7_cal)
          1'b1   :vpg_payload_color_7 <= p_color8;
          // spyglass disable_block UnUsedFlopOutput-ML
          // SMD: Unreachable sequential element must be removed from the design
          // SJ: Depending of the configuration, this line can be unreachable.
          default:vpg_payload_color_7 <= 30'b0;
          // spyglass enable_block UnUsedFlopOutput-ML
      endcase
  end //vpg_payload_color_7_PROC

  //Only up to eight kinds of color and color modes are up to seven as color cut-off points, so index of color is not more than 7.
  // spyglass disable_block W484
  // SMD: Possible assignment overflow.
  // SJ: Overflow can't occur. Protected by protocol.

  always @ * begin: p2_index_nxt_PROC
      case(color_x_y)
           1'b1 :    p2_index_nxt = 1'b1;
           default:  p2_index_nxt = 1'b0;
      endcase
  end // p2_index_nxt_PROC

  always @ * begin: p3_index_nxt_PROC
      case({p2_index_nxt,color_2x_y})
           {1'd1,1'b1} :   p3_index_nxt = 2'd2;
           {1'd1,1'b0},
           {1'd0,1'b1} :   p3_index_nxt = 2'd1;
           default     :   p3_index_nxt = 2'd0;
      endcase
  end // p3_index_nxt_PROC

  always @ * begin: p4_index_nxt_PROC
      case({p3_index_nxt,color_3x_y})
           {2'd2,1'b1} :   p4_index_nxt = 2'd3;
           //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.           
           {2'd2,1'b0},
           {2'd1,1'b1} :   p4_index_nxt = 2'd2;
           //ccx_line_end
           {2'd1,1'b0},
           {2'd0,1'b1} :   p4_index_nxt = 2'd1;
           default     :   p4_index_nxt = 2'd0;
      endcase
  end // p4_index_nxt_PROC

  always @ * begin: p5_index_nxt_PROC
      case({p4_index_nxt,color_4x_y})
           {2'd3,1'b1} :   p5_index_nxt = 3'd4;
           //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
           {2'd3,1'b0},
           {2'd2,1'b1} :   p5_index_nxt = 3'd3;
           //ccx_line_end
           {2'd2,1'b0},
           {2'd1,1'b1} :   p5_index_nxt = 3'd2;
           {2'd1,1'b0},
           {2'd0,1'b1} :   p5_index_nxt = 3'd1;
           default     :   p5_index_nxt = 3'd0;
      endcase
  end // p5_index_nxt_PROC

  always @ * begin: p6_index_nxt_PROC
      case({p5_index_nxt,color_5x_y})
           {3'd4,1'b1} :   p6_index_nxt = 3'd5;
           //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
           {3'd4,1'b0},
           {3'd3,1'b1} :   p6_index_nxt = 3'd4;
           //ccx_line_end
           //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
           {3'd3,1'b0},
           {3'd2,1'b1} :   p6_index_nxt = 3'd3;
           //ccx_line_end
           {3'd2,1'b0},
           {3'd1,1'b1} :   p6_index_nxt = 3'd2;
           {3'd1,1'b0},
           {3'd0,1'b1} :   p6_index_nxt = 3'd1;
           default     :   p6_index_nxt = 3'd0;
      endcase
  end // p6_index_nxt_PROC

  always @ * begin: p7_index_nxt_PROC
      case({p6_index_nxt,color_6x_y})
           {3'd5,1'b1} :   p7_index_nxt = 3'd6;
           {3'd5,1'b0},
           {3'd4,1'b1} :   p7_index_nxt = 3'd5;
           //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
           {3'd4,1'b0},
           {3'd3,1'b1} :   p7_index_nxt = 3'd4;
           //ccx_line_end
           {3'd3,1'b0},
           {3'd2,1'b1} :   p7_index_nxt = 3'd3;
           {3'd2,1'b0},
           {3'd1,1'b1} :   p7_index_nxt = 3'd2;
           {3'd1,1'b0},
           {3'd0,1'b1} :   p7_index_nxt = 3'd1;
           default     :   p7_index_nxt = 3'd0;
      endcase
  end // p7_index_nxt_PROC

  always @ * begin: p8_index_nxt_PROC
      case({p7_index_nxt,color_7x_y})
           {3'd6,1'b1} :   p8_index_nxt = 3'd7;
           //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
           {3'd6,1'b0},
           {3'd5,1'b1} :   p8_index_nxt = 3'd6;
           //ccx_line_end
           {3'd5,1'b0},
           {3'd4,1'b1} :   p8_index_nxt = 3'd5;
           //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
           {3'd4,1'b0},
           {3'd3,1'b1} :   p8_index_nxt = 3'd4;
           //ccx_line_end
           {3'd3,1'b0},
           {3'd2,1'b1} :   p8_index_nxt = 3'd3;
           {3'd2,1'b0},
           {3'd1,1'b1} :   p8_index_nxt = 3'd2;
           {3'd1,1'b0},
           {3'd0,1'b1} :   p8_index_nxt = 3'd1;
           default     :   p8_index_nxt = 3'd0;
      endcase
  end // p8_index_nxt_PROC

  always @ * begin: p9_index_nxt_PROC
      case({p8_index_nxt,color_8x_y})
           {3'd7,1'b0},
           {3'd6,1'b1} :   p9_index_nxt = 3'd7;
           //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
           {3'd6,1'b0},
           {3'd5,1'b1} :   p9_index_nxt = 3'd6;
           //ccx_line_end
           {3'd5,1'b0},
           {3'd4,1'b1} :   p9_index_nxt = 3'd5;
           //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
           {3'd4,1'b0},
           {3'd3,1'b1} :   p9_index_nxt = 3'd4;
           //ccx_line_end
           {3'd3,1'b0},
           {3'd2,1'b1} :   p9_index_nxt = 3'd3;
           {3'd2,1'b0},
           {3'd1,1'b1} :   p9_index_nxt = 3'd2;
           {3'd1,1'b0},
           {3'd0,1'b1} :   p9_index_nxt = 3'd1;
           default     :   p9_index_nxt = 3'd0;
      endcase
  end // p9_index_nxt_PROC

  always @ * begin: p10_index_nxt_PROC
      case({p9_index_nxt,color_9x_y})
           {3'd7,1'b0},
           {3'd6,1'b1} :   p10_index_nxt = 3'd7;
           //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
           {3'd6,1'b0},
           {3'd5,1'b1} :   p10_index_nxt = 3'd6;
           //ccx_line_end
           {3'd5,1'b0},
           {3'd4,1'b1} :   p10_index_nxt = 3'd5;
           //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.           
           {3'd4,1'b0},
           {3'd3,1'b1} :   p10_index_nxt = 3'd4;
           //ccx_line_end           
           {3'd3,1'b0},
           {3'd2,1'b1} :   p10_index_nxt = 3'd3;
           {3'd2,1'b0},
           {3'd1,1'b1} :   p10_index_nxt = 3'd2;
           {3'd1,1'b0},
           {3'd0,1'b1} :   p10_index_nxt = 3'd1;
           default     :   p10_index_nxt = 3'd0;
      endcase
  end // p10_index_nxt_PROC

  always @ * begin: p11_index_nxt_PROC
      case({p10_index_nxt,color_10x_y})
           {3'd7,1'b0},
           {3'd6,1'b1} :   p11_index_nxt = 3'd7;
           //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
           {3'd6,1'b0},
           {3'd5,1'b1} :   p11_index_nxt = 3'd6;
           //ccx_line_end
           {3'd5,1'b0},
           {3'd4,1'b1} :   p11_index_nxt = 3'd5;
           //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.           
           {3'd4,1'b0},
           {3'd3,1'b1} :   p11_index_nxt = 3'd4;
           //ccx_line_end           
           {3'd3,1'b0},
           {3'd2,1'b1} :   p11_index_nxt = 3'd3;
           {3'd2,1'b0},
           {3'd1,1'b1} :   p11_index_nxt = 3'd2;
           {3'd1,1'b0},
           {3'd0,1'b1} :   p11_index_nxt = 3'd1;
           default     :   p11_index_nxt = 3'd0;
      endcase
  end // p11_index_nxt_PROC

  always @ * begin: p12_index_nxt_PROC
      case({p11_index_nxt,color_11x_y})
           {3'd7,1'b0},
           {3'd6,1'b1} :   p12_index_nxt = 3'd7;
           //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
           {3'd6,1'b0},
           {3'd5,1'b1} :   p12_index_nxt = 3'd6;
           //ccx_line_end
           {3'd5,1'b0},
           {3'd4,1'b1} :   p12_index_nxt = 3'd5;
           //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.           
           {3'd4,1'b0},
           {3'd3,1'b1} :   p12_index_nxt = 3'd4;
           //ccx_line_end           
           {3'd3,1'b0},
           {3'd2,1'b1} :   p12_index_nxt = 3'd3;
           {3'd2,1'b0},
           {3'd1,1'b1} :   p12_index_nxt = 3'd2;
           {3'd1,1'b0},
           {3'd0,1'b1} :   p12_index_nxt = 3'd1;
           default     :   p12_index_nxt = 3'd0;
      endcase
  end // p12_index_nxt_PROC

  always @ * begin: p13_index_nxt_PROC
      case({p12_index_nxt,color_12x_y})
           {3'd7,1'b0},
           {3'd6,1'b1} :   p13_index_nxt = 3'd7;
           //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.             
           {3'd6,1'b0},
           {3'd5,1'b1} :   p13_index_nxt = 3'd6;
           //ccx_line_end            
           {3'd5,1'b0},
           {3'd4,1'b1} :   p13_index_nxt = 3'd5;
           //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.             
           {3'd4,1'b0},
           {3'd3,1'b1} :   p13_index_nxt = 3'd4;
           //ccx_line_end              
           {3'd3,1'b0},
           {3'd2,1'b1} :   p13_index_nxt = 3'd3;
           {3'd2,1'b0},
           {3'd1,1'b1} :   p13_index_nxt = 3'd2;
           {3'd1,1'b0},
           {3'd0,1'b1} :   p13_index_nxt = 3'd1;
           default     :   p13_index_nxt = 3'd0;
      endcase
  end // p13_index_nxt_PROC

  always @ * begin: p14_index_nxt_PROC
      case({p13_index_nxt,color_13x_y})
           {3'd7,1'b0},
           {3'd6,1'b1} :   p14_index_nxt = 3'd7;
           //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.            
           {3'd6,1'b0},
           {3'd5,1'b1} :   p14_index_nxt = 3'd6;
           //ccx_line_end              
           {3'd5,1'b0},
           {3'd4,1'b1} :   p14_index_nxt = 3'd5;
           //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.            
           {3'd4,1'b0},
           {3'd3,1'b1} :   p14_index_nxt = 3'd4;
           //ccx_line_end              
           {3'd3,1'b0},
           {3'd2,1'b1} :   p14_index_nxt = 3'd3;
           {3'd2,1'b0},
           {3'd1,1'b1} :   p14_index_nxt = 3'd2;
           {3'd1,1'b0},
           {3'd0,1'b1} :   p14_index_nxt = 3'd1;
           default     :   p14_index_nxt = 3'd0;
      endcase
  end // p14_index_nxt_PROC

  always @ * begin: p15_index_nxt_PROC
      case({p14_index_nxt,color_14x_y})
           {3'd7,1'b0},
           {3'd6,1'b1} :   p15_index_nxt = 3'd7;
           //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.             
           {3'd6,1'b0},
           {3'd5,1'b1} :   p15_index_nxt = 3'd6;
           //ccx_line_end              
           {3'd5,1'b0},
           {3'd4,1'b1} :   p15_index_nxt = 3'd5;
           //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.             
           {3'd4,1'b0},
           {3'd3,1'b1} :   p15_index_nxt = 3'd4;
           //ccx_line_end             
           {3'd3,1'b0},
           {3'd2,1'b1} :   p15_index_nxt = 3'd3;
           {3'd2,1'b0},
           {3'd1,1'b1} :   p15_index_nxt = 3'd2;
           {3'd1,1'b0},
           {3'd0,1'b1} :   p15_index_nxt = 3'd1;
           default     :   p15_index_nxt = 3'd0;
      endcase
  end // p15_index_nxt_PROC

  always @ * begin: p16_index_nxt_PROC
      case({p15_index_nxt,color_15x_y})
           {3'd7,1'b0},
           {3'd6,1'b1} :   p16_index_nxt = 3'd7;
           //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.             
           {3'd6,1'b0},
           {3'd5,1'b1} :   p16_index_nxt = 3'd6;
           //ccx_line_end            
           {3'd5,1'b0},
           {3'd4,1'b1} :   p16_index_nxt = 3'd5;
           //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.             
           {3'd4,1'b0},
           {3'd3,1'b1} :   p16_index_nxt = 3'd4;
           //ccx_line_end             
           {3'd3,1'b0},
           {3'd2,1'b1} :   p16_index_nxt = 3'd3;
           {3'd2,1'b0},
           {3'd1,1'b1} :   p16_index_nxt = 3'd2;
           {3'd1,1'b0},
           {3'd0,1'b1} :   p16_index_nxt = 3'd1;
           default     :   p16_index_nxt = 3'd0;
      endcase
  end // p16_index_nxt_PROC

  // spyglass enable_block W484

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : pN_index_PROC
      if(~ppi_clkrstz) begin
          p2_index  <= 1'b0;
          p3_index  <= 2'b0;
          p4_index  <= 2'b0;
          p5_index  <= 3'b0;
          p6_index  <= 3'b0;
          p7_index  <= 3'b0;
          p8_index  <= 3'b0;
          p9_index  <= 3'b0;
          p10_index <= 3'b0;
          p11_index <= 3'b0;
          p12_index <= 3'b0;
          p13_index <= 3'b0;
          p14_index <= 3'b0;
          p15_index <= 3'b0;
          p16_index <= 3'b0;
      end else begin
          // spyglass disable_block FlopDataConstant
          // SMD: Flip-flop data pin driven by a constant value
          // SJ: High bits are intentionally tiew to low
          p2_index  <= p2_index_nxt;
          // spyglass enable_block FlopDataConstant
          p3_index  <= p3_index_nxt;
          p4_index  <= p4_index_nxt;
          p5_index  <= p5_index_nxt;
          p6_index  <= p6_index_nxt;
          p7_index  <= p7_index_nxt;
          p8_index  <= p8_index_nxt;
          p9_index  <= p9_index_nxt;
          p10_index <= p10_index_nxt;
          p11_index <= p11_index_nxt;
          p12_index <= p12_index_nxt;
          p13_index <= p13_index_nxt;
          p14_index <= p14_index_nxt;
          p15_index <= p15_index_nxt;
          p16_index <= p16_index_nxt;
      end
  end //pN_index_PROC

  //Use some pixel buses to contain the components of different color in different color mode.
  //Such as p1, p2 and so on, every pixel bus is used for one pixel in a vpg_payload.
  //The p1 is used for the first pixel component and p2 is used for the second pixel component and others can be reasoned.

  // spyglass disable_block UnloadedNet-ML
  // SMD: Unloaded but driven net detected in the design
  // SJ: Some bits of the signal may not be needed in different configurations.
  // spyglass disable_block checkNetReceiver
  // SMD: Each internal net must have at least one receiver.
  // SJ: Some bits of the signal may not be needed in different configurations.
  // spyglass disable_block OutNotUsed
  // SMD: No output of a gate is used
  // SJ: Some bits of the signal may not be needed in different configurations.
  assign p1 = vpg_payload_color_0;

  always@* begin : p2_PROC
      case(p2_index)
          1'b0   :p2 = vpg_payload_color_0;
          default:p2 = vpg_payload_color_1;
      endcase
  end //p2_PROC

  always@* begin : p3_PROC
      case(p3_index)
          2'd0   :p3 = vpg_payload_color_0;
          2'd1   :p3 = vpg_payload_color_1;
          default:p3 = vpg_payload_color_2;
      endcase
  end //p3_PROC

  always@* begin : p4_PROC
      case(p4_index)
          2'd0   :p4 = vpg_payload_color_0;
          2'd1   :p4 = vpg_payload_color_1;
          //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
          2'd2   :p4 = vpg_payload_color_2;
          //ccx_line_end
          default:p4 = vpg_payload_color_3;
      endcase
  end //p4_PROC

  always@* begin : p5_PROC
      case(p5_index)
          3'd0   :p5 = vpg_payload_color_0;
          3'd1   :p5 = vpg_payload_color_1;
          3'd2   :p5 = vpg_payload_color_2;
          //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
          3'd3   :p5 = vpg_payload_color_3;
          //ccx_line_end
          default:p5 = vpg_payload_color_4;
      endcase
  end //p5_PROC

  always@* begin : p6_PROC
      case(p6_index)
          3'd0   :p6 = vpg_payload_color_0;
          3'd1   :p6 = vpg_payload_color_1;
          3'd2   :p6 = vpg_payload_color_2;
          //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
          3'd3   :p6 = vpg_payload_color_3;
          //ccx_line_end
          //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
          3'd4   :p6 = vpg_payload_color_4;
          //ccx_line_end
          default:p6 = vpg_payload_color_5;
      endcase
  end //p6_PROC

  always@* begin : p7_PROC
      case(p7_index)
          3'd0   :p7 = vpg_payload_color_0;
          3'd1   :p7 = vpg_payload_color_1;
          3'd2   :p7 = vpg_payload_color_2;
          3'd3   :p7 = vpg_payload_color_3;
          //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
          3'd4   :p7 = vpg_payload_color_4;
          //ccx_line_end
          3'd5   :p7 = vpg_payload_color_5;
          default:p7 = vpg_payload_color_6;
      endcase
  end //p7_PROC

  always@* begin : p8_PROC
      case(p8_index)
          3'd0   :p8 = vpg_payload_color_0;
          3'd1   :p8 = vpg_payload_color_1;
          3'd2   :p8 = vpg_payload_color_2;
          3'd3   :p8 = vpg_payload_color_3;
          //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
          3'd4   :p8 = vpg_payload_color_4;
          //ccx_line_end
          3'd5   :p8 = vpg_payload_color_5;
          //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
          3'd6   :p8 = vpg_payload_color_6;
          //ccx_line_end
          default:p8 = vpg_payload_color_7;
      endcase
  end //p8_PROC

  always@* begin : p9_PROC
      case(p9_index)
          3'd0   :p9 = vpg_payload_color_0;
          3'd1   :p9 = vpg_payload_color_1;
          3'd2   :p9 = vpg_payload_color_2;
          3'd3   :p9 = vpg_payload_color_3;
          //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.          
          3'd4   :p9 = vpg_payload_color_4;
          //ccx_line_end          
          3'd5   :p9 = vpg_payload_color_5;
          //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
          3'd6   :p9 = vpg_payload_color_6;
          //ccx_line_end
          default:p9 = vpg_payload_color_7;
      endcase
  end //p9_PROC

  always@* begin : p10_PROC
      case(p10_index)
          3'd0   :p10 = vpg_payload_color_0;
          3'd1   :p10 = vpg_payload_color_1;
          3'd2   :p10 = vpg_payload_color_2;
          3'd3   :p10 = vpg_payload_color_3;
          //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.          
          3'd4   :p10 = vpg_payload_color_4;
          //ccx_line_end          
          3'd5   :p10 = vpg_payload_color_5;
          //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
          3'd6   :p10 = vpg_payload_color_6;
          //ccx_line_end
          default:p10 = vpg_payload_color_7;
      endcase
  end //p10_PROC

  always@* begin : p11_PROC
      case(p11_index)
          3'd0   :p11 = vpg_payload_color_0;
          3'd1   :p11 = vpg_payload_color_1;
          3'd2   :p11 = vpg_payload_color_2;
          3'd3   :p11 = vpg_payload_color_3;
          //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
          3'd4   :p11 = vpg_payload_color_4;
          //ccx_line_end
          3'd5   :p11 = vpg_payload_color_5;
          //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
          3'd6   :p11 = vpg_payload_color_6;
          //ccx_line_end
          default:p11 = vpg_payload_color_7;
      endcase
  end //p11_PROC

  always@* begin : p12_PROC
      case(p12_index)
          3'd0   :p12 = vpg_payload_color_0;
          3'd1   :p12 = vpg_payload_color_1;
          3'd2   :p12 = vpg_payload_color_2;
          3'd3   :p12 = vpg_payload_color_3;
          //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
          3'd4   :p12 = vpg_payload_color_4;
          //ccx_line_end
          3'd5   :p12 = vpg_payload_color_5;
          //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
          3'd6   :p12 = vpg_payload_color_6;
          //ccx_line_end
          default:p12 = vpg_payload_color_7;
      endcase
  end //p12_PROC

  always@* begin : p13_PROC
      case(p13_index)
          3'd0   :p13 = vpg_payload_color_0;
          3'd1   :p13 = vpg_payload_color_1;
          3'd2   :p13 = vpg_payload_color_2;
          3'd3   :p13 = vpg_payload_color_3;
          //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.          
          3'd4   :p13 = vpg_payload_color_4;
          //ccx_line_end          
          3'd5   :p13 = vpg_payload_color_5;
          //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.           
          3'd6   :p13 = vpg_payload_color_6;
          //ccx_line_end            
          default:p13 = vpg_payload_color_7;
      endcase
  end //p13_PROC

  always@* begin : p14_PROC
      case(p14_index)
          3'd0   :p14 = vpg_payload_color_0;
          3'd1   :p14 = vpg_payload_color_1;
          3'd2   :p14 = vpg_payload_color_2;
          3'd3   :p14 = vpg_payload_color_3;
          //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.           
          3'd4   :p14 = vpg_payload_color_4;
          //ccx_line_end          
          3'd5   :p14 = vpg_payload_color_5;
          //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.            
          3'd6   :p14 = vpg_payload_color_6;
          //ccx_line_end          
          default:p14 = vpg_payload_color_7;
      endcase
  end //p14_PROC

  always@* begin : p15_PROC
      case(p15_index)
          3'd0   :p15 = vpg_payload_color_0;
          3'd1   :p15 = vpg_payload_color_1;
          3'd2   :p15 = vpg_payload_color_2;
          3'd3   :p15 = vpg_payload_color_3;
          //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.          
          3'd4   :p15 = vpg_payload_color_4;
          //ccx_line_end          
          3'd5   :p15 = vpg_payload_color_5;
          //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
          3'd6   :p15 = vpg_payload_color_6;
          //ccx_line_end
          default:p15 = vpg_payload_color_7;
      endcase
  end //p15_PROC

  always@* begin : p16_PROC
      case(p16_index)
          3'd0   :p16 = vpg_payload_color_0;
          3'd1   :p16 = vpg_payload_color_1;
          3'd2   :p16 = vpg_payload_color_2;
          3'd3   :p16 = vpg_payload_color_3;
          //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
          3'd4   :p16 = vpg_payload_color_4;
          //ccx_line_end
          3'd5   :p16 = vpg_payload_color_5;
          //ccx_line_begin: ; It is a unreachable condition, just for coding integrity to be kept.
          3'd6   :p16 = vpg_payload_color_6;
          //ccx_line_end
          default:p16 = vpg_payload_color_7;
      endcase
  end //p16_PROC

  // spyglass enable_block OutNotUsed
  // spyglass enable_block checkNetReceiver
  // spyglass enable_block UnloadedNet-ML

  ////////////////////////////////////////////////////////////////////////////////
  ////////////////////////// vpg_payload build ////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////
  //Pattern package payload data (LSB transmission first)
  //Be jointed by pixel bus based on encoding map.

  //According to the color encode, the pixels generation can be divided into 4 categories
  //The counter for pixels generation is cyclical repetition.
  //The gen_cnt_period is used to define the cycles of repetition period.
  always@* begin : gen_cnt_period_PROC
      case(vpg_dt_qst)
          `CSI2_RAW6,
          `CSI2_RAW12,
          `CSI2_RAW24,
          `CSI2_LY420_8B,
          `CSI2_RGB888:begin
              gen_cnt_period = 4'd2;
          end
          `CSI2_RGB666:begin
              gen_cnt_period = 4'd8;
          end
          `CSI2_RAW8,
          `CSI2_Y420_8B,
          `CSI2_CSPS_Y420_8B,
          `CSI2_Y422_8B,
          `CSI2_RAW16,
          `CSI2_RGB444,
          `CSI2_RGB555,
          `CSI2_RGB565:begin
              gen_cnt_period = 4'd0;
          end
          `CSI2_RAW10,
          `CSI2_RAW20,
          `CSI2_Y420_10B,
          `CSI2_CSPS_Y420_10B,
          `CSI2_Y422_10B:begin
              gen_cnt_period = 4'd4;
          end
          default:begin // `CSI2_RAW7,`CSI2_RAW14
              gen_cnt_period = 4'd6;
          end
      endcase
  end //gen_cnt_period_PROC

  //Current gen_cnt indication
  always@* begin : next_gen_cnt_PROC
      if(vpg_pld_gen_end)
          next_gen_cnt    = 4'd0;
      else
          if(vpg_pld_req_pre)
              if(current_gen_cnt == gen_cnt_period)
                  next_gen_cnt = 4'd0;
              else
              // spyglass disable_block W484
              // SMD: Possible assignment overflow.
              // SJ: Overflow can't occur. Protected by protocol.
                  next_gen_cnt = current_gen_cnt + 4'd1;
              // spyglass enable_block W484
          else
              next_gen_cnt = current_gen_cnt;
  end //next_gen_cnt_PROC

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : current_gen_cnt_PROC
    if(~ppi_clkrstz)
        current_gen_cnt    <= 4'd0;
    else
        current_gen_cnt    <= next_gen_cnt;
  end //current_gen_cnt_PROC

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : current_gen_cnt_d1_r_PROC
    if(~ppi_clkrstz)
        current_gen_cnt_d1_r <= 4'd0;
    else
        if(vpg_pld_gen_end)
            current_gen_cnt_d1_r <= 4'd0;
        else
            if(vpg_pld_req_pre)
                current_gen_cnt_d1_r <= current_gen_cnt;
  end // current_gen_cnt_d1_r_PROC

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : current_gen_cnt_d2_r_PROC
    if(~ppi_clkrstz)
        current_gen_cnt_d2_r <= 4'd0;
    else
        if(vpg_pld_gen_end)
            current_gen_cnt_d2_r <= 4'd0;
        else
            if(vpg_pld_req)
                current_gen_cnt_d2_r <= current_gen_cnt_d1_r;
  end // current_gen_cnt_d2_r_PROC

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : vpg_pld_req_1d_r_PROC
    if(~ppi_clkrstz)
        vpg_pld_req_1d_r <= 1'd0;
    else
        vpg_pld_req_1d_r <= vpg_pld_req;
  end  //vpg_pld_req_1d_r_PROC

  assign vpg_pld_shift_out = vpg_payload_shifter[63:0];

  always@* begin : first_category_pixels_PROC
      case(vpg_dt_qst)
          `CSI2_RAW6:begin
              first_category_pixels[71:0]    = {p12[29:24],p11[14: 9],p10[29:24], p9[14: 9],
                                                 p8[29:24], p7[14: 9], p6[29:24], p5[14: 9],
                                                 p4[29:24], p3[14: 9], p2[29:24], p1[14: 9]};
          end
          `CSI2_RAW12:begin
              first_category_pixels[71:0]    = { p6[21:18], p5[ 6: 3], p6[29:22], p5[14: 7],
                                                 p4[21:18], p3[ 6: 3], p4[29:22], p3[14: 7],
                                                 p2[21:18], p1[ 6: 3], p2[29:22], p1[14: 7]};
          end
          `CSI2_LY420_8B:begin
              first_category_pixels[71:0]   =  { p6[29:22], p5[29:22], p5[14: 7],
                                                 p4[29:22], p3[29:22], p3[14: 7],
                                                 p2[29:22], p1[29:22], p1[14: 7]};
          end
          `CSI2_RGB666:begin
              first_category_pixels[71:0]    = { p4[29:24], p4[19:14], p4[ 9: 4], p3[29:24], p3[19:14], p3[ 9: 4], p2[29:24], p2[19:14], p2[ 9: 4], p1[29:24], p1[19:14], p1[ 9: 4]};
          end
          default:begin
              first_category_pixels[71:0]    = {p3[29:22], p3[19:12], p3[ 9: 2], p2[29:22], p2[19:12], p2[ 9: 2], p1[29:22], p1[19:12], p1[ 9: 2]};
          end
      endcase
  end //first_category_pixels_PROC

  always@* begin : second_category_pixels_PROC
      case(vpg_dt_qst)
          `CSI2_RAW16:begin
              second_category_pixels[63:0]    = {p4[22: 15], p4[29], p4[29: 23], p3[7: 0], p3[14], p3[14: 8],
                                                 p2[22: 15], p2[29], p2[29: 23], p1[7: 0], p1[14], p1[14: 8]};
          end

          `CSI2_RAW8:begin
              second_category_pixels[63:0]    = { p8[29:22], p7[14: 7], p6[29:22], p5[14: 7], p4[29:22], p3[14: 7], p2[29:22], p1[14: 7]};
          end
          `CSI2_CSPS_Y420_8B,
          `CSI2_Y420_8B:begin
              if(odd_line)begin
                  second_category_pixels[63:0]    = { p8[29:22], p7[29:22], p6[29:22], p5[29:22], p4[29:22], p3[29:22], p2[29:22], p1[29:22]};
              end
                  else begin
                      second_category_pixels[63:0]    = {p4[29:22], p3[ 9: 2], p3[29:22], p3[19:12], p2[29:22], p1[ 9: 2], p1[29:22], p1[19:12]};
                  end
          end
          `CSI2_Y422_8B:begin
                  second_category_pixels[63:0]    = {p4[29:22], p3[ 9: 2], p3[29:22], p3[19:12], p2[29:22], p1[ 9: 2], p1[29:22], p1[19:12]};
          end
          default:begin //`CSI2_RGB444,`CSI2_RGB555,`CSI2_RGB565
                  second_category_pixels[63:0]    = {p4[29:25], p4[19:14], p4[9:5], p3[29:25], p3[19:14], p3[9:5], p2[29:25], p2[19:14], p2[9:5], p1[29:25], p1[19:14], p1[9:5]};
          end
      endcase
  end //second_category_pixels_PROC

  always@* begin : third_category_pixels_PROC
      case(vpg_dt_qst)
          `CSI2_RAW10:begin
              third_category_pixels[79:0]    = { p8[21:20], p7[ 6: 5], p6[21:20], p5[ 6: 5], p8[29:22], p7[14: 7], p6[29:22], p5[14: 7],
                                                 p4[21:20], p3[ 6: 5], p2[21:20], p1[ 6: 5], p4[29:22], p3[14: 7], p2[29:22], p1[14: 7]};
          end
          `CSI2_Y420_10B,
          `CSI2_CSPS_Y420_10B:begin
              if(odd_line) begin
                  third_category_pixels[79:0]    = { p8[21:20], p7[21:20], p6[21:20], p5[21:20], p8[29:22], p7[29:22], p6[29:22], p5[29:22],
                                                     p4[21:20], p3[21:20], p2[21:20], p1[21:20], p4[29:22], p3[29:22], p2[29:22], p1[29:22]};
              end
                  else begin
                      third_category_pixels[79:0]    = { p4[21:20], p3[ 1: 0], p3[21:20], p3[11:10], p4[29:22], p3[ 9: 2], p3[29:22], p3[19:12],
                                                         p2[21:20], p1[ 1: 0], p1[21:20], p1[11:10], p2[29:22], p1[ 9: 2], p1[29:22], p1[19:12]};
                  end
          end
          `CSI2_RAW20:begin
                  third_category_pixels[79:0]    = { p4[16:15], p4[26:25], p3[ 1: 0], p3[11:10], p4[24:17], {5{p4[29]}}, p4[29:27], p3[ 9: 2], {5{p3[14]}}, p3[14:12],
                                                     p2[16:15], p2[26:25], p1[ 1: 0], p1[11:10], p2[24:17], {5{p2[29]}}, p2[29:27], p1[ 9: 2], {5{p1[14]}}, p1[14:12]};
          end
          default:begin // CSI2_Y422_10B
                  third_category_pixels[79:0]    = { p4[21:20], p3[ 1: 0], p3[21:20], p3[11:10], p4[29:22], p3[ 9: 2], p3[29:22], p3[19:12],
                                                     p2[21:20], p1[ 1: 0], p1[21:20], p1[11:10], p2[29:22], p1[ 9: 2], p1[29:22], p1[19:12]};
          end
      endcase
  end //third_category_pixels_PROC

  always@* begin : fourth_category_pixels_PROC
      case(vpg_dt_qst)
          `CSI2_RAW7:begin
                   fourth_category_pixels[111:0]   = {p16[29:23],p15[14: 8],p14[29:23],p13[14: 8],p12[29:23],p11[14: 8],p10[29:23], p9[14: 8],
                                                       p8[29:23], p7[14: 8], p6[29:23], p5[14: 8], p4[29:23], p3[14: 8], p2[29:23], p1[14: 8]};
          end
          default:begin // `CSI2_RAW14
                  fourth_category_pixels[111:0]   = { p8[21:16], p7[6 : 1], p6[21:16], p5[ 6: 1], p8[29:22], p7[14: 7], p6[29:22], p5[14: 7],
                                                      p4[21:16], p3[6 : 1], p2[21:16], p1[ 6: 1], p4[29:22], p3[14: 7], p2[29:22], p1[14: 7]};
          end
      endcase
  end //fourth_category_pixels_PROC

  always@* begin : fifth_category_pixels_PROC
      case(vpg_dt_qst)
          `CSI2_RGB888:begin
              fifth_category_pixels[95:0] = {p4[29:22], p4[19:12], p4[ 9: 2], p3[29:22], p3[19:12], p3[ 9: 2], p2[29:22], p2[19:12], p2[ 9: 2], p1[29:22], p1[19:12], p1[ 9: 2]};
          end
          default:begin // `CSI2_RAW24
              fifth_category_pixels[95:0]    = { p4[18:15], p4[29], p4[29:27], p4[26:19], {8{p4[29]}}, p3[ 3: 0], p3[14], p3[14: 12], p3[11: 4], {8{p3[14]}},
                                                 p2[18:15], p2[29], p2[29:27], p2[26:19], {8{p2[29]}}, p1[ 3: 0], p1[14], p1[14: 12], p1[11: 4], {8{p1[14]}}};
          end
      endcase
  end //fifth_category_pixels_PROC

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : vpg_payload_shifter_64_PROC
      if(~ppi_clkrstz)
          vpg_payload_shifter    <= 112'b0;
      else
          if(vpg_pld_req_1d_r)
              case(vpg_dt_qst)
                  `CSI2_RAW6,
                  `CSI2_RAW12,
                  `CSI2_LY420_8B:begin
                      case(current_gen_cnt_d2_r)
                          4'd0:begin //72
                              vpg_payload_shifter[71:0] <= first_category_pixels[71:0];
                          end
                          4'd1:begin //72
                              vpg_payload_shifter[79:8] <= first_category_pixels[71:0];
                              vpg_payload_shifter[7:0]  <= vpg_payload_shifter[71:64];
                          end
                          default:begin   //4'd2 //48
                              vpg_payload_shifter[63:16] <= first_category_pixels[47:0];
                              vpg_payload_shifter[15:0]  <= vpg_payload_shifter[79:64];
                          end
                      endcase
                  end
                  `CSI2_RGB666:begin
                      case(current_gen_cnt_d2_r)
                          4'd0:begin //72
                              vpg_payload_shifter[71:0] <= first_category_pixels[71:0];
                          end
                          4'd1:begin //72
                              vpg_payload_shifter[79:8] <= first_category_pixels[71:0];
                              vpg_payload_shifter[7:0]  <= vpg_payload_shifter[71:64];
                          end
                          4'd2:begin //72
                              vpg_payload_shifter[87:16] <= first_category_pixels[71:0];
                              vpg_payload_shifter[15:0]  <= vpg_payload_shifter[79:64];
                          end
                          4'd3:begin //72
                              vpg_payload_shifter[95:24] <= first_category_pixels[71:0];
                              vpg_payload_shifter[23:0]  <= vpg_payload_shifter[87:64];
                          end
                          4'd4:begin //36
                              vpg_payload_shifter[67:32] <= first_category_pixels[35:0];
                              vpg_payload_shifter[31:0]  <= vpg_payload_shifter[95:64];
                          end
                          4'd5:begin //72
                              vpg_payload_shifter[75:4] <= first_category_pixels[71:0];
                              vpg_payload_shifter[3:0]  <= vpg_payload_shifter[67:64];
                          end
                          4'd6:begin //72
                              vpg_payload_shifter[83:12] <= first_category_pixels[71:0];
                              vpg_payload_shifter[11:0]  <= vpg_payload_shifter[75:64];
                          end
                          4'd7:begin //72
                              vpg_payload_shifter[91:20] <= first_category_pixels[71:0];
                              vpg_payload_shifter[19:0]  <= vpg_payload_shifter[83:64];
                          end
                          default:begin   //4'd8   //36
                              vpg_payload_shifter[63:28] <= first_category_pixels[35:0];
                              vpg_payload_shifter[27:0]   <= vpg_payload_shifter[91:64];
                          end
                      endcase
                  end
                  `CSI2_RAW16,
                  `CSI2_RAW8,
                  `CSI2_Y420_8B,
                  `CSI2_CSPS_Y420_8B,
                  `CSI2_Y422_8B,
                  `CSI2_RGB444,
                  `CSI2_RGB555,
                  `CSI2_RGB565:begin
                      vpg_payload_shifter[63:0] <= second_category_pixels[63:0];
                  end
                  `CSI2_RAW10,
                  `CSI2_RAW20,
                  `CSI2_Y420_10B,
                  `CSI2_CSPS_Y420_10B,
                  `CSI2_Y422_10B:begin
                      case(current_gen_cnt_d2_r)
                          4'd0:begin //80
                              vpg_payload_shifter[79:0] <= third_category_pixels[79:0];
                          end
                          4'd1:begin //80
                              vpg_payload_shifter[95:16] <= third_category_pixels[79:0];
                              vpg_payload_shifter[15:0]  <= vpg_payload_shifter[79:64];
                          end
                          4'd2:begin //40
                              vpg_payload_shifter[71:32] <= third_category_pixels[39:0];
                              vpg_payload_shifter[31:0]  <= vpg_payload_shifter[95:64];
                          end
                          4'd3:begin //80
                              vpg_payload_shifter[87:8]  <= third_category_pixels[79:0];
                              vpg_payload_shifter[7:0]   <= vpg_payload_shifter[71:64];
                          end
                          default:begin   //4'd4 //40
                              vpg_payload_shifter[63:24]  <= third_category_pixels[39:0];
                              vpg_payload_shifter[23:0]   <= vpg_payload_shifter[87:64];
                          end
                      endcase
                  end
                  `CSI2_RAW24,
                  `CSI2_RGB888:begin
                      case(current_gen_cnt_d2_r)
                          4'd0:begin //96
                              vpg_payload_shifter[95:0] <= fifth_category_pixels[95:0];
                          end
                          4'd1:begin //48
                              vpg_payload_shifter[79:32] <= fifth_category_pixels[47:0];
                              vpg_payload_shifter[31:0]  <= vpg_payload_shifter[95:64];
                          end
                          default:begin   //4'd2 //48
                              vpg_payload_shifter[63:16] <= fifth_category_pixels[47:0];
                              vpg_payload_shifter[15:0]  <= vpg_payload_shifter[79:64];
                          end
                      endcase
                  end
                  default:begin //`CSI2_RAW7, `CSI2_RAW14
                      case(current_gen_cnt_d2_r)
                          4'd0:begin //112
                              vpg_payload_shifter[111:0] <= fourth_category_pixels[111:0];
                          end
                          4'd1:begin //56
                              vpg_payload_shifter[103:48] <= fourth_category_pixels[55:0];
                              vpg_payload_shifter[47:0]   <= vpg_payload_shifter[111:64];
                          end
                          4'd2:begin //56
                              vpg_payload_shifter[95:40] <= fourth_category_pixels[55:0];
                              vpg_payload_shifter[39:0]   <= vpg_payload_shifter[103:64];
                          end
                          4'd3:begin //56
                              vpg_payload_shifter[87:32] <= fourth_category_pixels[55:0];
                              vpg_payload_shifter[31:0]   <= vpg_payload_shifter[95:64];
                          end
                          4'd4:begin //56
                              vpg_payload_shifter[79:24] <= fourth_category_pixels[55:0];
                              vpg_payload_shifter[23:0]   <= vpg_payload_shifter[87:64];
                          end
                          4'd5:begin //56
                              vpg_payload_shifter[71:16] <= fourth_category_pixels[55:0];
                              vpg_payload_shifter[15:0]   <= vpg_payload_shifter[79:64];
                          end
                          default:begin   //4'd6 //56
                              vpg_payload_shifter[63:8] <= fourth_category_pixels[55:0];
                              vpg_payload_shifter[7:0]   <= vpg_payload_shifter[71:64];
                          end
                      endcase
                  end
              endcase
  end //vpg_payload_shifter_64_PROC

  // spyglass disable_block W484
  // SMD: Possible assignment overflow.
  // SJ: Overflow can't occur. Protected by protocol.
  assign vpg_wc_minus1 = vpg_wc - 16'h1;
  // spyglass enable_block W484

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : vpg_wc_init_PROC
    if(~ppi_clkrstz)
        vpg_wc_init    <= 16'b0;
    else
        if(vp_req_ack)
            vpg_wc_init    <= vpg_wc_minus1;
  end //vpg_wc_init_PROC

  assign vpg_wc_init_mt_tx_num = |vpg_wc_init[15:`CSI2_DEVICE_PLD_BYTEEN_WIDTH];  //vpg_wc_init > `TX_BYTE_NUM
  assign vpg_pld_req_cnt_lt_2 = ~(|vpg_pld_req_cnt[15-`CSI2_DEVICE_PLD_BYTEEN_WIDTH:1]);  //vpg_pld_req_cnt < 2
  assign vpg_pld_1st_req_nxt  = vp_req_ack; // only video packet includes payload
  assign vpg_pld_req     = vpg_pld_1st_req | (vpg_pld_req_mt1_prd & ((~(almost_full & vpg_pld_req_1d_r)) & fullz));
  assign vpg_pld_req_pre = vp_req_ack | vpg_pld_req;
  assign buf_wr          = fullz & buf_wr_req;

  assign vpg_header_req_ack_pre2 = ~(vpg_packet_req_pre1 & (~vpg_header_req_ack_pre1));
  assign vpg_header_req_ack_pre1 = ~(vpg_packet_req      & (~vpg_header_gen_en));

  always@(posedge ppi_clk or negedge ppi_clkrstz) begin: vpg_packet_req_pre2_PROC
      if(~ppi_clkrstz)
          vpg_packet_req_pre2 <= 1'h0;
      else
          vpg_packet_req_pre2 <= vpg_packet_req_pre2_nxt;
  end //vpg_packet_req_pre2_PROC

  always@* begin: vpg_packet_req_pre2_nxt_PROC
      if(vpg_hdr_req)
          vpg_packet_req_pre2_nxt = 1'h1;
      else
          if(vpg_header_req_ack_pre2)
              vpg_packet_req_pre2_nxt = 1'h0;
          else
              vpg_packet_req_pre2_nxt = vpg_packet_req_pre2;
  end //vpg_packet_req_pre2_nxt_PROC

  always@(posedge ppi_clk or negedge ppi_clkrstz) begin: vpg_packet_req_pre1_PROC
      if(~ppi_clkrstz)
          vpg_packet_req_pre1 <= 1'h0;
      else
          vpg_packet_req_pre1 <= vpg_packet_req_pre1_nxt;
  end //vpg_packet_req_pre1_PROC

  always@* begin: vpg_packet_req_pre1_nxt_PROC
      if(vpg_packet_req_pre2)
          vpg_packet_req_pre1_nxt = 1'h1;
      else
          if(vpg_header_req_ack_pre1)
              vpg_packet_req_pre1_nxt = 1'h0;
          else
              vpg_packet_req_pre1_nxt = vpg_packet_req_pre1;
  end //vpg_packet_req_pre1_nxt_PROC

  always@(posedge ppi_clk or negedge ppi_clkrstz) begin: vpg_packet_req_PROC
      if(~ppi_clkrstz)
          vpg_packet_req <= 1'h0;
      else
          vpg_packet_req <= vpg_packet_req_nxt;
  end //vpg_packet_req_PROC

  always@* begin: vpg_packet_req_nxt_PROC
      if(vpg_packet_req_pre1)
          vpg_packet_req_nxt = 1'h1;
      else
          if(vpg_header_gen_en)
              vpg_packet_req_nxt = 1'h0;
          else
              vpg_packet_req_nxt = vpg_packet_req;
  end //vpg_packet_req_nxt_PROC

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : vpg_header_pre1_PROC
      if(~ppi_clkrstz)
          vpg_header_pre1 <= {`CSI2_DEVICE_HD_WIDTH{1'b0}};
      else
          if(vpg_header_req_ack_pre2)
              vpg_header_pre1 <= vpg_header_pre2;
  end // vpg_header_pre1_PROC

  always @ (posedge ppi_clk or negedge ppi_clkrstz) begin : vpg_header_PROC
      if(~ppi_clkrstz)
          vpg_header <= {`CSI2_DEVICE_HD_WIDTH{1'b0}};
      else
          if(vpg_header_req_ack_pre1)
              vpg_header <= vpg_header_pre1;
  end // vpg_header_PROC

  always@(posedge ppi_clk or negedge ppi_clkrstz) begin: vpg_pld_1st_req_PROC
      if(~ppi_clkrstz)
          vpg_pld_1st_req <= 1'h0;
      else
          vpg_pld_1st_req <= vpg_pld_1st_req_nxt;
  end //vpg_pld_1st_req_PROC

  always@(posedge ppi_clk or negedge ppi_clkrstz) begin: vpg_pld_req_mt1_prd_PROC
      if(~ppi_clkrstz)
          vpg_pld_req_mt1_prd <= 1'h0;
      else
          vpg_pld_req_mt1_prd <= vpg_pld_req_mt1_prd_nxt;
  end //vpg_pld_req_mt1_prd_PROC

  always@* begin: vpg_pld_req_mt1_prd_nxt_PROC
      if(vpg_pld_1st_req & vpg_wc_init_mt_tx_num)
          vpg_pld_req_mt1_prd_nxt = 1'h1;
      else
          if(vpg_pld_req_cnt_lt_2 & vpg_pld_req)
              vpg_pld_req_mt1_prd_nxt = 1'h0;
          else
              vpg_pld_req_mt1_prd_nxt = vpg_pld_req_mt1_prd;
  end //vpg_pld_req_mt1_prd_nxt_PROC

  //vpg_pld_req_cnt is derived from vpg_wc (long pkt), if (vpg_pld_req_cnt > 0), every time read payload, vpg_pld_req_cnt minus 1;
  always@(posedge ppi_clk or negedge ppi_clkrstz) begin: vpg_pld_req_cnt_PROC
      if(~ppi_clkrstz)
          vpg_pld_req_cnt <= {(16-`CSI2_DEVICE_PLD_BYTEEN_WIDTH){1'h0}};
      else
          vpg_pld_req_cnt <= vpg_pld_req_cnt_nxt;
  end // vpg_pld_req_cnt_PROC

  always@* begin: vpg_pld_req_cnt_nxt_PROC
      if(vpg_pld_1st_req)
          vpg_pld_req_cnt_nxt = vpg_wc_init[15:`CSI2_DEVICE_PLD_BYTEEN_WIDTH];
      else
          if(vpg_pld_req)
          // spyglass disable_block W484
          // SMD: Possible assignment overflow.
          // SJ: Overflow can't occur. Protected by protocol.
              vpg_pld_req_cnt_nxt = vpg_pld_req_cnt - {{(15-`CSI2_DEVICE_PLD_BYTEEN_WIDTH){1'h0}},1'h1};
          // spyglass enable_block W484
          else
              vpg_pld_req_cnt_nxt = vpg_pld_req_cnt;
  end // vpg_pld_req_cnt_nxt_PROC

  always@(posedge ppi_clk or negedge ppi_clkrstz) begin: vpg_pld_gen_end_PROC
      if(~ppi_clkrstz)
          vpg_pld_gen_end <= 1'h0;
      else
          vpg_pld_gen_end <= vpg_pld_gen_end_nxt;
  end //vpg_pld_gen_end_PROC

  always@* begin: vpg_pld_gen_end_nxt_PROC
      if(vpg_pld_1st_req & ~vpg_wc_init_mt_tx_num)
          vpg_pld_gen_end_nxt = 1'h1;
      else
          if(vpg_pld_req_mt1_prd & vpg_pld_req_cnt_lt_2 & vpg_pld_req)
              vpg_pld_gen_end_nxt = 1'h1;
          else
              vpg_pld_gen_end_nxt = 1'h0;
  end //vpg_pld_gen_end_nxt_PROC

  always@(posedge ppi_clk or negedge ppi_clkrstz) begin: buf_wr_req_PROC
      if(~ppi_clkrstz)
          buf_wr_req <= 1'h0;
      else
          buf_wr_req <= buf_wr_req_nxt;
  end // buf_wr_req_PROC

  always@* begin: buf_wr_req_nxt_PROC
      if(vpg_pld_req_1d_r)
          buf_wr_req_nxt = 1'h1;
      else
          if(buf_wr)
              buf_wr_req_nxt = 1'h0;
          else
              buf_wr_req_nxt = buf_wr_req;
  end // buf_wr_req_nxt_PROC

  as6s_app_elastbuf
   #(
    .ADDR_DEPTH (4),
    .DATA_WIDTH (`CSI2_DEVICE_NAP_PLD_WIDTH)
    )
    u_as6s_app_elastbuf (
    .clk                 ( ppi_clk                 ),  //- clock input
    .rstz                ( ppi_clkrstz             ),  //- asynchronous rstz = reset_n
    .write               ( buf_wr                  ),  //- write enable, active high
    .datain              ( vpg_pld_shift_out       ),  //- data input
    .read                ( vpg_payload_gen_en      ),  //- read enable, active high
    .dataout             ( vpg_payload             ),  //- data output

    .clrbuff             ( 1'b0                    ),  //- synchronous clear FIFO, active high
    .emptyz              ( vpg_elastbuf_emptyz     ),  //- empty, active low
    .fullz               ( fullz                   ),  //- full,  active low
    .almost_full         ( almost_full             )   //- almost full, remain 1, active high
    );

// Revision: $Id: video_pattern_generator.v 1 2024/03/28 07:41:43 GMT qiupeng Exp qiupeng $
endmodule

===FILE_END===pattern_test/video_pattern_generator.v===
===FILE_START===StdCell_Wrap.v===END_HEADER===
/////////////////////////////////////////////////
////////      STD Cell Wrap File  ///////////////
/////////////////////////////////////////////////
//V0.1 initial version, create in 2022/6/29, by yanhaitao


//timescale
`timescale 1ns/1ps

//define
//`define SIM
//`define FPGA
//`define TSMC_6NM_6T_LVT

//`define ARM_UD_MODEL
//`define UMCARM_28HPCP_9TLVT
//`define UMCARM_28HPCP_7TLVT

//CKInv_Wrap module
module CKInv_Wrap (
input A,
output ZN
);

`ifdef SIM
 assign ZN = ~A;
`elsif FPGA
      assign ZN = ~A;
   `elsif TSMC_6NM_6T_LVT
        CKND4BWP240H8P57CPDLVT U0_CKINV(
          .ZN  (ZN),
          .I   (A)
          ); 
   `elsif UMCARM_28HPCP_9TLVT
        INV_X4B_A9PP140ZTL_C35 U0_CKINV(
          .Y   (ZN),
          .A   (A)
          ); 
   `elsif UMCARM_28HPCP_7TLVT
        INV_X4B_A7PP140ZTL_C35 U0_CKINV(
          .Y   (ZN),
          .A   (A)
          ); 
     `else
          assign ZN = ~A;
`endif
endmodule
module CKInv_X16_Wrap (
input A,
output ZN
);

`ifdef SIM
 assign ZN = ~A;
`elsif FPGA
      assign ZN = ~A;
   `elsif TSMC_6NM_6T_LVT
        CKND16BWP240H8P57CPDLVT U0_CKINV(
          .ZN  (ZN),
          .I   (A)
          ); 
   `elsif UMCARM_28HPCP_9TLVT
        INV_X16B_A9PP140ZTL_C35 U0_CKINV(
          .Y   (ZN),
          .A   (A)
          ); 
   `elsif UMCARM_28HPCP_7TLVT
        INV_X16B_A7PP140ZTL_C35 U0_CKINV(
          .Y   (ZN),
          .A   (A)
          ); 
     `else
          assign ZN = ~A;
`endif
endmodule

//CKBuf_Wrap module
module CKBuf_Wrap (
input A,
output Z
);

`ifdef SIM
 assign Z = A;
`elsif FPGA
      assign Z = A;
   `elsif TSMC_6NM_6T_LVT
        CKBD4BWP240H8P57CPDLVT U0_CKBUF(
          .Z  (Z),
          .I   (A)
          ); 
   `elsif UMCARM_28HPCP_9TLVT
        BUF_X4B_A9PP140ZTL_C35 U0_CKBUF(
          .Y   (Z),
          .A   (A)
          ); 
   `elsif UMCARM_28HPCP_7TLVT
        BUF_X4B_A7PP140ZTL_C35 U0_CKBUF(
          .Y   (Z),
          .A   (A)
          ); 
   `else
          assign Z = A;
`endif
endmodule

//CKBuf_Wrap module
//CKBuf_Wrap_X16 module
module CKBuf_X16_Wrap (
input A,
output Z
);

`ifdef SIM
 assign Z = A;
`elsif FPGA
      assign Z = A;
   `elsif TSMC_6NM_6T_LVT
        CKBD16BWP240H8P57CPDLVT U0_CKBUF(
          .Z  (Z),
          .I   (A)
          ); 
   `elsif UMCARM_28HPCP_9TLVT
        BUF_X16B_A9PP140ZTL_C35 U0_CKBUF(
          .Y   (Z),
          .A   (A)
          ); 
   `elsif UMCARM_28HPCP_7TLVT
        BUF_X16B_A7PP140ZTL_C35 U0_CKBUF(
          .Y   (Z),
          .A   (A)
          ); 
   `else
          assign Z = A;
`endif
endmodule

//CKBuf_Wrap X16 module


module OCC_BUF_Wrap (
input A,
input PIN_SCN,
input PIN_SCN_CLK,
output Z
);

`ifdef SIM
 assign Z = A;
`elsif FPGA
      assign Z = A;
   `elsif TSMC_6NM_6T_LVT
        CKBD4BWP240H8P57CPDLVT U0_CKBUF(
          .Z  (Z),
          .I   (A)
          ); 
   `elsif UMCARM_28HPCP_9TLVT
        BUF_X4B_A9PP140ZTL_C35 U0_CKBUF(
          .Y   (Z),
          .A   (A)
          ); 
   `elsif UMCARM_28HPCP_7TLVT
        BUF_X4B_A7PP140ZTL_C35 U0_CKBUF(
          .Y   (Z),
          .A   (A)
          ); 
   `else
          assign Z = A;
`endif
endmodule

//CKAnd2_Wrap module
module CKAnd2_Wrap (
input A1,
input A2,
output Z
);

`ifdef SIM
 assign Z = A1 && A2;
`elsif FPGA
      assign Z = A1 && A2;
   `elsif TSMC_6NM_6T_LVT
        CKAN2D4BWP240H8P57CPDLVT U0_CKAND2(
          .Z  (Z),
          .A1 (A1),
          .A2 (A2)
          ); 
   `elsif UMCARM_28HPCP_9TLVT
        AND2_X4B_A9PP140ZTL_C35 U0_CKAND2(
          .Y   (Z),
          .A   (A1),
          .B   (A2)
          ); 
   `elsif UMCARM_28HPCP_7TLVT
        AND2_X4B_A7PP140ZTL_C35 U0_CKAND2(
          .Y   (Z),
          .A   (A1),
          .B   (A2)
          ); 
         `else
          assign Z = A1 && A2;
`endif
endmodule
//CKNor2_Wrap modul
module CKNor2_Wrap (
input A,
input B,
output Y
);
`ifdef SIM
 assign Y = !(A | B);
 `elsif UMCARM_28HPCP_7TLVT
    NOR2_X4B_A7PP140ZTL_C35 U0_CKNOR2(
        .Y(Y),
        .A(A),
        .B(B)
    );
  `else
    assign Y = !(A | B);
`endif
endmodule
//CKNand2_Wrap module
module CKNand2_Wrap (
input A,
input B,
output ZN
);

`ifdef SIM
 assign ZN = !(A && B);
`elsif FPGA
      assign ZN = !(A && B);
   `elsif TSMC_6NM_6T_LVT
        CKNAN2D4BWP240H8P57CPDLVT U0_CKNAND2(
          .ZN (ZN),
          .A1 (A),
          .A2 (B)
          ); 
   `elsif UMCARM_28HPCP_9TLVT
        NAND2_X4B_A9PP140ZTL_C35 U0_CKNAND2(
          .Y   (ZN),
          .A   (A),
          .B   (B)
          ); 
   `elsif UMCARM_28HPCP_7TLVT
        NAND2_X4B_A7PP140ZTL_C35 U0_CKNAND2(
          .Y   (ZN),
          .A   (A),
          .B   (B)
          ); 
         `else
          assign ZN = !(A && B);
`endif
endmodule

//CKOr2_Wrap module
module CKOr2_Wrap (
input A1,
input A2,
output Z
);

`ifdef SIM
 assign Z = A1 || A2;
`elsif FPGA
      assign Z = A1 || A2;  //fpga no clockor
   `elsif TSMC_6NM_6T_LVT
        CKOR2D4BWP240H8P57CPDLVT U0_CKOR2(
          .Z  (Z),
          .A1 (A1),
          .A2 (A2)
          ); 
   `elsif UMCARM_28HPCP_9TLVT
        OR2_X4B_A9PP140ZTL_C35 U0_CKOR2(
          .Y   (Z),
          .A   (A1),
          .B   (A2)
          ); 
   `elsif UMCARM_28HPCP_7TLVT
        OR2_X4B_A7PP140ZTL_C35 U0_CKOR2(
          .Y   (Z),
          .A   (A1),
          .B   (A2)
          ); 
         `else
          assign Z = A1 || A2;
`endif
endmodule

//CKMux2_Wrap module
module CKMux2_Wrap (
input A,
input B,
input S,
output Z
);

`ifdef SIM
 assign Z = S ? B : A;
`elsif FPGA
    //default sel clock mux, "defparam" can synthesis by vivado
    parameter [1:0] SEL = 2'd2;  
    generate 
        if (SEL == 2'd0) begin : sel_clock_a
            assign Z = A;
        end else if (SEL == 2'd1) begin : sel_clock_b
            assign Z = B;
        end else if (SEL == 2'd2) begin : clock_mux
            assign Z = S ? B : A;
        end else begin : clock_bufg_mux  //fpga SYNC MUX
            `ifdef FPGA_SIM
              assign Z = S ? B : A;
            `else
              BUFGMUX #(.CLK_SEL_TYPE("SYNC")) BUFGMUX_inst (.O(Z), .I0(A), .I1(B), .S(S));
            `endif
        end
    endgenerate

   `elsif TSMC_6NM_6T_LVT
        CKMUX2D4BWP240H8P57CPDLVT U0_CKMUX2(
          .Z  (Z),
          .I0 (A),
          .I1 (B),
          .S  (S )
          ); 
   `elsif UMCARM_28HPCP_9TLVT
        MX2_X4B_A9PP140ZTL_C35 U0_CKMUX2(
          .Y   (Z),
          .A   (A),
          .B   (B),
          .S0  (S)
          ); 
   `elsif UMCARM_28HPCP_7TLVT
        MX2_X4B_A7PP140ZTL_C35 U0_CKMUX2(
          .Y   (Z),
          .A   (A),
          .B   (B),
          .S0  (S)
          ); 
         `else
          assign Z = S ? B : A;
`endif
endmodule

//Inv_Wrap module
module Inv_Wrap (
input A,
output ZN
);

`ifdef SIM
 assign ZN = ~A;
`elsif FPGA
      assign ZN = ~A;
   `elsif TSMC_6NM_6T_LVT
        INVD1BWP240H8P57CPDLVT U0_INV(
          .ZN  (ZN),
          .I   (A)
          ); 
   `elsif UMCARM_28HPCP_9TLVT
        INV_X4B_A9PP140ZTL_C35 U0_INV(
          .Y   (ZN),
          .A   (A)
          ); 
   `elsif UMCARM_28HPCP_7TLVT
        INV_X4B_A7PP140ZTL_C35 U0_INV(
          .Y   (ZN),
          .A   (A)
          ); 
         `else
          assign ZN = ~A;
`endif
endmodule

//Inv_Wrap module
module Inv_X16_Wrap (
input A,
output ZN
);

`ifdef SIM
 assign ZN = ~A;
`elsif FPGA
      assign ZN = ~A;
   `elsif TSMC_6NM_6T_LVT
        INVD16BWP240H8P57CPDLVT U0_INV(
          .ZN  (ZN),
          .I   (A)
          ); 
   `elsif UMCARM_28HPCP_9TLVT
        INV_X16B_A9PP140ZTL_C35 U0_INV(
          .Y   (ZN),
          .A   (A)
          ); 
   `elsif UMCARM_28HPCP_7TLVT
        INV_X16B_A7PP140ZTL_C35 U0_INV(
          .Y   (ZN),
          .A   (A)
          ); 
         `else
          assign ZN = ~A;
`endif
endmodule

//Buf_Wrap module
module Buf_Wrap (
input A,
output Z
);

`ifdef SIM
 assign Z = A;
`elsif FPGA
      assign Z = A;
   `elsif TSMC_6NM_6T_LVT
        BUFFD1BWP240H8P57CPDLVT U0_BUF(
          .Z  (Z),
          .I   (A)
          ); 
   `elsif UMCARM_28HPCP_9TLVT
        BUF_X4B_A9PP140ZTL_C35 U0_BUF(
          .Y   (Z),
          .A   (A)
          ); 
   `elsif UMCARM_28HPCP_7TLVT
        BUF_X4B_A7PP140ZTL_C35 U0_BUF(
          .Y   (Z),
          .A   (A)
          ); 
         `else
          assign Z = A;
`endif
endmodule

//and2_Wrap module
module And2_Wrap (
input A,
input B,
output Z
);

`ifdef SIM
 assign Z = A && B;
`elsif FPGA
      assign Z = A && B;
   `elsif TSMC_6NM_6T_LVT
        AN2D4BWP240H8P57CPDLVT U0_AND2(
          .Z  (Z),
          .A1 (A),
          .A2 (B)
          ); 
   `elsif UMCARM_28HPCP_9TLVT
        AND2_X4B_A9PP140ZTL_C35 U0_AND2(
          .Y   (Z),
          .A   (A),
          .B   (B)
          ); 
   `elsif UMCARM_28HPCP_7TLVT
        AND2_X4B_A7PP140ZTL_C35 U0_AND2(
          .Y   (Z),
          .A   (A),
          .B   (B)
          ); 
         `else
          assign Z = A && B;
`endif
endmodule

//Nand2_Wrap module
module Nand2_Wrap (
input A,
input B,
output ZN
);

`ifdef SIM
 assign ZN = !(A && B);
`elsif FPGA
      assign ZN = !(A && B);
   `elsif TSMC_6NM_6T_LVT
        NAN2D4BWP240H8P57CPDLVT U0_NAND2(
          .ZN (ZN),
          .A1 (A),
          .A2 (B)
          ); 
   `elsif UMCARM_28HPCP_9TLVT
        NAND2_X4B_A9PP140ZTL_C35 U0_NAND2(
          .Y   (ZN),
          .A   (A),
          .B   (B)
          ); 
   `elsif UMCARM_28HPCP_7TLVT
        NAND2_X4B_A7PP140ZTL_C35 U0_NAND2(
          .Y   (ZN),
          .A   (A),
          .B   (B)
          ); 
         `else
          assign ZN = !(A && B);
`endif
endmodule

//Or2_Wrap module
module Or2_Wrap (
input A1,
input A2,
output Z
);

`ifdef SIM
 assign Z = A1 || A2;
`elsif FPGA
      assign Z = A1 || A2;
   `elsif TSMC_6NM_6T_LVT
        OR2D4BWP240H8P57CPDLVT U0_OR2(
          .Z  (Z),
          .A1 (A1),
          .A2 (A2)
          ); 
   `elsif UMCARM_28HPCP_9TLVT
        OR2_X4B_A9PP140ZTL_C35 U0_OR2(
          .Y   (Z),
          .A   (A1),
          .B   (A2)
          ); 
   `elsif UMCARM_28HPCP_7TLVT
        OR2_X4B_A7PP140ZTL_C35 U0_OR2(
          .Y   (Z),
          .A   (A1),
          .B   (A2)
          ); 
         `else
          assign Z = A1 || A2;
`endif
endmodule

//Mux2_Wrap module
module Mux2_Wrap (
input A,
input B,
input S,
output Z
);

`ifdef SIM
 assign Z = S ? B : A;
`elsif FPGA
      assign Z = S ? B : A;
   `elsif TSMC_6NM_6T_LVT
        MUX2D1BWP240H8P57CPDLVT U0_MUX2(
          .Z  (Z),
          .I0 (A),
          .I1 (B),
          .S  (S )
          ); 
   `elsif UMCARM_28HPCP_9TLVT
        MX2_X4B_A9PP140ZTL_C35 U0_MUX2(
          .Y   (Z),
          .A   (A),
          .B   (B),
          .S0  (S)
          ); 
   `elsif UMCARM_28HPCP_7TLVT
        MX2_X4B_A7PP140ZTL_C35 U0_MUX2(
          .Y   (Z),
          .A   (A),
          .B   (B),
          .S0  (S)
          ); 
         `else
          assign Z = S ? B : A;
`endif
endmodule

//SDFRPQ_Wrap module
module SDFRPQ_Wrap (
input CP,
input D,
input CD,
output Q
);

`ifdef SIM
  reg Q_Int;
  always @(posedge CP or posedge CD) begin 
    if(CD == 1'b1) begin
      Q_Int <= 1'b0;
    end else begin
      Q_Int <= D;
      end
  end
  assign Q = Q_Int;
`elsif FPGA
      reg Q_Int;
      always @(posedge CP or posedge CD) begin 
           if(CD == 1'b1) begin
             Q_Int <= 1'b0;
           end else begin
             Q_Int <= D;
             end
         end
       assign Q = Q_Int;
   `elsif TSMC_6NM_6T_LVT
          wire Q_Int;
        SDFRPQD1BWP240H8P57CPDLVT U0_SDFRPQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (D),
          .CP (CP ),
          .CD (CD),
          .Q  (Q_Int)
          ); 
         assign Q = Q_Int;
   `elsif UMCARM_28HPCP_9TLVT
          wire Q_Int;
          wire CD_Int;
        SDFFRPQ_X1M_A9PP140ZTL_C35 U0_SDFRPQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (D),
          .CK   (CP),
          .R    (CD),
          .Q    (Q_Int)
          ); 
         assign Q = Q_Int;
//         assign CD = ~CD_Int;
   `elsif UMCARM_28HPCP_7TLVT
          wire Q_Int;
          wire CD_Int;
        SDFFRPQ_X1M_A7PP140ZTL_C35 U0_SDFRPQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (D),
          .CK   (CP),
          .R    (CD),
          .Q    (Q_Int)
          ); 
         assign Q = Q_Int;
//         assign CD = ~CD_Int;
         `else
          reg Q_Int;
          always @(posedge CP or posedge CD) begin 
            if(CD == 1'b1) begin
              Q_Int <= 1'b0;
            end else begin
              Q_Int <= D;
              end
          end
         assign Q = Q_Int;
`endif
endmodule

//SDFRNQ_Wrap module
module SDFRNQ_Wrap (
input CP,
input D,
input CDN,
output Q
);

`ifdef SIM
  reg Q_Int;
  always @(posedge CP or negedge CDN) begin 
    if(CDN == 1'b0) begin
      Q_Int <= 1'b0;
    end else begin
      Q_Int <= D;
      end
  end
  assign Q = Q_Int;
`elsif FPGA
      reg Q_Int;
      always @(posedge CP or negedge CDN) begin 
           if(CDN == 1'b0) begin
             Q_Int <= 1'b0;
           end else begin
             Q_Int <= D;
             end
         end
       assign Q = Q_Int;
   `elsif TSMC_6NM_6T_LVT
          wire Q_Int;
        SDFRPQD1BWP240H8P57CPDLVT U0_SDFRPQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (D),
          .CP (CP ),
          .CD (~CDN),
          .Q  (Q_Int)
          ); 
         assign Q = Q_Int;
   `elsif UMCARM_28HPCP_9TLVT
          wire Q_Int;
          wire CD_Int;
        SDFFRPQ_X1M_A9PP140ZTL_C35 U0_SDFRPQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (D),
          .CK   (CP),
          .R    (~CDN),
          .Q    (Q_Int)
          ); 
         assign Q = Q_Int;
//         assign CD = ~CD_Int;
   `elsif UMCARM_28HPCP_7TLVT
          wire Q_Int;
          wire CD_Int;
          wire CD;
        INV_X2B_A7PP140ZTL_C35 U_CDN(.Y(CD), .A(CDN));
        SDFFRPQ_X1M_A7PP140ZTL_C35 U0_SDFRPQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (D),
          .CK   (CP),
          .R    (CD),
          .Q    (Q_Int)
          ); 
         assign Q = Q_Int;
//         assign CD = ~CD_Int;
         `else
          reg Q_Int;
          always @(posedge CP or posedge CDN) begin 
            if(CDN == 1'b1) begin
              Q_Int <= 1'b0;
            end else begin
              Q_Int <= D;
              end
          end
         assign Q = Q_Int;
`endif
endmodule

//SDFSNQ_Wrap module
module SDFSNQ_Wrap (
input CP,
input D,
input SDN,
output Q
);

`ifdef SIM
  reg Q_Int;
  always @(posedge CP or negedge SDN) begin 
    if(SDN == 1'b0) begin
      Q_Int <= 1'b1;
    end else begin
      Q_Int <= D;
      end
  end
  assign Q = Q_Int;
`elsif FPGA
      reg Q_Int;
      always @(posedge CP or negedge SDN) begin 
           if(SDN == 1'b0) begin
             Q_Int <= 1'b1;
           end else begin
             Q_Int <= D;
             end
         end
       assign Q = Q_Int;
   `elsif TSMC_6NM_6T_LVT
          wire Q_Int;
        SDFSNQD1BWP240H8P57CPDLVT U0_SDFSNQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (D),
          .CP (CP ),
          .SDN (SDN),
          .Q  (Q_Int)
          ); 
         assign Q = Q_Int;
   `elsif UMCARM_28HPCP_9TLVT
          wire Q_Int;
        SDFFSQ_X1M_A9PP140ZTL_C35 U0_SDFSNQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (D),
          .CK   (CP),
          .SN   (SDN),
          .Q    (Q_Int)
          ); 
         assign Q = Q_Int;
   `elsif UMCARM_28HPCP_7TLVT
          wire Q_Int;
        SDFFSQ_X1M_A7PP140ZTL_C35 U0_SDFSNQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (D),
          .CK   (CP),
          .SN   (SDN),
          .Q    (Q_Int)
          ); 
         assign Q = Q_Int;
         `else
          reg Q_Int;
          always @(posedge CP or negedge SDN) begin 
            if(SDN == 1'b0) begin
              Q_Int <= 1'b1;
            end else begin
              Q_Int <= D;
              end
          end
         assign Q = Q_Int;
`endif
endmodule

//CKLN_Wrap module
module CKLN_Wrap (
input CP,
input E,
input TE,
output Q
);

`ifdef SIM
  wire E_Int;
  reg Q_Int;
  assign E_Int = E || TE;
  always @(*) begin 
      if (CP == 1'b0) begin 
      Q_Int <= E_Int;
        end
      end
  assign Q = Q_Int && CP;
`elsif FPGA
    reg Q_Int;
    always @(posedge CP) begin
        Q_Int <= (E || TE);    //use ff, no latch
    end
    //default no clock gating, "defparam" can synthesis by vivado
    parameter [1:0] SEL = 2'd0; 
    generate
        if (SEL == 2'd0) begin : no_gating
            assign Q = CP;
        end else if (SEL == 2'd1) begin : sel_gate
            assign Q = Q_Int && CP;
        end else if (SEL == 2'd2) begin : sel_bufgce
            `ifdef FPGA_SIM
                assign Q = Q_Int && CP;
            `else
                BUFGCE #(.CE_TYPE("SYNC"),.IS_CE_INVERTED(1'b0),.IS_I_INVERTED(1'b0),.SIM_DEVICE("ULTRASCALE_PLUS")) BUFGCE_inst (.O(Q),.CE(E || TE),.I(CP));
            `endif
        end else begin : sel_bufg
            `ifdef FPGA_SIM
                assign Q = CP;
            `else
                BUFG BUFG_inst (.O(Q), .I(CP));
            `endif
        end
    endgenerate

   `elsif TSMC_6NM_6T_LVT
          wire Q_Int;
        CKLNQD4BWP240H8P57CPDLVT U0_CKLN(
          .CP (CP ),
          .E  (E),
          .TE (TE),
          .Q  (Q_Int)
          ); 
         assign Q = Q_Int;
   `elsif UMCARM_28HPCP_9TLVT
          wire Q_Int;
        PREICG_X4B_A9PP140ZTL_C35 U0_CKLN(
          .CK   (CP),
          .E   (E),
          .SE   (TE),
          .ECK   (Q_Int)
          ); 
         assign Q = Q_Int;
   `elsif UMCARM_28HPCP_7TLVT
          wire Q_Int;
        PREICG_X4B_A7PP140ZTL_C35 U0_CKLN(
          .CK   (CP),
          .E   (E),
          .SE   (TE),
          .ECK   (Q_Int)
          ); 
         assign Q = Q_Int;
         `else
            wire E_Int;
            reg Q_Int;
            assign E_Int = E || TE;
            always @(*) begin 
                if (CP == 1'b0) begin 
                Q_Int = E_Int;
                  end
                end
            assign Q = Q_Int && CP;
`endif
endmodule


//CKLH_Wrap module
module CKLH_Wrap (
input CPN,
input E,
input TE,
output Q
);

`ifdef SIM
  wire E_Int;
  reg Q_Int;
  assign E_Int = E || TE;
  always @(*) begin 
      if (CPN == 1'b1) begin 
      Q_Int <= E_Int;
        end
      end
  assign Q = (~Q_Int) || CPN;
`elsif FPGA
       wire E_Int;
       reg Q_Int;
       assign E_Int = E || TE;
       always @(*) begin 
           if (CPN == 1'b1) begin 
           Q_Int <= E_Int;
             end
           end
       assign Q = (~Q_Int) || CPN;
   `elsif TSMC_6NM_6T_LVT
          wire Q_Int;
        CKLHQD4BWP240H8P57CPDLVT U0_CKLH(
          .CPN (CPN ),
          .E  (E),
          .TE (TE),
          .Q  (Q_Int)
          ); 
         assign Q = Q_Int;
   `elsif UMCARM_28HPCP_9TLVT
          wire Q_Int;
        PREICGN_X4B_A9PP140ZTL_C35 U0_CKLH(
          .CK   (CPN),
          .E    (E),
          .SE   (TE),
          .ECK  (Q_Int)
          ); 
         assign Q = Q_Int;
   `elsif UMCARM_28HPCP_7TLVT
          wire Q_Int;
        PREICGN_X4B_A7PP140ZTL_C35 U0_CKLH(
          .CK   (CPN),
          .E    (E),
          .SE   (TE),
          .ECK  (Q_Int)
          ); 
         assign Q = Q_Int;
         `else
            wire E_Int;
            reg Q_Int;
            assign E_Int = E || TE;
            always @(*) begin 
                if (CPN == 1'b1) begin 
                Q_Int = E_Int;
                  end
                end
            assign Q = (~Q_Int) || CPN;
`endif
endmodule

//SDFSYNC2RPQ_Wrap module
module SDFSYNC2RPQ_Wrap (
input CP_S,
input CP_D,
input D,
input CD_S,
input CD_D,
output Q
);

`ifdef SIM
  reg QS_Int;
  reg QD1_Int;
  reg QD2_Int;
  always @(posedge CP_S or posedge CD_S) begin 
    if(CD_S == 1'b1) begin
      QS_Int <= 1'b0;
    end else begin
      QS_Int <= D;
      end
  end
  always @(posedge CP_D or posedge CD_D) begin 
    if(CD_D == 1'b1) begin
      QD1_Int <= 1'b0;
      QD2_Int <= 1'b0;
    end else begin
      QD1_Int <= QS_Int;
      QD2_Int <= QD1_Int;
      end
  end
  assign Q = QD2_Int;
`elsif FPGA
        reg QS_Int;
        reg QD1_Int;
        reg QD2_Int;
        always @(posedge CP_S or posedge CD_S) begin 
          if(CD_S == 1'b1) begin
            QS_Int <= 1'b0;
          end else begin
            QS_Int <= D;
            end
        end
        always @(posedge CP_D or posedge CD_D) begin 
          if(CD_D == 1'b1) begin
            QD1_Int <= 1'b0;
            QD2_Int <= 1'b0;
          end else begin
            QD1_Int <= QS_Int;
            QD2_Int <= QD1_Int;
            end
        end
  assign Q = QD2_Int;
   `elsif TSMC_6NM_6T_LVT
          wire QS_Int;
          wire QD1_Int;
          wire QD2_Int;
        SDFSYNC1RPQD1BWP240H8P57CPDLVT U0_SDFRPQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (D),
          .CP (CP_S),
          .CD (CD_S),
          .Q  (QS_Int)
          ); 
        SDFSYNC1RPQD1BWP240H8P57CPDLVT U1_SDFRPQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (QS_Int),
          .CP (CP_D),
          .CD (CD_D),
          .Q  (QD1_Int)
          ); 
        SDFSYNC1RPQD1BWP240H8P57CPDLVT U2_SDFRPQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (QD1_Int),
          .CP (CP_D),
          .CD (CD_D),
          .Q  (QD2_Int)
          ); 
         assign Q = QD2_Int;
   `elsif UMCARM_28HPCP_9TLVT
          wire QS_Int;
          wire QD2_Int;
          wire CD_S_Int;
          wire CD_D_Int;
        SDFFRPQ_X1M_A9PP140ZTL_C35 U0_SDFRPQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (D),
          .CK   (CP_S),
          .R    (CD_S_Int),
          .Q    (QS_Int)
          ); 
        SDFFYRPQ2D_X1M_A9PP140ZTL_C35 U1_SDFRPQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (QS_Int),
          .CK   (CP_D),
          .R   (CD_D_Int),
          .Q   (QD2_Int)
          ); 
         assign Q = QD2_Int;
         assign CD_S_Int = CD_S;
         assign CD_D_Int = CD_D;
   `elsif UMCARM_28HPCP_7TLVT
          wire QS_Int;
          wire QD2_Int;
          wire CD_S_Int;
          wire CD_D_Int;
        SDFFRPQ_X1M_A7PP140ZTL_C35 U0_SDFRPQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (D),
          .CK   (CP_S),
          .R    (CD_S_Int),
          .Q    (QS_Int)
          ); 
        SDFFYRPQ2D_X1M_A7PP140ZTL_C35 U1_SDFRPQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (QS_Int),
          .CK   (CP_D),
          .R   (CD_D_Int),
          .Q   (QD2_Int)
          ); 
         assign Q = QD2_Int;
         assign CD_S_Int = CD_S;
         assign CD_D_Int = CD_D;
         `else
              reg QS_Int;
              reg QD1_Int;
              reg QD2_Int;
              always @(posedge CP_S or posedge CD_S) begin 
                if(CD_S == 1'b1) begin
                  QS_Int <= 1'b0;
                end else begin
                  QS_Int <= D;
                  end
              end
              always @(posedge CP_D or posedge CD_D) begin 
                if(CD_D == 1'b1) begin
                  QD1_Int <= 1'b0;
                  QD2_Int <= 1'b0;
                end else begin
                  QD1_Int <= QS_Int;
                  QD2_Int <= QD1_Int;
                  end
              end
              assign Q = QD2_Int;
`endif
endmodule

//SDFSYNC2RNQ_Wrap module
module SDFSYNC2RNQ_Wrap (
input CP_S,
input CP_D,
input D,
input CDN_S,
input CDN_D,
output Q
);

`ifdef SIM
  reg QS_Int;
  reg QD1_Int;
  reg QD2_Int;
  always @(posedge CP_S or posedge CDN_S) begin 
    if(CDN_S == 1'b0) begin
      QS_Int <= 1'b0;
    end else begin
      QS_Int <= D;
      end
  end
  always @(posedge CP_D or posedge CDN_D) begin 
    if(CDN_D == 1'b0) begin
      QD1_Int <= 1'b0;
      QD2_Int <= 1'b0;
    end else begin
      QD1_Int <= QS_Int;
      QD2_Int <= QD1_Int;
      end
  end
  assign Q = QD2_Int;
`elsif FPGA
        reg QS_Int;
        reg QD1_Int;
        reg QD2_Int;
        always @(posedge CP_S or posedge CDN_S) begin 
          if(CDN_S == 1'b0) begin
            QS_Int <= 1'b0;
          end else begin
            QS_Int <= D;
            end
        end
        always @(posedge CP_D or posedge CDN_D) begin 
          if(CDN_D == 1'b0) begin
            QD1_Int <= 1'b0;
            QD2_Int <= 1'b0;
          end else begin
            QD1_Int <= QS_Int;
            QD2_Int <= QD1_Int;
            end
        end
  assign Q = QD2_Int;
   `elsif TSMC_6NM_6T_LVT
          wire QS_Int;
          wire QD1_Int;
          wire QD2_Int;
        SDFSYNC1RPQD1BWP240H8P57CPDLVT U0_SDFRPQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (D),
          .CP (CP_S),
          .CD (~CDN_S),
          .Q  (QS_Int)
          ); 
        SDFSYNC1RPQD1BWP240H8P57CPDLVT U1_SDFRPQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (QS_Int),
          .CP (CP_D),
          .CD (~CD_D),
          .Q  (QD1_Int)
          ); 
        SDFSYNC1RPQD1BWP240H8P57CPDLVT U2_SDFRPQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (QD1_Int),
          .CP (CP_D),
          .CD (~CD_D),
          .Q  (QD2_Int)
          ); 
         assign Q = QD2_Int;
   `elsif UMCARM_28HPCP_9TLVT
          wire QS_Int;
          wire QD2_Int;
          wire CD_S_Int;
          wire CD_D_Int;
        SDFFRPQ_X1M_A9PP140ZTL_C35 U0_SDFRPQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (D),
          .CK   (CP_S),
          .R    (CD_S_Int),
          .Q    (QS_Int)
          ); 
        SDFFYRPQ2D_X1M_A9PP140ZTL_C35 U1_SDFRPQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (QS_Int),
          .CK   (CP_D),
          .R   (CD_D_Int),
          .Q   (QD2_Int)
          ); 
         assign Q = QD2_Int;
         assign CD_S_Int = ~CDN_S;
         assign CD_D_Int = ~CDN_D;
   `elsif UMCARM_28HPCP_7TLVT
          wire QS_Int;
          wire QD2_Int;
          wire CD_S_Int;
          wire CD_D_Int;
        SDFFRPQ_X1M_A7PP140ZTL_C35 U0_SDFRPQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (D),
          .CK   (CP_S),
          .R    (CD_S_Int),
          .Q    (QS_Int)
          ); 
        SDFFYRPQ2D_X1M_A7PP140ZTL_C35 U1_SDFRPQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (QS_Int),
          .CK   (CP_D),
          .R   (CD_D_Int),
          .Q   (QD2_Int)
          ); 
         assign Q = QD2_Int;
         assign CD_S_Int = ~CDN_S;
         assign CD_D_Int = ~CDN_D;
         `else
              reg QS_Int;
              reg QD1_Int;
              reg QD2_Int;
              always @(posedge CP_S or posedge CDN_S) begin 
                if(CDN_S == 1'b0) begin
                  QS_Int <= 1'b0;
                end else begin
                  QS_Int <= D;
                  end
              end
              always @(posedge CP_D or posedge CDN_D) begin 
                if(CDN_D == 1'b0) begin
                  QD1_Int <= 1'b0;
                  QD2_Int <= 1'b0;
                end else begin
                  QD1_Int <= QS_Int;
                  QD2_Int <= QD1_Int;
                  end
              end
              assign Q = QD2_Int;
`endif
endmodule

//SDFSYNC2SNQ_Wrap module
module SDFSYNC2SNQ_Wrap (
input CP_S,
input CP_D,
input D,
input SDN_S,
input SDN_D,
output Q
);

`ifdef SIM
  reg QS_Int;
  reg QD1_Int;
  reg QD2_Int;
  always @(posedge CP_S or negedge SDN_S) begin 
    if(SDN_S == 1'b0) begin
      QS_Int <= 1'b1;
    end else begin
      QS_Int <= D;
      end
  end
  always @(posedge CP_D or negedge SDN_D) begin 
    if(SDN_D == 1'b0) begin
      QD1_Int <= 1'b1;
      QD2_Int <= 1'b1;
    end else begin
      QD1_Int <= QS_Int;
      QD2_Int <= QD1_Int;
      end
  end
  assign Q = QD2_Int;
`elsif FPGA
        reg QS_Int;
        reg QD1_Int;
        reg QD2_Int;
        always @(posedge CP_S or negedge SDN_S) begin 
          if(SDN_S == 1'b0) begin
            QS_Int <= 1'b1;
          end else begin
            QS_Int <= D;
            end
        end
        always @(posedge CP_D or negedge SDN_D) begin 
          if(SDN_D == 1'b0) begin
            QD1_Int <= 1'b1;
            QD2_Int <= 1'b1;
          end else begin
            QD1_Int <= QS_Int;
            QD2_Int <= QD1_Int;
            end
        end
  assign Q = QD2_Int;
   `elsif TSMC_6NM_6T_LVT
          wire QS_Int;
          wire QD1_Int;
          wire QD2_Int;
        SDFSYNC1SNQD1BWP240H8P57CPDLVT U0_SDFSYNC1SNQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (D),
          .CP (CP_S),
          .SDN (SDN_S),
          .Q  (QS_Int)
          ); 
        SDFSYNC1SNQD1BWP240H8P57CPDLVT U1_SDFSYNC1SNQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (QS_Int),
          .CP (CP_D),
          .SDN (SDN_D),
          .Q  (QD1_Int)
          ); 
        SDFSYNC1SNQD1BWP240H8P57CPDLVT U2_SDFSYNC1SNQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (QD1_Int),
          .CP (CP_D),
          .SDN (SDN_D),
          .Q  (QD2_Int)
          ); 
         assign Q = QD2_Int;
   `elsif UMCARM_28HPCP_9TLVT
          wire QS_Int;
          wire QD2_Int;
        SDFFSQ_X1M_A9PP140ZTL_C35 U0_SDFSYNC1SNQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (D),
          .CK   (CP_S),
          .SN   (SDN_S),
          .Q    (QS_Int)
          ); 
        SDFFYSQ2D_X1M_A9PP140ZTL_C35 U1_SDFSYNC1SNQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (QS_Int),
          .CK   (CP_D),
          .SN   (SDN_D),
          .Q   (QD2_Int)
          ); 
         assign Q = QD2_Int;
   `elsif UMCARM_28HPCP_7TLVT
          wire QS_Int;
          wire QD2_Int;
        SDFFSQ_X1M_A7PP140ZTL_C35 U0_SDFSYNC1SNQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (D),
          .CK   (CP_S),
          .SN   (SDN_S),
          .Q    (QS_Int)
          ); 
        SDFFYSQ2D_X1M_A7PP140ZTL_C35 U1_SDFSYNC1SNQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (QS_Int),
          .CK   (CP_D),
          .SN   (SDN_D),
          .Q   (QD2_Int)
          ); 
         assign Q = QD2_Int;
         `else
              reg QS_Int;
              reg QD1_Int;
              reg QD2_Int;
              always @(posedge CP_S or negedge SDN_S) begin 
                if(SDN_S == 1'b0) begin
                  QS_Int <= 1'b1;
                end else begin
                  QS_Int <= D;
                  end
              end
              always @(posedge CP_D or negedge SDN_D) begin 
                if(SDN_D == 1'b0) begin
                  QD1_Int <= 1'b1;
                  QD2_Int <= 1'b1;
                end else begin
                  QD1_Int <= QS_Int;
                  QD2_Int <= QD1_Int;
                  end
              end
              assign Q = QD2_Int;
`endif
endmodule

//SDFSYNC3RPQ_Wrap module
module SDFSYNC3RPQ_Wrap (
input CP_S,
input CP_D,
input D,
input CD_S,
input CD_D,
output Q
);

`ifdef SIM
  reg QS_Int;
  reg QD1_Int;
  reg QD2_Int;
  reg QD3_Int;
  always @(posedge CP_S or posedge CD_S) begin 
    if(CD_S == 1'b1) begin
      QS_Int <= 1'b0;
    end else begin
      QS_Int <= D;
      end
  end
  always @(posedge CP_D or posedge CD_D) begin 
    if(CD_D == 1'b1) begin
      QD1_Int <= 1'b0;
      QD2_Int <= 1'b0;
      QD3_Int <= 1'b0;
    end else begin
      QD1_Int <= QS_Int;
      QD2_Int <= QD1_Int;
      QD3_Int <= QD2_Int;
      end
  end
  assign Q = QD3_Int;
`elsif FPGA
        reg QS_Int;
        reg QD1_Int;
        reg QD2_Int;
        reg QD3_Int;
        always @(posedge CP_S or posedge CD_S) begin 
          if(CD_S == 1'b1) begin
            QS_Int <= 1'b0;
          end else begin
            QS_Int <= D;
            end
        end
        always @(posedge CP_D or posedge CD_D) begin 
          if(CD_D == 1'b1) begin
            QD1_Int <= 1'b0;
            QD2_Int <= 1'b0;
            QD3_Int <= 1'b0;
          end else begin
            QD1_Int <= QS_Int;
            QD2_Int <= QD1_Int;
            QD3_Int <= QD2_Int;
            end
        end
  assign Q = QD3_Int;
   `elsif TSMC_6NM_6T_LVT
          wire QS_Int;
          wire QD1_Int;
          wire QD2_Int;
          wire QD3_Int;
        SDFSYNC1RPQD1BWP240H8P57CPDLVT U0_SDFRPQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (D),
          .CP (CP_S),
          .CD (CD_S),
          .Q  (QS_Int)
          ); 
        SDFSYNC1RPQD1BWP240H8P57CPDLVT U1_SDFRPQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (QS_Int),
          .CP (CP_D),
          .CD (CD_D),
          .Q  (QD1_Int)
          ); 
        SDFSYNC1RPQD1BWP240H8P57CPDLVT U2_SDFRPQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (QD1_Int),
          .CP (CP_D),
          .CD (CD_D),
          .Q  (QD2_Int)
          ); 
        SDFSYNC1RPQD1BWP240H8P57CPDLVT U3_SDFRPQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (QD2_Int),
          .CP (CP_D),
          .CD (CD_D),
          .Q  (QD3_Int)
          ); 
         assign Q = QD3_Int;
   `elsif UMCARM_28HPCP_9TLVT
          wire QS_Int;
          wire QD3_Int;
          wire CD_S_Int;
          wire CD_D_Int;
        SDFFRPQ_X1M_A9PP140ZTL_C35 U0_SDFRPQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (D),
          .CK   (CP_S),
          .R    (CD_S_Int),
          .Q    (QS_Int)
          ); 
        SDFFYRPQ3D_X1M_A9PP140ZTL_C35 U1_SDFRPQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (QS_Int),
          .CK   (CP_D),
          .R   (CD_D_Int),
          .Q   (QD3_Int)
          ); 
         assign Q = QD3_Int;
         assign CD_S_Int = CD_S;
         assign CD_D_Int = CD_D;
   `elsif UMCARM_28HPCP_7TLVT
          wire QS_Int;
          wire QD3_Int;
          wire CD_S_Int;
          wire CD_D_Int;
        SDFFRPQ_X1M_A7PP140ZTL_C35 U0_SDFRPQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (D),
          .CK   (CP_S),
          .R    (CD_S_Int),
          .Q    (QS_Int)
          ); 
        SDFFYRPQ3D_X1M_A7PP140ZTL_C35 U1_SDFRPQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (QS_Int),
          .CK   (CP_D),
          .R   (CD_D_Int),
          .Q   (QD3_Int)
          ); 
         assign Q = QD3_Int;
         assign CD_S_Int = CD_S;
         assign CD_D_Int = CD_D;
         `else
              reg QS_Int;
              reg QD1_Int;
              reg QD2_Int;
              reg QD3_Int;
              always @(posedge CP_S or posedge CD_S) begin 
                if(CD_S == 1'b1) begin
                  QS_Int <= 1'b0;
                end else begin
                  QS_Int <= D;
                  end
              end
              always @(posedge CP_D or posedge CD_D) begin 
                if(CD_D == 1'b1) begin
                  QD1_Int <= 1'b0;
                  QD2_Int <= 1'b0;
                  QD3_Int <= 1'b0;
                end else begin
                  QD1_Int <= QS_Int;
                  QD2_Int <= QD1_Int;
                  QD3_Int <= QD2_Int;
                  end
              end
              assign Q = QD3_Int;
`endif
endmodule

//SDFSYNC3RNQ_Wrap module
module SDFSYNC3RNQ_Wrap (
input CP_S,
input CP_D,
input D,
input CDN_S,
input CDN_D,
output Q
);

`ifdef SIM
  reg QS_Int;
  reg QD1_Int;
  reg QD2_Int;
  reg QD3_Int;
  always @(posedge CP_S or posedge CDN_S) begin 
    if(CDN_S == 1'b0) begin
      QS_Int <= 1'b0;
    end else begin
      QS_Int <= D;
      end
  end
  always @(posedge CP_D or posedge CDN_D) begin 
    if(CDN_D == 1'b0) begin
      QD1_Int <= 1'b0;
      QD2_Int <= 1'b0;
      QD3_Int <= 1'b0;
    end else begin
      QD1_Int <= QS_Int;
      QD2_Int <= QD1_Int;
      QD3_Int <= QD2_Int;
      end
  end
  assign Q = QD3_Int;
`elsif FPGA
        reg QS_Int;
        reg QD1_Int;
        reg QD2_Int;
        reg QD3_Int;
        always @(posedge CP_S or posedge CDN_S) begin 
          if(CDN_S == 1'b0) begin
            QS_Int <= 1'b0;
          end else begin
            QS_Int <= D;
            end
        end
        always @(posedge CP_D or posedge CDN_D) begin 
          if(CDN_D == 1'b0) begin
            QD1_Int <= 1'b0;
            QD2_Int <= 1'b0;
            QD3_Int <= 1'b0;
          end else begin
            QD1_Int <= QS_Int;
            QD2_Int <= QD1_Int;
            QD3_Int <= QD2_Int;
            end
        end
  assign Q = QD3_Int;
   `elsif TSMC_6NM_6T_LVT
          wire QS_Int;
          wire QD1_Int;
          wire QD2_Int;
          wire QD3_Int;
        SDFSYNC1RPQD1BWP240H8P57CPDLVT U0_SDFRPQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (D),
          .CP (CP_S),
          .CD (~CD_S),
          .Q  (QS_Int)
          ); 
        SDFSYNC1RPQD1BWP240H8P57CPDLVT U1_SDFRPQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (QS_Int),
          .CP (CP_D),
          .CD (~CD_D),
          .Q  (QD1_Int)
          ); 
        SDFSYNC1RPQD1BWP240H8P57CPDLVT U2_SDFRPQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (QD1_Int),
          .CP (CP_D),
          .CD (~CD_D),
          .Q  (QD2_Int)
          ); 
        SDFSYNC1RPQD1BWP240H8P57CPDLVT U3_SDFRPQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (QD2_Int),
          .CP (CP_D),
          .CD (~CD_D),
          .Q  (QD3_Int)
          ); 
         assign Q = QD3_Int;
   `elsif UMCARM_28HPCP_9TLVT
          wire QS_Int;
          wire QD3_Int;
          wire CD_S_Int;
          wire CD_D_Int;
        SDFFRPQ_X1M_A9PP140ZTL_C35 U0_SDFRPQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (D),
          .CK   (CP_S),
          .R    (CD_S_Int),
          .Q    (QS_Int)
          ); 
        SDFFYRPQ3D_X1M_A9PP140ZTL_C35 U1_SDFRPQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (QS_Int),
          .CK   (CP_D),
          .R   (CD_D_Int),
          .Q   (QD3_Int)
          ); 
         assign Q = QD3_Int;
         assign CD_S_Int = ~CDN_S;
         assign CD_D_Int = ~CDN_D;
   `elsif UMCARM_28HPCP_7TLVT
          wire QS_Int;
          wire QD3_Int;
          wire CD_S_Int;
          wire CD_D_Int;
        SDFFRPQ_X1M_A7PP140ZTL_C35 U0_SDFRPQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (D),
          .CK   (CP_S),
          .R    (CD_S_Int),
          .Q    (QS_Int)
          ); 
        SDFFYRPQ3D_X1M_A7PP140ZTL_C35 U1_SDFRPQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (QS_Int),
          .CK   (CP_D),
          .R   (CD_D_Int),
          .Q   (QD3_Int)
          ); 
         assign Q = QD3_Int;
         assign CD_S_Int = ~CDN_S;
         assign CD_D_Int = ~CDN_D;
         `else
              reg QS_Int;
              reg QD1_Int;
              reg QD2_Int;
              reg QD3_Int;
              always @(posedge CP_S or posedge CDN_S) begin 
                if(CDN_S == 1'b0) begin
                  QS_Int <= 1'b0;
                end else begin
                  QS_Int <= D;
                  end
              end
              always @(posedge CP_D or posedge CDN_D) begin 
                if(CDN_D == 1'b0) begin
                  QD1_Int <= 1'b0;
                  QD2_Int <= 1'b0;
                  QD3_Int <= 1'b0;
                end else begin
                  QD1_Int <= QS_Int;
                  QD2_Int <= QD1_Int;
                  QD3_Int <= QD2_Int;
                  end
              end
              assign Q = QD3_Int;
`endif
endmodule

//SDFSYNC3SNQ_Wrap module
module SDFSYNC3SNQ_Wrap (
input CP_S,
input CP_D,
input D,
input SDN_S,
input SDN_D,
output Q
);

`ifdef SIM
  reg QS_Int;
  reg QD1_Int;
  reg QD2_Int;
  reg QD3_Int;
  always @(posedge CP_S or negedge SDN_S) begin 
    if(SDN_S == 1'b0) begin
      QS_Int <= 1'b1;
    end else begin
      QS_Int <= D;
      end
  end
  always @(posedge CP_D or negedge SDN_D) begin 
    if(SDN_D == 1'b0) begin
      QD1_Int <= 1'b1;
      QD2_Int <= 1'b1;
      QD3_Int <= 1'b1;
    end else begin
      QD1_Int <= QS_Int;
      QD2_Int <= QD1_Int;
      QD3_Int <= QD2_Int;
      end
  end
  assign Q = QD3_Int;
`elsif FPGA
        reg QS_Int;
        reg QD1_Int;
        reg QD2_Int;
        reg QD3_Int;
        always @(posedge CP_S or negedge SDN_S) begin 
          if(SDN_S == 1'b0) begin
            QS_Int <= 1'b1;
          end else begin
            QS_Int <= D;
            end
        end
        always @(posedge CP_D or negedge SDN_D) begin 
          if(SDN_D == 1'b0) begin
            QD1_Int <= 1'b1;
            QD2_Int <= 1'b1;
            QD3_Int <= 1'b1;
          end else begin
            QD1_Int <= QS_Int;
            QD2_Int <= QD1_Int;
            QD3_Int <= QD2_Int;
            end
        end
  assign Q = QD3_Int;
   `elsif TSMC_6NM_6T_LVT
          wire QS_Int;
          wire QD1_Int;
          wire QD2_Int;
        SDFSYNC1SNQD1BWP240H8P57CPDLVT U0_SDFSYNC1SNQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (D),
          .CP (CP_S),
          .SDN (SDN_S),
          .Q  (QS_Int)
          ); 
        SDFSYNC1SNQD1BWP240H8P57CPDLVT U1_SDFSYNC1SNQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (QS_Int),
          .CP (CP_D),
          .SDN (SDN_D),
          .Q  (QD1_Int)
          ); 
        SDFSYNC1SNQD1BWP240H8P57CPDLVT U2_SDFSYNC1SNQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (QD1_Int),
          .CP (CP_D),
          .SDN (SDN_D),
          .Q  (QD2_Int)
          ); 
        SDFSYNC1SNQD1BWP240H8P57CPDLVT U3_SDFSYNC1SNQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (QD2_Int),
          .CP (CP_D),
          .SDN (SDN_D),
          .Q  (QD3_Int)
          ); 
         assign Q = QD3_Int;
   `elsif UMCARM_28HPCP_9TLVT
          wire QS_Int;
          wire QD3_Int;
        SDFFSQ_X1M_A9PP140ZTL_C35 U0_SDFSYNC1SNQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (D),
          .CK   (CP_S),
          .SN   (SDN_S),
          .Q    (QS_Int)
          ); 
        SDFFYSQ3D_X1M_A9PP140ZTL_C35 U1_SDFSYNC1SNQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (QS_Int),
          .CK   (CP_D),
          .SN   (SDN_D),
          .Q   (QD3_Int)
          ); 
         assign Q = QD3_Int;
   `elsif UMCARM_28HPCP_7TLVT
          wire QS_Int;
          wire QD3_Int;
        SDFFSQ_X1M_A7PP140ZTL_C35 U0_SDFSYNC1SNQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (D),
          .CK   (CP_S),
          .SN   (SDN_S),
          .Q    (QS_Int)
          ); 
        SDFFYSQ3D_X1M_A7PP140ZTL_C35 U1_SDFSYNC1SNQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (QS_Int),
          .CK   (CP_D),
          .SN   (SDN_D),
          .Q   (QD3_Int)
          ); 
         assign Q = QD3_Int;
         `else
              reg QS_Int;
              reg QD1_Int;
              reg QD2_Int;
              reg QD3_Int;
              always @(posedge CP_S or negedge SDN_S) begin 
                if(SDN_S == 1'b0) begin
                  QS_Int <= 1'b1;
                end else begin
                  QS_Int <= D;
                  end
              end
              always @(posedge CP_D or negedge SDN_D) begin 
                if(SDN_D == 1'b0) begin
                  QD1_Int <= 1'b1;
                  QD2_Int <= 1'b1;
                  QD3_Int <= 1'b1;
                end else begin
                  QD1_Int <= QS_Int;
                  QD2_Int <= QD1_Int;
                  QD3_Int <= QD2_Int;
                  end
              end
              assign Q = QD3_Int;
`endif
endmodule

//SDFSYNC2RPQ_DO_Wrap module
module SDFSYNC2RPQ_DO_Wrap (
input CP_D,
input D,
input CD_D,
output Q
);

`ifdef SIM
  reg QD1_Int;
  reg QD2_Int;
  always @(posedge CP_D or posedge CD_D) begin 
    if(CD_D == 1'b1) begin
      QD1_Int <= 1'b0;
      QD2_Int <= 1'b0;
    end else begin
      QD1_Int <= D;
      QD2_Int <= QD1_Int;
      end
  end
  assign Q = QD2_Int;
`elsif FPGA
        reg QD1_Int;
        reg QD2_Int;
        always @(posedge CP_D or posedge CD_D) begin 
          if(CD_D == 1'b1) begin
            QD1_Int <= 1'b0;
            QD2_Int <= 1'b0;
          end else begin
            QD1_Int <= D;
            QD2_Int <= QD1_Int;
            end
        end
  assign Q = QD2_Int;
   `elsif TSMC_6NM_6T_LVT
          wire QD1_Int;
          wire QD2_Int;
        SDFSYNC1RPQD1BWP240H8P57CPDLVT U1_SDFRPQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (D),
          .CP (CP_D),
          .CD (CD_D),
          .Q  (QD1_Int)
          ); 
        SDFSYNC1RPQD1BWP240H8P57CPDLVT U2_SDFRPQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (QD1_Int),
          .CP (CP_D),
          .CD (CD_D),
          .Q  (QD2_Int)
          ); 
         assign Q = QD2_Int;
   `elsif UMCARM_28HPCP_9TLVT
          wire QD2_Int;
          wire CD_D_Int;
        SDFFYRPQ2D_X1M_A9PP140ZTL_C35 U1_SDFRPQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (D),
          .CK   (CP_D),
          .R   (CD_D_Int),
          .Q   (QD2_Int)
          ); 
         assign Q = QD2_Int;
         assign CD_D_Int = CD_D;
   `elsif UMCARM_28HPCP_7TLVT
          wire QD2_Int;
          wire CD_D_Int;
        SDFFYRPQ2D_X1M_A7PP140ZTL_C35 U1_SDFRPQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (D),
          .CK   (CP_D),
          .R   (CD_D_Int),
          .Q   (QD2_Int)
          ); 
         assign Q = QD2_Int;
         assign CD_D_Int = CD_D;
         `else
              reg QD1_Int;
              reg QD2_Int;
              always @(posedge CP_D or posedge CD_D) begin 
                if(CD_D == 1'b1) begin
                  QD1_Int <= 1'b0;
                  QD2_Int <= 1'b0;
                end else begin
                  QD1_Int <= D;
                  QD2_Int <= QD1_Int;
                  end
              end
              assign Q = QD2_Int;
`endif
endmodule

//SDFSYNC2RNQ_DO_Wrap module
module SDFSYNC2RNQ_DO_Wrap (
input CP_D,
input D,
input CDN_D,
output Q
);

`ifdef SIM
  reg QD1_Int;
  reg QD2_Int;
  always @(posedge CP_D or posedge CDN_D) begin 
    if(CDN_D == 1'b0) begin
      QD1_Int <= 1'b0;
      QD2_Int <= 1'b0;
    end else begin
      QD1_Int <= D;
      QD2_Int <= QD1_Int;
      end
  end
  assign Q = QD2_Int;
`elsif FPGA
        reg QD1_Int;
        reg QD2_Int;
        always @(posedge CP_D or posedge CDN_D) begin 
          if(CDN_D == 1'b0) begin
            QD1_Int <= 1'b0;
            QD2_Int <= 1'b0;
          end else begin
            QD1_Int <= D;
            QD2_Int <= QD1_Int;
            end
        end
  assign Q = QD2_Int;
   `elsif TSMC_6NM_6T_LVT
          wire QD1_Int;
          wire QD2_Int;
        SDFSYNC1RPQD1BWP240H8P57CPDLVT U1_SDFRPQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (D),
          .CP (CP_D),
          .CD (~CDN_D),
          .Q  (QD1_Int)
          ); 
        SDFSYNC1RPQD1BWP240H8P57CPDLVT U2_SDFRPQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (QD1_Int),
          .CP (CP_D),
          .CD (~CDN_D),
          .Q  (QD2_Int)
          ); 
         assign Q = QD2_Int;
   `elsif UMCARM_28HPCP_9TLVT
          wire QD2_Int;
          wire CD_D_Int;
        SDFFYRPQ2D_X1M_A9PP140ZTL_C35 U1_SDFRPQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (D),
          .CK   (CP_D),
          .R   (CD_D_Int),
          .Q   (QD2_Int)
          ); 
         assign Q = QD2_Int;
         assign CD_D_Int = ~CDN_D;
   `elsif UMCARM_28HPCP_7TLVT
          wire QD2_Int;
          wire CD_D_Int;
        SDFFYRPQ2D_X1M_A7PP140ZTL_C35 U1_SDFRPQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (D),
          .CK   (CP_D),
          .R   (CD_D_Int),
          .Q   (QD2_Int)
          ); 
         assign Q = QD2_Int;
         assign CD_D_Int = ~CDN_D;
         `else
              reg QD1_Int;
              reg QD2_Int;
              always @(posedge CP_D or posedge CDN_D) begin 
                if(CDN_D == 1'b0) begin
                  QD1_Int <= 1'b0;
                  QD2_Int <= 1'b0;
                end else begin
                  QD1_Int <= D;
                  QD2_Int <= QD1_Int;
                  end
              end
              assign Q = QD2_Int;
`endif
endmodule

//SDFSYNC2SNQ_DO_Wrap module
module SDFSYNC2SNQ_DO_Wrap (
input CK,
input D,
input SDN,
output Q
);

`ifdef SIM
  reg QD1_Int;
  reg QD2_Int;
  always @(posedge CK or negedge SDN) begin 
    if(SDN == 1'b0) begin
      QD1_Int <= 1'b1;
      QD2_Int <= 1'b1;
    end else begin
      QD1_Int <= D;
      QD2_Int <= QD1_Int;
      end
  end
  assign Q = QD2_Int;
`elsif FPGA
        reg QD1_Int;
        reg QD2_Int;
        always @(posedge CK or negedge SDN) begin 
          if(SDN == 1'b0) begin
            QD1_Int <= 1'b1;
            QD2_Int <= 1'b1;
          end else begin
            QD1_Int <= D;
            QD2_Int <= QD1_Int;
            end
        end
  assign Q = QD2_Int;
   `elsif TSMC_6NM_6T_LVT
          wire QD1_Int;
          wire QD2_Int;
        SDFSYNC1SNQD1BWP240H8P57CPDLVT U1_SDFSYNC1SNQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (D),
          .CP (CK),
          .SDN (SDN),
          .Q  (QD1_Int)
          ); 
        SDFSYNC1SNQD1BWP240H8P57CPDLVT U2_SDFSYNC1SNQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (QD1_Int),
          .CP (CK),
          .SDN (SDN),
          .Q  (QD2_Int)
          ); 
         assign Q = QD2_Int;
   `elsif UMCARM_28HPCP_9TLVT
          wire QD2_Int;
        SDFFYSQ2D_X1M_A9PP140ZTL_C35 U1_SDFSYNC1SNQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (D),
          .CK   (CK),
          .SN   (SDN),
          .Q   (QD2_Int)
          ); 
         assign Q = QD2_Int;
   `elsif UMCARM_28HPCP_7TLVT
          wire QD2_Int;
        SDFFYSQ2D_X1M_A7PP140ZTL_C35 U1_SDFSYNC1SNQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (D),
          .CK   (CK),
          .SN   (SDN),
          .Q   (QD2_Int)
          ); 
         assign Q = QD2_Int;
         `else
              reg QD1_Int;
              reg QD2_Int;
              always @(posedge CK or negedge SDN) begin 
                if(SDN == 1'b0) begin
                  QD1_Int <= 1'b1;
                  QD2_Int <= 1'b1;
                end else begin
                  QD1_Int <= D;
                  QD2_Int <= QD1_Int;
                  end
              end
              assign Q = QD2_Int;
`endif
endmodule

//SDFSYNC3RPQ_DO_Wrap module
module SDFSYNC3RPQ_DO_Wrap (
input CP_D,
input D,
input CD_D,
output Q
);

`ifdef SIM
  reg QD1_Int;
  reg QD2_Int;
  reg QD3_Int;
  always @(posedge CP_D or posedge CD_D) begin 
    if(CD_D == 1'b1) begin
      QD1_Int <= 1'b0;
      QD2_Int <= 1'b0;
      QD3_Int <= 1'b0;
    end else begin
      QD1_Int <= D;
      QD2_Int <= QD1_Int;
      QD3_Int <= QD2_Int;
      end
  end
  assign Q = QD3_Int;
`elsif FPGA
        reg QD1_Int;
        reg QD2_Int;
        reg QD3_Int;
        always @(posedge CP_D or posedge CD_D) begin 
          if(CD_D == 1'b1) begin
            QD1_Int <= 1'b0;
            QD2_Int <= 1'b0;
            QD3_Int <= 1'b0;
          end else begin
            QD1_Int <= D;
            QD2_Int <= QD1_Int;
            QD3_Int <= QD2_Int;
            end
        end
  assign Q = QD3_Int;
   `elsif TSMC_6NM_6T_LVT
          wire QD1_Int;
          wire QD2_Int;
          wire QD3_Int;
        SDFSYNC1RPQD1BWP240H8P57CPDLVT U1_SDFRPQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (D),
          .CP (CP_D),
          .CD (CD_D),
          .Q  (QD1_Int)
          ); 
        SDFSYNC1RPQD1BWP240H8P57CPDLVT U2_SDFRPQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (QD1_Int),
          .CP (CP_D),
          .CD (CD_D),
          .Q  (QD2_Int)
          ); 
        SDFSYNC1RPQD1BWP240H8P57CPDLVT U3_SDFRPQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (QD2_Int),
          .CP (CP_D),
          .CD (CD_D),
          .Q  (QD3_Int)
          ); 
         assign Q = QD3_Int;
   `elsif UMCARM_28HPCP_9TLVT
          wire QD3_Int;
          wire CD_D_Int;
        SDFFYRPQ3D_X1M_A9PP140ZTL_C35 U1_SDFRPQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (D),
          .CK   (CP_D),
          .R   (CD_D_Int),
          .Q   (QD3_Int)
          ); 
         assign Q = QD3_Int;
         assign CD_D_Int = CD_D;
   `elsif UMCARM_28HPCP_7TLVT
          wire QD3_Int;
          wire CD_D_Int;
        SDFFYRPQ3D_X1M_A7PP140ZTL_C35 U1_SDFRPQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (D),
          .CK   (CP_D),
          .R   (CD_D_Int),
          .Q   (QD3_Int)
          ); 
         assign Q = QD3_Int;
         assign CD_D_Int = CD_D;
         `else
              reg QD1_Int;
              reg QD2_Int;
              reg QD3_Int;
              always @(posedge CP_D or posedge CD_D) begin 
                if(CD_D == 1'b1) begin
                  QD1_Int <= 1'b0;
                  QD2_Int <= 1'b0;
                  QD3_Int <= 1'b0;
                end else begin
                  QD1_Int <= D;
                  QD2_Int <= QD1_Int;
                  QD3_Int <= QD2_Int;
                  end
              end
              assign Q = QD3_Int;
`endif
endmodule

//SDFSYNC3RNQ_DO_Wrap module
module SDFSYNC3RNQ_DO_Wrap (
input CP_D,
input D,
input CDN_D,
output Q
);

`ifdef SIM
  reg QD1_Int;
  reg QD2_Int;
  reg QD3_Int;
  always @(posedge CP_D or posedge CDN_D) begin 
    if(CDN_D == 1'b0) begin
      QD1_Int <= 1'b0;
      QD2_Int <= 1'b0;
      QD3_Int <= 1'b0;
    end else begin
      QD1_Int <= D;
      QD2_Int <= QD1_Int;
      QD3_Int <= QD2_Int;
      end
  end
  assign Q = QD3_Int;
`elsif FPGA
        reg QD1_Int;
        reg QD2_Int;
        reg QD3_Int;
        always @(posedge CP_D or posedge CDN_D) begin 
          if(CDN_D == 1'b0) begin
            QD1_Int <= 1'b0;
            QD2_Int <= 1'b0;
            QD3_Int <= 1'b0;
          end else begin
            QD1_Int <= D;
            QD2_Int <= QD1_Int;
            QD3_Int <= QD2_Int;
            end
        end
  assign Q = QD3_Int;
   `elsif TSMC_6NM_6T_LVT
          wire QD1_Int;
          wire QD2_Int;
          wire QD3_Int;
        SDFSYNC1RPQD1BWP240H8P57CPDLVT U1_SDFRPQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (D),
          .CP (CP_D),
          .CD (~CDN_D),
          .Q  (QD1_Int)
          ); 
        SDFSYNC1RPQD1BWP240H8P57CPDLVT U2_SDFRPQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (QD1_Int),
          .CP (CP_D),
          .CD (~CDN_D),
          .Q  (QD2_Int)
          ); 
        SDFSYNC1RPQD1BWP240H8P57CPDLVT U3_SDFRPQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (QD2_Int),
          .CP (CP_D),
          .CD (~CDN_D),
          .Q  (QD3_Int)
          ); 
         assign Q = QD3_Int;
   `elsif UMCARM_28HPCP_9TLVT
          wire QD3_Int;
          wire CD_D_Int;
        SDFFYRPQ3D_X1M_A9PP140ZTL_C35 U1_SDFRPQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (D),
          .CK   (CP_D),
          .R   (CD_D_Int),
          .Q   (QD3_Int)
          ); 
         assign Q = QD3_Int;
         assign CD_D_Int = ~CDN_D;
   `elsif UMCARM_28HPCP_7TLVT
          wire QD3_Int;
          wire CD_D_Int;
        SDFFYRPQ3D_X1M_A7PP140ZTL_C35 U1_SDFRPQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (D),
          .CK   (CP_D),
          .R   (CD_D_Int),
          .Q   (QD3_Int)
          ); 
         assign Q = QD3_Int;
         assign CD_D_Int = ~CDN_D;
         `else
              reg QD1_Int;
              reg QD2_Int;
              reg QD3_Int;
              always @(posedge CP_D or posedge CDN_D) begin 
                if(CDN_D == 1'b0) begin
                  QD1_Int <= 1'b0;
                  QD2_Int <= 1'b0;
                  QD3_Int <= 1'b0;
                end else begin
                  QD1_Int <= D;
                  QD2_Int <= QD1_Int;
                  QD3_Int <= QD2_Int;
                  end
              end
              assign Q = QD3_Int;
`endif
endmodule

//SDFSYNC3SNQ_DO_Wrap module
module SDFSYNC3SNQ_DO_Wrap (
input CP_D,
input D,
input SDN_D,
output Q
);

`ifdef SIM
  reg QD1_Int;
  reg QD2_Int;
  reg QD3_Int;
  always @(posedge CP_D or negedge SDN_D) begin 
    if(SDN_D == 1'b0) begin
      QD1_Int <= 1'b1;
      QD2_Int <= 1'b1;
      QD3_Int <= 1'b1;
    end else begin
      QD1_Int <= D;
      QD2_Int <= QD1_Int;
      QD3_Int <= QD2_Int;
      end
  end
  assign Q = QD3_Int;
`elsif FPGA
        reg QD1_Int;
        reg QD2_Int;
        reg QD3_Int;
        always @(posedge CP_D or negedge SDN_D) begin 
          if(SDN_D == 1'b0) begin
            QD1_Int <= 1'b1;
            QD2_Int <= 1'b1;
            QD3_Int <= 1'b1;
          end else begin
            QD1_Int <= D;
            QD2_Int <= QD1_Int;
            QD3_Int <= QD2_Int;
            end
        end
  assign Q = QD3_Int;
   `elsif TSMC_6NM_6T_LVT
          wire QD1_Int;
          wire QD2_Int;
        SDFSYNC1SNQD1BWP240H8P57CPDLVT U1_SDFSYNC1SNQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (D),
          .CP (CP_D),
          .SDN (SDN_D),
          .Q  (QD1_Int)
          ); 
        SDFSYNC1SNQD1BWP240H8P57CPDLVT U2_SDFSYNC1SNQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (QD1_Int),
          .CP (CP_D),
          .SDN (SDN_D),
          .Q  (QD2_Int)
          ); 
        SDFSYNC1SNQD1BWP240H8P57CPDLVT U3_SDFSYNC1SNQ(
          .SI (1'b0),
          .SE (1'b0),
          .D  (QD2_Int),
          .CP (CP_D),
          .SDN (SDN_D),
          .Q  (QD3_Int)
          ); 
         assign Q = QD3_Int;
   `elsif UMCARM_28HPCP_9TLVT
          wire QD3_Int;
        SDFFYSQ3D_X1M_A9PP140ZTL_C35 U1_SDFSYNC1SNQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (D),
          .CK   (CP_D),
          .SN   (SDN_D),
          .Q   (QD3_Int)
          ); 
         assign Q = QD3_Int;
   `elsif UMCARM_28HPCP_7TLVT
          wire QD3_Int;
        SDFFYSQ3D_X1M_A7PP140ZTL_C35 U1_SDFSYNC1SNQ(
          .SI   (1'b0),
          .SE   (1'b0),
          .D    (D),
          .CK   (CP_D),
          .SN   (SDN_D),
          .Q   (QD3_Int)
          ); 
         assign Q = QD3_Int;
         `else
              reg QD1_Int;
              reg QD2_Int;
              reg QD3_Int;
              always @(posedge CP_D or negedge SDN_D) begin 
                if(SDN_D == 1'b0) begin
                  QD1_Int <= 1'b1;
                  QD2_Int <= 1'b1;
                  QD3_Int <= 1'b1;
                end else begin
                  QD1_Int <= D;
                  QD2_Int <= QD1_Int;
                  QD3_Int <= QD2_Int;
                  end
              end
              assign Q = QD3_Int;
`endif
endmodule




===FILE_END===StdCell_Wrap.v===
===FILE_START===dig_cell.v===END_HEADER===
`define WAM_PROC \
wire in_sync_wam; \
`ifdef WAM_XSTATE_MESSAGE_LEVEL_INFO \
wam #(.xstate_message_level(1)) U_WAM (.dst_clk(clk), .datain(data), .dataout(in_sync_wam)); \
`else \
wam U_WAM (.dst_clk(clk), .datain(data), .dataout(in_sync_wam)); \
`endif
module clk_sparecells (CK, RST, Q);
input CK;
input RST;
output Q;

wire spare_dff1_d, spare_dff1_q;
wire spare_dff2_d, spare_dff2_q;
wire spare_dff3_d, spare_dff3_q;
wire spare_dff4_d, spare_dff4_q;
wire spare_dff5_d, spare_dff5_q;

wire rstn;
//Inv_Wrap U_DONT_RST_INV (.A(RST), .ZN(rstn));

Mux2_Wrap  U_DONT_SPARE_MUX_1 (.A(Q), .B(1'b0), .S(1'b0), .Z(spare_dff1_d));
SDFRPQ_Wrap U_DONT_SPARE_DFF_1 (.CP(CK), .CD(RST), .D(spare_dff1_d), .Q(Q) );

Mux2_Wrap  U_DONT_SPARE_MUX_2 (.A(spare_dff2_q), .B(1'b0), .S(1'b0), .Z(spare_dff2_d));
SDFRPQ_Wrap U_DONT_SPARE_DFF_2 (.CP(CK), .CD(RST), .D(spare_dff2_d), .Q(spare_dff2_q) );

Mux2_Wrap  U_DONT_SPARE_MUX_3 (.A(spare_dff3_q), .B(1'b0), .S(1'b0), .Z(spare_dff3_d));
SDFRPQ_Wrap U_DONT_SPARE_DFF_3 (.CP(CK), .CD(RST), .D(spare_dff3_d), .Q(spare_dff3_q));

Mux2_Wrap  U_DONT_SPARE_MUX_4 (.A(spare_dff4_q), .B(1'b0), .S(1'b0), .Z(spare_dff4_d));
SDFRPQ_Wrap U_DONT_SPARE_DFF_4 (.CP(CK), .CD(RST), .D(spare_dff4_d), .Q(spare_dff4_q));

Mux2_Wrap  U_DONT_SPARE_MUX_5 (.A(spare_dff5_q), .B(1'b0), .S(1'b0), .Z(spare_dff5_d));
SDFRPQ_Wrap U_DONT_SPARE_DFF_5 (.CP(CK), .CD(RST), .D(spare_dff5_d), .Q(spare_dff5_q) );

endmodule


//module clk_sparecells_udr (CK, RST, Q);
//input CK;
//input RST;
//output Q;
//
//wire spare_dff1_d, spare_dff1_q;
//wire spare_dff2_d, spare_dff2_q;
//wire spare_dff3_d, spare_dff3_q;
//wire spare_dff4_d, spare_dff4_q;
//wire spare_dff5_d, spare_dff5_q;
//
//wire rstn;
//szd_sivx6_m2 U_DONT_RST_INV (.A(RST), .Z(rstn));
//
//Mux2_Wrap  U_DONT_SPARE_MUX_1 (.A(Q), .B(1'b0), .S(1'b0), .Z(spare_dff1_d));
//SDFSNQ_Wrap U_DONT_SPARE_DFF_1 (.CK(CK), .RB(rstn), .D(spare_dff1_d), .Q(Q), .SCN(1'b0), .SI(1'b0));
////szd_ssdfrudrx4 U_DONT_SPARE_DFF_1 ( .ISOB(1'b1), .CK(CK), .RB(rstn), .D(spare_dff1_d), .Q(Q), .SCN(1'b0), .SI(1'b0));
//
//Mux2_Wrap  U_DONT_SPARE_MUX_2 (.A(spare_dff2_q), .B(1'b0), .S(1'b0), .Z(spare_dff2_d));
//SDFSNQ_Wrap U_DONT_SPARE_DFF_2 (.CK(CK), .RB(rstn), .D(spare_dff2_d), .Q(spare_dff2_q), .SCN(1'b0), .SI(1'b0));
////szd_ssdfrudrx4 U_DONT_SPARE_DFF_2 ( .ISOB(1'b1), .CK(CK), .RB(rstn), .D(spare_dff2_d), .Q(spare_dff2_q), .SCN(1'b0), .SI(1'b0));
//
//Mux2_Wrap  U_DONT_SPARE_MUX_3 (.A(spare_dff3_q), .B(1'b0), .S(1'b0), .Z(spare_dff3_d));
//SDFSNQ_Wrap U_DONT_SPARE_DFF_3 (.CK(CK), .RB(rstn), .D(spare_dff3_d), .Q(spare_dff3_q), .SCN(1'b0), .SI(1'b0));
////szd_ssdfrudrx4 U_DONT_SPARE_DFF_3 ( .ISOB(1'b1), .CK(CK), .RB(rstn), .D(spare_dff3_d), .Q(spare_dff3_q), .SCN(1'b0), .SI(1'b0));
//
//Mux2_Wrap  U_DONT_SPARE_MUX_4 (.A(spare_dff4_q), .B(1'b0), .S(1'b0), .Z(spare_dff4_d));
//SDFSNQ_Wrap U_DONT_SPARE_DFF_4 (.CK(CK), .RB(rstn), .D(spare_dff4_d), .Q(spare_dff4_q), .SCN(1'b0), .SI(1'b0));
////szd_ssdfrudrx4 U_DONT_SPARE_DFF_4 ( .ISOB(1'b1), .CK(CK), .RB(rstn), .D(spare_dff4_d), .Q(spare_dff4_q), .SCN(1'b0), .SI(1'b0));
//
//Mux2_Wrap  U_DONT_SPARE_MUX_5 (.A(spare_dff5_q), .B(1'b0), .S(1'b0), .Z(spare_dff5_d));
//SDFSNQ_Wrap U_DONT_SPARE_DFF_5 (.CK(CK), .RB(rstn), .D(spare_dff5_d), .Q(spare_dff5_q), .SCN(1'b0), .SI(1'b0));
////szd_ssdfrudrx4 U_DONT_SPARE_DFF_5 ( .ISOB(1'b1), .CK(CK), .RB(rstn), .D(spare_dff5_d), .Q(spare_dff5_q), .SCN(1'b0), .SI(1'b0));
//
//endmodule

module clk_or_cell_type1 (A, B, Z);

input A, B;
output Z;

CKOr2_Wrap U_DONT_OR ( .A1(A), .A2(B), .Z(Z) );


endmodule






module clk_mux_cell_type1 (A, B, S, Z);
input  A ;
input  B ;
input  S ;
output Z ;

CKMux2_Wrap U_DONT_MUX(.A(A), .B(B), .S(S), .Z(Z));

endmodule


//A to Z has short delay
module clk_mux_cell_type2 (A, B, S, Z);
input  A ;
input  B ;
input  S ;
output Z ;

wire S_N;
wire A_SEL;
wire B_SEL;

CKInv_Wrap  U_DONT_INV (.A(S), .ZN(S_N));
CKNand2_Wrap U_DONT_NAND_1 ( .A(A), .B(S_N), .ZN(A_SEL) );
CKNand2_Wrap U_DONT_NAND_2 ( .A(B), .B(S), .ZN(B_SEL) );
CKNand2_Wrap U_DONT_NAND_3 ( .A(A_SEL), .B(B_SEL), .ZN(Z) );

endmodule

//A to Z has short delay
module clk_mux_cell_type3 (A, B, S1, S2, Z);
input  A ;
input  B ;
input  S1 ;
input  S2 ;
output Z ;

wire A_SEL;
wire B_SEL;

//assign Z = A & S1 | B & S2;
CKNand2_Wrap U_DONT_NAND_1 ( .A(A), .B(S1), .ZN(A_SEL) );
CKNand2_Wrap U_DONT_NAND_2 ( .A(B), .B(S2), .ZN(B_SEL) );
CKNand2_Wrap U_DONT_NAND_3 ( .A(A_SEL), .B(B_SEL), .ZN(Z) );

endmodule



//not used
//module clk_xor_cell_type1 (A, B, Z);
//input  A ;
//input  B ;
//output Z ;
//
//szd_scxor2x8 U_DONT_XOR (.A ( A ) , .B(B), .Z(Z));
//
//endmodule


//A to Z has short delay
module clk_xor_cell_type2 (A, B, Z);
input  A ;
input  B ;
output Z ;

wire A_N;
wire B_N;
wire A_BN;
wire AN_B;

CKInv_Wrap  U_DONT_INV_1 (.A(A), .ZN(A_N));
CKInv_Wrap  U_DONT_INV_2 (.A(B), .ZN(B_N));
CKNand2_Wrap U_DONT_NAND_1 (.A(A), .B(B_N), .ZN(A_BN));
CKNand2_Wrap U_DONT_NAND_2 (.A(A_N), .B(B), .ZN(AN_B));
CKNand2_Wrap U_DONT_NAND_3 (.A(A_BN), .B(AN_B), .ZN(Z));


endmodule



module clk_inv_cell (A, Z);
input  A ;
output Z ;

CKInv_Wrap U_DONT_INV(.A(A), .ZN(Z));

endmodule

module clk_gate_cell_type1 (CKIN, EN, CKOUT);
input  CKIN ;
input  EN ;
output CKOUT ;

wire CKOUT_N;

CKNand2_Wrap U_DONT_NAND (.A(CKIN), .B(EN), .ZN(CKOUT_N));
CKInv_Wrap U_DONT_INV (.A(CKOUT_N), .ZN(CKOUT));

endmodule

module clk_gate_cell_type2 (CKIN, DIS, CKOUT);
input  CKIN ;
input  DIS ;
output CKOUT ;

wire CKOUT_N;

//    szd_scnr2x4 U_DONT_NAND (.A(CKIN), .B(DIS), .Z(CKOUT_N));
//    CKInv_Wrap U_DONT_INV (.A(CKOUT_N), .ZN(CKOUT));


CKOr2_Wrap   U_DONT_OR (.A1(CKIN), .A2(DIS), .Z(CKOUT) );


endmodule


//not used
//module data_mux_cell_type1 (A, B, S, Z);
//input  A ;
//input  B ;
//input  S ;
//output Z ;
//
//szd_smx2x8 U_DONT_MUX(.A(A), .B(B), .S(S), .Z(Z));
//
//endmodule

module data_mux_cell_type2 (A, B, S, Z);
input  A ;
input  B ;
input  S ;
output Z ;

wire S_N;
wire A_SEL;
wire B_SEL;

Inv_Wrap  U_DONT_INV (.A(S), .ZN(S_N));
Nand2_Wrap U_DONT_NAND_1 ( .A(A), .B(S_N), .ZN(A_SEL) );
Nand2_Wrap U_DONT_NAND_2 ( .A(B), .B(S), .ZN(B_SEL) );
Nand2_Wrap U_DONT_NAND_3 ( .A(A_SEL), .B(B_SEL), .ZN(Z) );

endmodule


module data_mux_cell_bus10 (A, B, S, Z);
input  [9:0] A ;
input  [9:0] B ;
input  S ;
output [9:0] Z ;

data_mux_cell_type2 u_mx2_0(.A(A[0]), .B(B[0]), .S(S), .Z(Z[0]));
data_mux_cell_type2 u_mx2_1(.A(A[1]), .B(B[1]), .S(S), .Z(Z[1]));
data_mux_cell_type2 u_mx2_2(.A(A[2]), .B(B[2]), .S(S), .Z(Z[2]));
data_mux_cell_type2 u_mx2_3(.A(A[3]), .B(B[3]), .S(S), .Z(Z[3]));
data_mux_cell_type2 u_mx2_4(.A(A[4]), .B(B[4]), .S(S), .Z(Z[4]));
data_mux_cell_type2 u_mx2_5(.A(A[5]), .B(B[5]), .S(S), .Z(Z[5]));
data_mux_cell_type2 u_mx2_6(.A(A[6]), .B(B[6]), .S(S), .Z(Z[6]));
data_mux_cell_type2 u_mx2_7(.A(A[7]), .B(B[7]), .S(S), .Z(Z[7]));
data_mux_cell_type2 u_mx2_8(.A(A[8]), .B(B[8]), .S(S), .Z(Z[8]));
data_mux_cell_type2 u_mx2_9(.A(A[9]), .B(B[9]), .S(S), .Z(Z[9]));

endmodule

//A: 10bit, B: 10bit
module data_xor_cell_bus10_t2 (A, B, Z);
input [9:0] A;
input [9:0] B;
output [9:0] Z;

data_xor_cell_type2 u_xor2_0 (.A(A[0]), .B(B[0]), .Z(Z[0]));
data_xor_cell_type2 u_xor2_1 (.A(A[1]), .B(B[1]), .Z(Z[1]));
data_xor_cell_type2 u_xor2_2 (.A(A[2]), .B(B[2]), .Z(Z[2]));
data_xor_cell_type2 u_xor2_3 (.A(A[3]), .B(B[3]), .Z(Z[3]));
data_xor_cell_type2 u_xor2_4 (.A(A[4]), .B(B[4]), .Z(Z[4]));
data_xor_cell_type2 u_xor2_5 (.A(A[5]), .B(B[5]), .Z(Z[5]));
data_xor_cell_type2 u_xor2_6 (.A(A[6]), .B(B[6]), .Z(Z[6]));
data_xor_cell_type2 u_xor2_7 (.A(A[7]), .B(B[7]), .Z(Z[7]));
data_xor_cell_type2 u_xor2_8 (.A(A[8]), .B(B[8]), .Z(Z[8]));
data_xor_cell_type2 u_xor2_9 (.A(A[9]), .B(B[9]), .Z(Z[9]));

endmodule


//module data_dly_cell (A,Z);
//input A;
//output Z ;
//wire Z;
//wire n1,n2,n3,n4 ;
//szd_sbufx1 U_DLY_0 ( .A(A), .Z(n1));
//szd_sbufx1 U_DLY_1 ( .A(n1), .Z(n2));
//szd_sbufx1 U_DLY_2 ( .A(n2), .Z(n3));
//szd_sbufx1 U_DLY_3 ( .A(n3), .Z(n4));
//szd_sbufx1 U_DLY_4 ( .A(n4), .Z(Z));
//endmodule


//module data_dly_cell_bus10 (A,Z);
//input [9:0] A;
//output [9:0] Z ;
//wire [9:0] Z;

//data_dly_cell u_dly_0 (.A(A[0]), .Z(Z[0]));
//data_dly_cell u_dly_1 (.A(A[1]), .Z(Z[1]));
//data_dly_cell u_dly_2 (.A(A[2]), .Z(Z[2]));
//data_dly_cell u_dly_3 (.A(A[3]), .Z(Z[3]));
//data_dly_cell u_dly_4 (.A(A[4]), .Z(Z[4]));
//data_dly_cell u_dly_5 (.A(A[5]), .Z(Z[5]));
//data_dly_cell u_dly_6 (.A(A[6]), .Z(Z[6]));
//data_dly_cell u_dly_7 (.A(A[7]), .Z(Z[7]));
//data_dly_cell u_dly_8 (.A(A[8]), .Z(Z[8]));
//data_dly_cell u_dly_9 (.A(A[9]), .Z(Z[9]));
//
//endmodule

module data_dly_cell_type2 (A,Z);
input A;
output Z ;
wire Z;
wire n1,n2,n3,n4 ;
Buf_Wrap U_DONT_DLY_0 ( .A(A), .Z(n1));
Buf_Wrap U_DONT_DLY_1 ( .A(n1), .Z(n2));
Buf_Wrap U_DONT_DLY_2 ( .A(n2), .Z(n3));
Buf_Wrap U_DONT_DLY_3 ( .A(n3), .Z(n4));
Buf_Wrap U_DONT_DLY_4 ( .A(n4), .Z(Z));
endmodule


module data_dly_cell_bus10_type2 (A,Z);
input [9:0] A;
output [9:0] Z ;
wire [9:0] Z;

data_dly_cell_type2 u_dly_0 (.A(A[0]), .Z(Z[0]));
data_dly_cell_type2 u_dly_1 (.A(A[1]), .Z(Z[1]));
data_dly_cell_type2 u_dly_2 (.A(A[2]), .Z(Z[2]));
data_dly_cell_type2 u_dly_3 (.A(A[3]), .Z(Z[3]));
data_dly_cell_type2 u_dly_4 (.A(A[4]), .Z(Z[4]));
data_dly_cell_type2 u_dly_5 (.A(A[5]), .Z(Z[5]));
data_dly_cell_type2 u_dly_6 (.A(A[6]), .Z(Z[6]));
data_dly_cell_type2 u_dly_7 (.A(A[7]), .Z(Z[7]));
data_dly_cell_type2 u_dly_8 (.A(A[8]), .Z(Z[8]));
data_dly_cell_type2 u_dly_9 (.A(A[9]), .Z(Z[9]));

endmodule


//not used
//module data_xor_cell_type1 (A, B, Z);
//input A, B;
//output Z;
//
//szd_sxor2x8 U_DONT_XOR (.A(A), .B(B), .Z(Z));
//
//endmodule

module data_xor_cell_type2 (A, B, Z);
input A, B;
output Z;

wire A_N;
wire B_N;
wire A_BN;
wire AN_B;

Inv_Wrap  U_DONT_INV_1 (.A(A), .ZN(A_N));
Inv_Wrap  U_DONT_INV_2 (.A(B), .ZN(B_N));
Nand2_Wrap U_DONT_NAND_1 (.A(A), .B(B_N), .ZN(A_BN));
Nand2_Wrap U_DONT_NAND_2 (.A(A_N), .B(B), .ZN(AN_B));
Nand2_Wrap U_DONT_NAND_3 (.A(A_BN), .B(AN_B), .ZN(Z));

endmodule


//A: 10bit, B: 1bit
module data_xor_cell_bus10 (A, B, Z);
input [9:0] A;
input B;
output [9:0] Z;

data_xor_cell_type2 u_xor2_0 (.A(A[0]), .B(B), .Z(Z[0]));
data_xor_cell_type2 u_xor2_1 (.A(A[1]), .B(B), .Z(Z[1]));
data_xor_cell_type2 u_xor2_2 (.A(A[2]), .B(B), .Z(Z[2]));
data_xor_cell_type2 u_xor2_3 (.A(A[3]), .B(B), .Z(Z[3]));
data_xor_cell_type2 u_xor2_4 (.A(A[4]), .B(B), .Z(Z[4]));
data_xor_cell_type2 u_xor2_5 (.A(A[5]), .B(B), .Z(Z[5]));
data_xor_cell_type2 u_xor2_6 (.A(A[6]), .B(B), .Z(Z[6]));
data_xor_cell_type2 u_xor2_7 (.A(A[7]), .B(B), .Z(Z[7]));
data_xor_cell_type2 u_xor2_8 (.A(A[8]), .B(B), .Z(Z[8]));
data_xor_cell_type2 u_xor2_9 (.A(A[9]), .B(B), .Z(Z[9]));

endmodule



//module sync2_udr_cell (clk, reset, data, qout);
//input clk, reset, data;
//output qout;
//
//wire reset_n;
//
//Inv_Wrap U_DONT_RST_INV (.A(reset), .Z(reset_n));
////szd_s2dsyncudrx2 U_DONT_SYNC2( .ISOB(1'b1), .Q(qout), .CK(clk), .D(data), .RB(reset_n), .SCN(1'b0), .SI(1'b0));
//SDFSYNC2SNQ_DO_Wrap U_DONT_SYNC2( .Q(qout), .CK(clk), .D(data), .RB(reset_n), .SCN(1'b0), .SI(1'b0));
//
//endmodule

//module sync2_udr_cell_dly (clk, reset, data, qout);
//input clk, reset, data;
//output qout;
//
//wire reset_n;
//
//Inv_Wrap U_DONT_RST_INV (.A(reset), .Z(reset_n));
////szd_s2dsyncudrx2 U_DONT_DLY( .ISOB(1'b1), .Q(qout), .CK(clk), .D(data), .RB(reset_n), .SCN(1'b0), .SI(1'b0));
//SDFSYNC2SNQ_DO_Wrap U_DONT_DLY ( .Q(qout), .CK(clk), .D(data), .RB(reset_n), .SCN(1'b0), .SI(1'b0));
//
//endmodule
//
//module sync2_udr_cell_rstb (clk, reset_n, data, qout);
//input clk, reset_n, data;
//output qout;
//
////szd_s2dsyncudrx2 U_DONT_SYNC2( .ISOB(1'b1), .Q(qout), .CK(clk), .D(data), .RB(reset_n), .SCN(1'b0), .SI(1'b0));
//SDFSYNC2SNQ_DO_Wrap U_DONT_SYNC2( .Q(qout), .CK(clk), .D(data), .RB(reset_n), .SCN(1'b0), .SI(1'b0));
//
//endmodule
//
//
//module sync2_udr_cell_set (clk, set, data, qout);
//input clk, set, data;
//output qout;
//
//wire data_n, set_n, qout_n;
//Inv_Wrap U_DONT_DATA_INV (.A(data), .Z(data_n));
//Inv_Wrap U_DONT_RST_INV (.A(set), .Z(set_n));
////szd_s2dsyncudrx2 U_DONT_SYNC2( .ISOB(1'b1), .Q(qout_n), .CK(clk), .D(data_n), .RB(set_n), .SCN(1'b0), .SI(1'b0));
//SDFSYNC2SNQ_DO_Wrap U_DONT_SYNC2( .Q(qout_n), .CK(clk), .D(data_n), .RB(set_n), .SCN(1'b0), .SI(1'b0));
//Inv_Wrap U_DONT_QOUT_INV (.A(qout_n), .Z(qout));
//
//endmodule

/*
module sync2_udr_cell_set_dly (clk, set, data, qout);
input clk, set, data;
output qout;

wire data_n, set_n, qout_n;
Inv_Wrap U_DONT_DATA_INV (.A(data), .Z(data_n));
Inv_Wrap U_DONT_RST_INV (.A(set), .Z(set_n));
//szd_s2dsyncudrx2 U_DONT_DLY( .ISOB(1'b1), .Q(qout_n), .CK(clk), .D(data_n), .RB(set_n), .SCN(1'b0), .SI(1'b0));
SDFSYNC2SNQ_DO_Wrap U_DONT_DLY ( .Q(qout_n), .CK(clk), .D(data_n), .RB(set_n), .SCN(1'b0), .SI(1'b0));
Inv_Wrap U_DONT_QOUT_INV (.A(qout_n), .Z(qout));

endmodule
*/

//
//
//module sync2_udr_cell_setb (clk, set_n, data, qout);
//input clk, set_n, data;
//output qout;
//
//wire data_n, qout_n;
//SDFSYNC2SNQ_DO_Wrap U_DONT_SYNC2( .Q(qout), .CK(clk), .D(data), .SDN(set_n));
//
//endmodule

/*
module sync2_cell (clk, reset, data, qout);
input clk, reset, data;
output qout;

reg data_sync1;
reg data_sync2;

always @(posedge clk or posedge reset)
begin
  if(reset) begin
    data_sync1 <= 1'b0;  
    data_sync2 <= 1'b0;  
  end
else begin
    data_sync1 <= data;
    data_sync2 <= data_sync1;
  end
end

assign qout = data_sync2;

endmodule

module sync2_cell_rstb (clk, reset_n, data, qout);
input clk, reset_n, data;
output qout;

reg data_sync1;
reg data_sync2;

always @(posedge clk or negedge reset_n)
begin
  if(~reset_n) begin
    data_sync1 <= 1'b0;  
    data_sync2 <= 1'b0;  
  end
else begin
    data_sync1 <= data;
    data_sync2 <= data_sync1;
  end
end

assign qout = data_sync2;


endmodule


module sync2_cell_set (clk, set, data, qout);
input clk, set, data;
output qout;

reg data_sync1;
reg data_sync2;

always @(posedge clk or posedge set)
begin
  if(set) begin
    data_sync1 <= 1'b1;  
    data_sync2 <= 1'b1;  
  end
else begin
    data_sync1 <= data;
    data_sync2 <= data_sync1;
  end
end

assign qout = data_sync2;



endmodule

module sync2_cell_setb (clk, set_n, data, qout);
input clk, set_n, data;
output qout;

reg data_sync1;
reg data_sync2;

always @(posedge clk or negedge set_n)
begin
  if(~set_n) begin
    data_sync1 <= 1'b1;  
    data_sync2 <= 1'b1;  
  end
else begin
    data_sync1 <= data;
    data_sync2 <= data_sync1;
  end
end

assign qout = data_sync2;

endmodule

module clk_gate_cell_type3 (TE,E,CP,Q);
input TE,E,CP;
output Q;
reg E_D;
  
    always @(*)begin
     if(CP == 1'b0)
       E_D = E | TE;
    end
    assign  Q = E_D & CP;
endmodule

module csd_clk_reg_rise (CP, CD,D,Q);
 input CP;
 input CD;
 input D;
 output Q;

  always @(posedge CP or posedge CD) 
  begin
        if(CD) Q <= 1'b0;
        else   Q <= D;
  end

endmodule

module clk_and(A1,A2,Z);
input A1;
input A2;
output Z;

 assign Z = A1 && A2;

endmodule


*/

module csd_clk_reg_rise (/*AUTOARG*/CP, CD,D,Q);
 input CP,CD,D;
 output Q;
 SDFRPQ_Wrap U_DONT_SDFPRQ (.CP(CP),.D(D),.CD(CD),.Q(Q));
endmodule

module clk_gate_cell_type3 (/*AUTOARG*/TE,E,CP,Q);
input TE,E,CP;
output Q;
CKLN_Wrap U_DONT_CKLN (.CP(CP),.E(E),.TE(TE),.Q(Q));
endmodule

module clk_and(A1,A2,Z);
input A1;
input A2;
output Z;

CKAnd2_Wrap U_DONT_CK_AND2 (.A1(A1),.A2(A2),.Z(Z));

endmodule

//==============================================================================
//             CDC lib cells
//==============================================================================

//Limitation: Only used for gray code sync .
module multi_bit_sync2_cell_rstb #(
    parameter BUS_WIDTH = 10
)(qout,clk, reset_n, data);
input clk, reset_n;
input   [BUS_WIDTH-1:0] data;
output  [BUS_WIDTH-1:0] qout;
genvar i ;
generate 
    for(i = 0; i < BUS_WIDTH; i = i+1) begin:SYNC2_CELL_RSTB_BK
        sync2_cell_rstb u_sync2_cell_rstb(
            .clk(clk), 
            .reset_n(reset_n), 
            .data(data[i]), 
            .qout(qout[i]));
    end
endgenerate

endmodule

//Limitation: Only used for gray code sync .
module multi_bit_sync2_cell #(
    parameter BUS_WIDTH = 10
)(qout,clk, reset, data);
input clk, reset;
input   [BUS_WIDTH-1:0] data;
output  [BUS_WIDTH-1:0] qout;
genvar i ;
generate 
    for(i = 0;i < BUS_WIDTH; i = i+1) begin:SYNC2_CELL_BK
        sync2_cell u_sync2_cell(
            .clk(clk), 
            .reset(reset), 
            .data(data[i]), 
            .qout(qout[i]));
    end
endgenerate

endmodule


module sync2_cell (clk, reset, data, qout);
input clk, reset, data;
output qout;

//wire reset_n;

`ifdef ADD_WAM
`WAM_PROC
SDFSYNC2RPQ_DO_Wrap U_DONT_SYNC2( .Q(qout), .CP_D(clk), .D(in_sync_wam), .CD_D(reset) );
`else
//Inv_Wrap U_DONT_RST_INV (.A(reset), .ZN(reset_n));
SDFSYNC2RPQ_DO_Wrap U_DONT_SYNC2( .Q(qout), .CP_D(clk), .D(data), .CD_D(reset) );
`endif

endmodule

module sync2_cell_dly (clk, reset, data, qout);
input clk, reset, data;
output qout;

`ifdef ADD_WAM
`WAM_PROC
SDFSYNC2RPQ_DO_Wrap U_DONT_SYNC2( .Q(qout), .CP_D(clk), .D(in_sync_wam), .CD_D(reset) );
`else
SDFSYNC2RPQ_DO_Wrap U_DONT_SYNC2( .Q(qout), .CP_D(clk), .D(data), .CD_D(reset) );
`endif

endmodule

module sync2_cell_rstb (clk, reset_n, data, qout);
input clk, reset_n, data;
output qout;

wire reset;
Inv_Wrap U_DONT_RST_INV (.A(reset_n), .ZN(reset));
`ifdef ADD_WAM
`WAM_PROC
SDFSYNC2RPQ_DO_Wrap U_DONT_SYNC2( .Q(qout), .CP_D(clk), .D(in_sync_wam), .CD_D(reset) );
`else
SDFSYNC2RPQ_DO_Wrap U_DONT_SYNC2( .Q(qout), .CP_D(clk), .D(data), .CD_D(reset) );
`endif

endmodule


module sync2_cell_set (clk, set, data, qout);
input clk, set, data;
output qout;

wire set_n;

Inv_Wrap U_DONT_RST_INV (.A(set), .ZN(set_n));
`ifdef ADD_WAM
`WAM_PROC
SDFSYNC2SNQ_DO_Wrap U_DONT_SYNC2( .Q(qout), .CK(clk), .D(in_sync_wam), .SDN(set_n));
`else
SDFSYNC2SNQ_DO_Wrap U_DONT_SYNC2( .Q(qout), .CK(clk), .D(data), .SDN(set_n));
`endif

endmodule

module sync2_cell_set_dly (clk, set, data, qout);
input clk, set, data;
output qout;

wire   set_n;

Inv_Wrap U_DONT_RST_INV (.A(set), .ZN(set_n));
`ifdef ADD_WAM
`WAM_PROC
SDFSYNC2SNQ_DO_Wrap U_DONT_SYNC2( .Q(qout), .CK(clk), .D(in_sync_wam), .SDN(set_n));
`else
SDFSYNC2SNQ_DO_Wrap U_DONT_SYNC2( .Q(qout), .CK(clk), .D(data), .SDN(set_n));
`endif

endmodule
module sync2_cell_setb (clk, set_n, data, qout);
input clk, set_n, data;
output qout;

`ifdef ADD_WAM
`WAM_PROC
SDFSYNC2SNQ_DO_Wrap U_DONT_SYNC2( .Q(qout), .CK(clk), .D(in_sync_wam), .SDN(set_n));
`else
SDFSYNC2SNQ_DO_Wrap U_DONT_SYNC2( .Q(qout), .CK(clk), .D(data), .SDN(set_n));
`endif

endmodule

module pulse_sync_hs(SRC_CK, SRC_RST, DST_CK, DST_RST, SRC_PULSE, DST_PULSE);
/*
hs: hand shake
Sync Type: High pulse sync hand shake
Pulse MODE: 0: aligned the rise edge of the destination clock, 1: aligned the falling edge of the destination clock.
Limitation: The space between two continuous high pulse should be greater than 2SRC_CK + 2DST_CK cycles.
This module is to synchronize clock pulse from one clock domain to another, from SRC_CK to DST_CK
This synchronization is done by asserting internal signal when input pulse comes in and reset it when output pulse is generated
The limitation is input pulse cannot come continuously faster than DST_CK
If it does come too fast, before DST_PULSE is generated, only the first pulse will pass through, intermediate ones will be ignored
This module is suitable when SRC_PULSE is possibly generated multiple times to deliver the same message
2023-08-17 Bin Yuan
*/
input         SRC_CK; //Source clock
input         SRC_RST; //Source reset
input         DST_CK;//Destination clock
input         DST_RST;//Destination Reset
input         SRC_PULSE; //Source rise edge clock, last for one clock cycle, otherwise will case an assertion error
output        DST_PULSE; //Destination rise edge clock, last for one clock cycle

parameter PULSE_MODE = 0; //0: rise edge detect in destinaton domain, 1: falling edge detect in the destination domain

reg    src_level;
wire   dst_level;
reg    dst_level_d1;
wire   src_level_feedback;

always@(posedge SRC_CK or posedge SRC_RST)
  if(SRC_RST) src_level <= 1'b0;
  else if (src_level_feedback) src_level <= 1'b0;
  else if (SRC_PULSE) src_level <= 1'b1;

sync2_cell u_pulse_sync_1 (.clk(DST_CK), .reset(DST_RST), .data(src_level), .qout(dst_level));

always@(posedge DST_CK or posedge DST_RST)
  if(DST_RST) dst_level_d1 <= 1'b0;
  else dst_level_d1 <= dst_level;
  
generate 
   if(PULSE_MODE <= 0) begin : GEN_PLSMD0
      assign DST_PULSE = dst_level & ~dst_level_d1; //rising edge
   end
   if(PULSE_MODE == 1) begin : GEN_PLSMD1
      assign DST_PULSE = ~dst_level & dst_level_d1; //falling edge
   end
//   if(PULSE_MODE == 2) begin: GEN_PLSMD2
//      assign DST_PULSE = dst_level ^ dst_level_d1; //edge detect
//   end
endgenerate

sync2_cell u_pulse_sync_2 (.clk(SRC_CK), .reset(SRC_RST), .data(dst_level), .qout(src_level_feedback));

`ifdef _CDC_SIM_CHCK
assert property (@(posedge SRC_CK) disable iff (!DST_RST) SRC_PULSE |-> ##1 !SRC_PULSE) else $error("source pulse last for more than one clock cycle!"); //pulse must be only one cycle
assert property (@(posedge SRC_CK) disable iff (!DST_RST) SRC_PULSE |-> src_level) $error ("Detect the space of the two continuouse pusles is underflow the safe space clock cycle!");//
`endif

endmodule


module pulse_sync_hs_ack(SRC_CK, SRC_RST, DST_CK, DST_RST, SRC_PULSE, DST_PULSE, PULSE_ACK, IS_BUSY);
/*
hs: hand shake
Sync Type: High pulse sync hand shake
Pulse MODEL: 0: aligned the rise edge of the destination clock, 1: aligned the falling edge of the destination clock.
Limitation: The space between two continuous high pulse should be greater than 2SRC_CK + 2DST_CK cycles.
This module is to synchronize clock pulse from one clock domain to another, from SRC_CK to DST_CK
This synchronization is done by asserting internal signal when input pulse comes in and reset it when output pulse is generated
The limitation is input pulse cannot come continuously faster than DST_CK
If it does come too fast, before DST_PULSE is generated, only the first pulse will pass through, intermediate ones will be ignored
This module is suitable when SRC_PULSE is possibly generated multiple times to deliver the same message
2023-08-17 Bin Yuan
*/
input         SRC_CK; //Source clock
input         SRC_RST; //Source reset
input         DST_CK;//Destination clock
input         DST_RST;//Destination Reset
input         SRC_PULSE; //Source rise edge clock, last for one clock cycle, otherwise will case an assertion error
output        DST_PULSE; //Destination rise edge clock, last for one clock cycle
output        PULSE_ACK; //One clock cycle pulse
output        IS_BUSY;  //Indicate the Synchronizer is busy

parameter PULSE_MODE = 0; //0: rise edge detect in destinaton domain, 1: falling edge detect in the destination domain

reg    src_level;
reg    src_level_d1;
wire   dst_level;
reg    dst_level_d1;
wire   src_level_feedback;

always@(posedge SRC_CK or posedge SRC_RST)
  if(SRC_RST) src_level <= 1'b0;
  else if (src_level_feedback) src_level <= 1'b0;
  else if (SRC_PULSE) src_level <= 1'b1;

sync2_cell u_pulse_sync_1 (.clk(DST_CK), .reset(DST_RST), .data(src_level), .qout(dst_level));

always@(posedge DST_CK or posedge DST_RST)
  if(DST_RST) dst_level_d1 <= 1'b0;
  else dst_level_d1 <= dst_level;
generate 
   if(PULSE_MODE <= 0) begin : GEN_PLSMD0
      assign DST_PULSE = dst_level & ~dst_level_d1; //rising edge
   end
   if(PULSE_MODE == 1) begin: GEN_PLSMD1
      assign DST_PULSE = ~dst_level & dst_level_d1; //falling edge
   end
endgenerate

sync2_cell u_pulse_sync_2 (.clk(SRC_CK), .reset(SRC_RST), .data(dst_level), .qout(src_level_feedback));

always@(posedge SRC_CK or posedge SRC_RST)
  if(SRC_RST) src_level_d1 <= 1'b0;
  else src_level_d1 <= src_level;
  
assign PULSE_ACK = ~src_level & src_level_d1;
assign IS_BUSY = src_level;

`ifdef _CDC_SIM_CHCK
assert property (@(posedge SRC_CK) disable iff (!DST_RST) SRC_PULSE |-> ##1 !SRC_PULSE) else $error("source pulse last for more than one clock cycle!"); //pulse must be only one cycle
assert property (@(posedge SRC_CK) disable iff (!DST_RST) SRC_PULSE |-> src_level) $error ("Detect the space of the two continuouse pusles is underflow the safe space clock cycle!");//
`endif

endmodule


module databus_sync_dmux (/*AUTOARG*/SRC_CK,SRC_RST,SRC_DATA,SRC_PULSE,DST_CK,DST_RST,DST_DATA,DST_PULSE);
/*
Data Bus Sync Type: Data MuX structure
Limitation: The space between two continuous high pulse should be greater than 2SRC_CK + 2DST_CK cycles. Otherwise the bus sync will be not valid. 
                    For PT check, the bus max delay from "src_data_ff" to "dst_data_ff" must less than one DST_CK clock cycle, recommend to set the bus max delay is half of the period of the destination clock.
This module is to synchronize the data from one clock domain to another, from SRC_CK to DST_CK
This synchronization is done by using the Pulse rising edge handshake synchromizator "pulse_sync_hs"
The limitation is input pulse cannot come continuously faster than DST_CK
If it does come too fast, before DST_PULSE is generated, only the first pulse will pass through, intermediate ones will be ignored
This module is suitable when SRC_PULSE is possibly generated multiple times to deliver the same message
The max bus max delay from "src_data_ff" to "dst_data_ff" must less than one DST_CK clock cycle, recommend to set the bus max delay is half of the period of the destination clock.
2023-08-30 Bin Yuan
*/
parameter D_WIDTH = 8;

input [D_WIDTH-1:0] SRC_DATA;
input               SRC_PULSE;//
input SRC_CK;
input SRC_RST;
input DST_CK;
input DST_RST;
output [D_WIDTH-1:0] DST_DATA;
output               DST_PULSE;

reg [D_WIDTH-1: 0] src_data_ff;
reg [D_WIDTH-1: 0] dst_data_ff;
reg                src_pulse_d1;
reg                DST_PULSE;

wire [D_WIDTH-1:0] DST_DATA;
wire               dst_pule_ack;

always @(posedge SRC_CK or posedge SRC_RST) begin
    if(SRC_RST) src_data_ff <= {D_WIDTH{1'b0}};
    else if(SRC_PULSE) src_data_ff <= SRC_DATA;
end
always @(posedge SRC_CK or posedge SRC_RST) begin
    if(SRC_RST) src_pulse_d1 <= 1'b0;
    else src_pulse_d1 <= SRC_PULSE;//delay pulse for one clock cycle to make sure that src_data_ff is stable before synced it to the destination clock domain. 
end

pulse_sync_hs  #(.PULSE_MODE(1'b0)) u_pulse_sync_hs(.SRC_CK(SRC_CK), .SRC_RST(SRC_RST), .DST_CK(DST_CK), .DST_RST(DST_RST), .SRC_PULSE(src_pulse_d1), .DST_PULSE(dst_pule_ack));

always @(posedge DST_CK or posedge DST_RST) begin
    if(DST_RST) dst_data_ff <=  {D_WIDTH{1'b0}};
    else if(dst_pule_ack) dst_data_ff <= src_data_ff;
end
always @(posedge DST_CK or posedge DST_RST) begin
    if(DST_RST) DST_PULSE <=  1'b0;
    else DST_PULSE <= dst_pule_ack;
end

assign DST_DATA = dst_data_ff;

endmodule

module databus_sync_dmux_ack (/*AUTOARG*/SRC_CK,SRC_RST,SRC_DATA,SRC_PULSE,SRC_IS_BUSY,DST_CK,DST_RST,DST_DATA,DST_PULSE);
/*
Data Bus Sync Type: Data MuX Structure with ACK
Limitation: The space between two continuous high pulse should be greater than 2SRC_CK + 2DST_CK cycles. Otherwise the bus sync will be not valid. 
            For PT check, the bus max delay from "src_data_ff" to "dst_data_ff" must less than one DST_CK clock cycle, recommend to set the bus max delay is half of the period of the destination clock. 
            When SRC_IS_BUSY is asserted, indicate the synchronizator is busy. When the SRC_IS_BUSY = 1, the incoming SRC_PULSE will be ignored.
This module is to synchronize the data from one clock domain to another, from SRC_CK to DST_CK
This synchronization is done by using the Pulse rising edge handshake synchromizator "pulse_sync_hs"
The limitation is input pulse cannot come continuously faster than DST_CK
If it does come too fast, before DST_PULSE is generated, only the first pulse will pass through, intermediate ones will be ignored
This module is suitable when SRC_PULSE is possibly generated multiple times to deliver the same message
The max bus max delay from "src_data_ff" to "dst_data_ff" must less than one DST_CK clock cycle, recommend to set the bus max delay is half of the period of the destination clock.
2023-08-30 Bin Yuan
*/
parameter D_WIDTH = 8;

input [D_WIDTH-1:0] SRC_DATA;
input               SRC_PULSE;//
input  SRC_CK;
input  SRC_RST;
input  DST_CK;
input  DST_RST;
output [D_WIDTH-1:0] DST_DATA;
output               DST_PULSE;
output               SRC_IS_BUSY; //when it is asserted, indicate the synchronizator is busy, the 

reg [D_WIDTH-1: 0] src_data_ff;
reg [D_WIDTH-1: 0] dst_data_ff;
reg                src_pulse_d1;
reg                DST_PULSE;
reg                SRC_IS_BUSY;

wire [D_WIDTH-1:0] DST_DATA;
wire               dst_pule_ack;
wire               is_busy;
wire               is_busy_fall;
wire               src_pulse_gated;

assign  src_pulse_gated = SRC_PULSE & ~SRC_IS_BUSY;
always @(posedge SRC_CK or posedge SRC_RST) begin
    if(SRC_RST) src_data_ff <= {D_WIDTH{1'b0}};
    else if(src_pulse_gated) src_data_ff <= SRC_DATA;
end

always @(posedge SRC_CK or posedge SRC_RST) begin
    if(SRC_RST) src_pulse_d1 <= 1'b0;
    else src_pulse_d1 <= src_pulse_gated; //delay pulse for one clock cycle to make sure that src_data_ff is stable before synced it to the destination clock domain. 
end
pulse_sync_hs_ack  #(.PULSE_MODE(1'b0)) u_pulse_sync_hs_ack(/*AUTOINST*/.SRC_CK(SRC_CK), .SRC_RST(SRC_RST), .DST_CK(DST_CK), .DST_RST(DST_RST), .SRC_PULSE(src_pulse_d1), .DST_PULSE(dst_pule_ack), .IS_BUSY(is_busy));

always @(posedge SRC_CK or posedge SRC_RST) begin
    if(SRC_RST) SRC_IS_BUSY <= 1'b0;
    else if ( is_busy_fall ) SRC_IS_BUSY <= 1'b0;
    else if (SRC_PULSE) SRC_IS_BUSY <= 1'b1;
end
edge_det #(.PULSE_MODE(1'b1)) u_is_busy (.clk(SRC_CK),.reset(SRC_RST),.din(is_busy),.d_edge(is_busy_fall));//falling edge detect

always @(posedge DST_CK or posedge DST_RST) begin
    if(DST_RST) dst_data_ff <=  {D_WIDTH{1'b0}};
    else if(dst_pule_ack) dst_data_ff <= src_data_ff;
end
always @(posedge DST_CK or posedge DST_RST) begin
    if(DST_RST) DST_PULSE <=  1'b0;
    else DST_PULSE <= dst_pule_ack;
end
assign DST_DATA = dst_data_ff;

endmodule


//module MIPI_HOST_DWC_mipi_csi2_host_bcm23 (
//             clk_s, 
//             rst_s_n, 
//             event_s, 
//             ack_s,
//             busy_s,
//
//             clk_d, 
//             rst_d_n, 
//             event_d
//             );
//
// parameter REG_EVENT    = 1;    // RANGE 0 to 1
// parameter REG_ACK      = 1;    // RANGE 0 to 1
// parameter ACK_DELAY    = 1;    // RANGE 0 to 1
// parameter F_SYNC_TYPE  = 2;    // RANGE 0 to 4
// parameter R_SYNC_TYPE  = 2;    // RANGE 0 to 4
// parameter VERIF_EN     = 1;    // RANGE 0 to 4
// parameter PULSE_MODE   = 0;    // RANGE 0 to 3
// parameter SVA_TYPE     = 0;
//
// 
//input  clk_s;                   // clock input for source domain
//input  rst_s_n;                 // active low async. reset in clk_s domain
//input  event_s;                 // event pulseack input (active high event)
//output ack_s;                   // event pulseack output (active high event)
//output busy_s;                  // event pulseack output (active high event)
//
//input  clk_d;                   // clock input for destination domain
//input  rst_d_n;                 // active low async. reset in clk_d domain
//output event_d;                 // event pulseack output (active high event)
//
//wire   tgl_s_event_cc;
//wire   tgl_d_event_cc;
//reg    tgl_s_event_q;
//reg    tgl_s_evnt_nfb_cdc;
//wire   tgl_s_ack_x;
//reg    event_s_cap;
//
//wire   tgl_s_event_x;
//wire   tgl_d_event_d;
//wire   tgl_d_event_a;
//
//wire   tgl_s_ack_d;
//reg    srcdom_ack;
//reg    tgl_s_ack_q;
//wire   nxt_busy_state;
//reg    busy_state;
//wire   tgl_d_event_dx;    // event seen via edge detect (before registered)
//reg    tgl_d_event_q;     // registered version of event seen
//reg    tgl_d_event_qx;    // xor of dest dom data and registered version
//
//`ifndef SYNTHESIS
//`ifndef DWC_DISABLE_CDC_METHOD_REPORTING
//  initial begin
//    if ((F_SYNC_TYPE > 0)&&(F_SYNC_TYPE < 8))
//       $display("Information: *** Instance %m module is using the <Toggle Type Event Sychronizer with busy and acknowledge (3)> Clock Domain Crossing Method ***");
//  end
//
//`endif
//`endif
//
//  
//  always @ (posedge clk_s or negedge rst_s_n) begin : event_lauch_reg_PROC
//    if (rst_s_n == 1'b0) begin
//      tgl_s_event_q    <= 1'b0;
//      tgl_s_evnt_nfb_cdc<= 1'b0;
//      busy_state       <= 1'b0;
//// spyglass disable_block W528
//// SMD: A signal or variable is set but never read
//// SJ: Based on component configuration, this(these) signal(s) or parts of it will not be used to compute the final result.
//      srcdom_ack       <= 1'b0;
//// spyglass enable_block W528
//      tgl_s_ack_q      <= 1'b0;
//// spyglass disable_block W528
//// SMD: A signal or variable is set but never read
//// SJ: Based on component configuration, this(these) signal(s) or parts of it will not be used to compute the final result.
//      event_s_cap      <= 1'b0;
//// spyglass enable_block W528
//    end else begin
//      tgl_s_event_q    <= tgl_s_event_x;
//      tgl_s_evnt_nfb_cdc<= tgl_s_event_x;
//      busy_state       <= nxt_busy_state;
//      srcdom_ack       <= tgl_s_ack_x;
//      tgl_s_ack_q      <= tgl_s_ack_d;
//      event_s_cap      <= event_s;
//    end 
//  end // always : event_lauch_reg_PROC
//
//
//
//  assign tgl_s_event_cc = tgl_s_evnt_nfb_cdc;
//
//  MIPI_HOST_DWC_mipi_csi2_host_bcm21
//   #(1, F_SYNC_TYPE+8, VERIF_EN, 1) U_DW_SYNC_F(
//        .clk_d(clk_d),
//        .rst_d_n(rst_d_n),
//        .data_s(tgl_s_event_cc),
//        .data_d(tgl_d_event_d) );
//
//
//  assign tgl_d_event_cc = tgl_d_event_a;
//
//  MIPI_HOST_DWC_mipi_csi2_host_bcm21
//   #(1, R_SYNC_TYPE+8, VERIF_EN, 1) U_DW_SYNC_R(
//        .clk_d(clk_s),
//        .rst_d_n(rst_s_n),
//        .data_s(tgl_d_event_cc),
//        .data_d(tgl_s_ack_d) );
//
//  always @ (posedge clk_d or negedge rst_d_n) begin : second_sync_PROC
//    if (rst_d_n == 1'b0) begin
//      tgl_d_event_q      <= 1'b0;
//// spyglass disable_block W528
//// SMD: A signal or variable is set but never read
//// SJ: Based on component configuration, this(these) signal(s) or parts of it will not be used to compute the final result.
//      tgl_d_event_qx     <= 1'b0;
//// spyglass enable_block W528
//    end else begin
//      tgl_d_event_q      <= tgl_d_event_d;
//      tgl_d_event_qx     <= tgl_d_event_dx;
//    end
//  end // always
//
//
//generate
//    
//    if (PULSE_MODE <= 0) begin : GEN_PLSMD0
//      assign tgl_s_event_x = tgl_s_event_q   ^ (event_s && (! busy_state));
//    end
//    
//    if (PULSE_MODE == 1) begin : GEN_PLSMD1
//      assign tgl_s_event_x = tgl_s_event_q   ^ (! busy_state &(event_s & (! event_s_cap)));
//    end
//    
//    if (PULSE_MODE == 2) begin : GEN_PLSMD2
//      assign tgl_s_event_x = tgl_s_event_q  ^ (! busy_state &(event_s_cap & (!event_s)));
//    end
//    
//    if (PULSE_MODE >= 3) begin : GEN_PLSMD3
//      assign tgl_s_event_x = tgl_s_event_q ^ (! busy_state & (event_s ^ event_s_cap));
//    end
//
//endgenerate
//  assign tgl_d_event_dx = tgl_d_event_d ^ tgl_d_event_q;
//  //assign tgl_s_event_x  = tgl_s_event_q ^ (event_s & ! busy_s);
//  assign tgl_s_ack_x    = tgl_s_ack_d   ^ tgl_s_ack_q;
//  assign nxt_busy_state = tgl_s_event_x ^ tgl_s_ack_d;
//
//  generate
//    if (REG_EVENT == 0) begin : GEN_RGEVT0
//      assign event_d       = tgl_d_event_dx;
//    end
//
//    else begin : GEN_RGRVT1
//      assign event_d       = tgl_d_event_qx;
//    end
//  endgenerate
//
//  generate
//    if (REG_ACK == 0) begin : GEN_RGACK0
//      assign ack_s         = tgl_s_ack_x;
//    end
//
//    else begin : GEN_RGACK1
//      assign ack_s         = srcdom_ack;
//    end
//  endgenerate
//
//  generate
//    if (ACK_DELAY == 0) begin : GEN_AKDLY0
//      assign tgl_d_event_a = tgl_d_event_d;
//    end
//
//    else begin : GEN_AKDLY1
//      reg tgl_d_event_nfb_cdc;
//
//      always @ (posedge clk_d or negedge rst_d_n) begin : third_sync_PROC
//        if (rst_d_n == 1'b0) begin
//          tgl_d_event_nfb_cdc <= 1'b0;
//        end else begin
//          tgl_d_event_nfb_cdc <= tgl_d_event_d;
//        end
//      end // always
//
//      assign tgl_d_event_a = tgl_d_event_nfb_cdc;
//    end
//  endgenerate
//
//
//  assign busy_s = busy_state;
//
//`ifdef DWC_BCM_SNPS_ASSERT_ON
//`ifndef SYNTHESIS
//
//  DWC_mipi_csi2_host_sva03 #(F_SYNC_TYPE&7,  PULSE_MODE) P_PULSEACK_SYNC_HS (.*);
//
//  generate if (SVA_TYPE == 1) begin : GEN_SVATP_EQ_1
//    DWC_mipi_csi2_host_sva02 #(
//      .F_SYNC_TYPE    (F_SYNC_TYPE&7),
//      .PULSE_MODE     (PULSE_MODE   )
//    ) P_PULSE_SYNC_HS (
//        .clk_s        (clk_s        )
//      , .rst_s_n      (rst_s_n      )
//      , .event_s      (event_s      )
//      , .event_d      (event_d      )
//    );
//  end endgenerate
//
//  generate if ((F_SYNC_TYPE==0) || (R_SYNC_TYPE==0)) begin : GEN_SINGLE_CLOCK_CANDIDATE
//    DWC_mipi_csi2_host_sva07 #(F_SYNC_TYPE, R_SYNC_TYPE) P_CDC_CLKCOH (.*);
//  end endgenerate
//
//`endif // SYNTHESIS
//`endif // DWC_BCM_SNPS_ASSERT_ON
//
//endmodule
//
module edge_det (clk,reset,din,d_edge);
/*

*/
parameter PULSE_MODE = 0; // 0: rising edge; 1: falling edge ; 2: both rising edge or falling edge

input  clk;
input  reset;
input  din;
output d_edge;

reg din_d;

always @(posedge clk or posedge reset) begin
    if(reset) din_d <= 1'b0;
    else din_d <= din;
end

generate 
   if(PULSE_MODE <= 0) begin : GEN_PLSMD0
      assign d_edge = din & ~din_d; //rising edge
   end
   if(PULSE_MODE == 1) begin: GEN_PLSMD1
      assign d_edge = ~din & din_d; //falling edge
   end
   if(PULSE_MODE == 2) begin: GEN_PLSMD2
      assign d_edge = din ^ din_d;
   end
endgenerate

endmodule

===FILE_END===dig_cell.v===
